<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>parameterize API documentation</title>
<meta name="description" content="QMMMReBind : Quantum Mechanics – Molecular Mechanics ( *QMMM* ) forcefield
*Re*paramaterisation of the *Bind*ing site for the receptor-ligand complexes" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>parameterize</code></h1>
</header>
<section id="section-intro">
<p>QMMMReBind : Quantum Mechanics – Molecular Mechanics ( <em>QMMM</em> ) forcefield
<em>Re</em>paramaterisation of the <em>Bind</em>ing site for the receptor-ligand complexes</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
QMMMReBind : Quantum Mechanics – Molecular Mechanics ( *QMMM* ) forcefield 
*Re*paramaterisation of the *Bind*ing site for the receptor-ligand complexes
&#34;&#34;&#34;

import openforcefield.typing.engines.smirnoff
from biopandas.pdb import PandasPdb
import matplotlib.pyplot as plt
from operator import itemgetter
import openforcefield.topology
from mendeleev import element
from simtk.openmm import app
from scipy import optimize
import subprocess as sp
from sys import stdout
import openforcefield
import pandas as pd
import numpy as np
import statistics
import itertools
import parmed
import pickle
import shutil
import simtk
import scipy
import time
import math
import sys
import re
import os

element_list = [
    [&#34;1 &#34;, &#34;H &#34;, &#34;Hydrogen&#34;],
    [&#34;2 &#34;, &#34;He&#34;, &#34;Helium&#34;],
    [&#34;3 &#34;, &#34;Li&#34;, &#34;Lithium&#34;],
    [&#34;4 &#34;, &#34;Be&#34;, &#34;Beryllium&#34;],
    [&#34;5 &#34;, &#34;B &#34;, &#34;Boron&#34;],
    [&#34;6 &#34;, &#34;C &#34;, &#34;Carbon&#34;],
    [&#34;7 &#34;, &#34;N &#34;, &#34;Nitrogen&#34;],
    [&#34;8 &#34;, &#34;O &#34;, &#34;Oxygen&#34;],
    [&#34;9 &#34;, &#34;F &#34;, &#34;Fluorine&#34;],
    [&#34;10&#34;, &#34;Ne&#34;, &#34;Neon&#34;],
    [&#34;11&#34;, &#34;Na&#34;, &#34;Sodium&#34;],
    [&#34;12&#34;, &#34;Mg&#34;, &#34;Magnesium&#34;],
    [&#34;13&#34;, &#34;Al&#34;, &#34;Aluminum&#34;],
    [&#34;14&#34;, &#34;Si&#34;, &#34;Silicon&#34;],
    [&#34;15&#34;, &#34;P &#34;, &#34;Phosphorus&#34;],
    [&#34;16&#34;, &#34;S &#34;, &#34;Sulfur&#34;],
    [&#34;17&#34;, &#34;Cl&#34;, &#34;Chlorine&#34;],
    [&#34;18&#34;, &#34;Ar&#34;, &#34;Argon&#34;],
    [&#34;19&#34;, &#34;K &#34;, &#34;Potassium&#34;],
    [&#34;20&#34;, &#34;Ca&#34;, &#34;Calcium&#34;],
    [&#34;21&#34;, &#34;Sc&#34;, &#34;Scandium&#34;],
    [&#34;22&#34;, &#34;Ti&#34;, &#34;Titanium&#34;],
    [&#34;23&#34;, &#34;V &#34;, &#34;Vanadium&#34;],
    [&#34;24&#34;, &#34;Cr&#34;, &#34;Chromium&#34;],
    [&#34;25&#34;, &#34;Mn&#34;, &#34;Manganese&#34;],
    [&#34;26&#34;, &#34;Fe&#34;, &#34;Iron&#34;],
    [&#34;27&#34;, &#34;Co&#34;, &#34;Cobalt&#34;],
    [&#34;28&#34;, &#34;Ni&#34;, &#34;Nickel&#34;],
    [&#34;29&#34;, &#34;Cu&#34;, &#34;Copper&#34;],
    [&#34;30&#34;, &#34;Zn&#34;, &#34;Zinc&#34;],
    [&#34;31&#34;, &#34;Ga&#34;, &#34;Gallium&#34;],
    [&#34;32&#34;, &#34;Ge&#34;, &#34;Germanium&#34;],
    [&#34;33&#34;, &#34;As&#34;, &#34;Arsenic&#34;],
    [&#34;34&#34;, &#34;Se&#34;, &#34;Selenium&#34;],
    [&#34;35&#34;, &#34;Br&#34;, &#34;Bromine&#34;],
    [&#34;36&#34;, &#34;Kr&#34;, &#34;Krypton&#34;],
    [&#34;37&#34;, &#34;Rb&#34;, &#34;Rubidium&#34;],
    [&#34;38&#34;, &#34;Sr&#34;, &#34;Strontium&#34;],
    [&#34;39&#34;, &#34;Y &#34;, &#34;Yttrium&#34;],
    [&#34;40&#34;, &#34;Zr&#34;, &#34;Zirconium&#34;],
    [&#34;41&#34;, &#34;Nb&#34;, &#34;Niobium&#34;],
    [&#34;42&#34;, &#34;Mo&#34;, &#34;Molybdenum&#34;],
    [&#34;43&#34;, &#34;Tc&#34;, &#34;Technetium&#34;],
    [&#34;44&#34;, &#34;Ru&#34;, &#34;Ruthenium&#34;],
    [&#34;45&#34;, &#34;Rh&#34;, &#34;Rhodium&#34;],
    [&#34;46&#34;, &#34;Pd&#34;, &#34;Palladium&#34;],
    [&#34;47&#34;, &#34;Ag&#34;, &#34;Silver&#34;],
    [&#34;48&#34;, &#34;Cd&#34;, &#34;Cadmium&#34;],
    [&#34;49&#34;, &#34;In&#34;, &#34;Indium&#34;],
    [&#34;50&#34;, &#34;Sn&#34;, &#34;Tin&#34;],
    [&#34;51&#34;, &#34;Sb&#34;, &#34;Antimony&#34;],
    [&#34;52&#34;, &#34;Te&#34;, &#34;Tellurium&#34;],
    [&#34;53&#34;, &#34;I &#34;, &#34;Iodine&#34;],
    [&#34;54&#34;, &#34;Xe&#34;, &#34;Xenon&#34;],
    [&#34;55&#34;, &#34;Cs&#34;, &#34;Cesium&#34;],
    [&#34;56&#34;, &#34;Ba&#34;, &#34;Barium&#34;],
    [&#34;57&#34;, &#34;La&#34;, &#34;Lanthanum&#34;],
    [&#34;58&#34;, &#34;Ce&#34;, &#34;Cerium&#34;],
    [&#34;59&#34;, &#34;Pr&#34;, &#34;Praseodymium&#34;],
    [&#34;60&#34;, &#34;Nd&#34;, &#34;Neodymium&#34;],
    [&#34;61&#34;, &#34;Pm&#34;, &#34;Promethium&#34;],
    [&#34;62&#34;, &#34;Sm&#34;, &#34;Samarium&#34;],
    [&#34;63&#34;, &#34;Eu&#34;, &#34;Europium&#34;],
    [&#34;64&#34;, &#34;Gd&#34;, &#34;Gadolinium&#34;],
    [&#34;65&#34;, &#34;Tb&#34;, &#34;Terbium&#34;],
    [&#34;66&#34;, &#34;Dy&#34;, &#34;Dysprosium&#34;],
    [&#34;67&#34;, &#34;Ho&#34;, &#34;Holmium&#34;],
    [&#34;68&#34;, &#34;Er&#34;, &#34;Erbium&#34;],
    [&#34;69&#34;, &#34;Tm&#34;, &#34;Thulium&#34;],
    [&#34;70&#34;, &#34;Yb&#34;, &#34;Ytterbium&#34;],
    [&#34;71&#34;, &#34;Lu&#34;, &#34;Lutetium&#34;],
    [&#34;72&#34;, &#34;Hf&#34;, &#34;Hafnium&#34;],
    [&#34;73&#34;, &#34;Ta&#34;, &#34;Tantalum&#34;],
    [&#34;74&#34;, &#34;W &#34;, &#34;Tungsten&#34;],
    [&#34;75&#34;, &#34;Re&#34;, &#34;Rhenium&#34;],
    [&#34;76&#34;, &#34;Os&#34;, &#34;Osmium&#34;],
    [&#34;77&#34;, &#34;Ir&#34;, &#34;Iridium&#34;],
    [&#34;78&#34;, &#34;Pt&#34;, &#34;Platinum&#34;],
    [&#34;79&#34;, &#34;Au&#34;, &#34;Gold&#34;],
    [&#34;80&#34;, &#34;Hg&#34;, &#34;Mercury&#34;],
    [&#34;81&#34;, &#34;Tl&#34;, &#34;Thallium&#34;],
    [&#34;82&#34;, &#34;Pb&#34;, &#34;Lead&#34;],
    [&#34;83&#34;, &#34;Bi&#34;, &#34;Bismuth&#34;],
    [&#34;84&#34;, &#34;Po&#34;, &#34;Polonium&#34;],
    [&#34;85&#34;, &#34;At&#34;, &#34;Astatine&#34;],
    [&#34;86&#34;, &#34;Rn&#34;, &#34;Radon&#34;],
    [&#34;87&#34;, &#34;Fr&#34;, &#34;Francium&#34;],
    [&#34;88&#34;, &#34;Ra&#34;, &#34;Radium&#34;],
    [&#34;89&#34;, &#34;Ac&#34;, &#34;Actinium&#34;],
    [&#34;90&#34;, &#34;Th&#34;, &#34;Thorium&#34;],
    [&#34;91&#34;, &#34;Pa&#34;, &#34;Protactinium&#34;],
    [&#34;92&#34;, &#34;U &#34;, &#34;Uranium&#34;],
    [&#34;93&#34;, &#34;Np&#34;, &#34;Neptunium&#34;],
    [&#34;94&#34;, &#34;Pu&#34;, &#34;Plutonium&#34;],
    [&#34;95&#34;, &#34;Am&#34;, &#34;Americium&#34;],
    [&#34;96&#34;, &#34;Cm&#34;, &#34;Curium&#34;],
    [&#34;97&#34;, &#34;Bk&#34;, &#34;Berkelium&#34;],
    [&#34;98&#34;, &#34;Cf&#34;, &#34;Californium&#34;],
    [&#34;99&#34;, &#34;Es&#34;, &#34;Einsteinium&#34;],
]


def unit_vector_N(u_BC, u_AB):
    # Calculates unit normal vector which is perpendicular to plane ABC
    cross_product = np.cross(u_BC, u_AB)
    norm_u_N = np.linalg.norm(cross_product)
    u_N = cross_product / norm_u_N
    return u_N


def copy_file(source, destination):
    shutil.copy(source, destination)


def u_PA_from_angles(atom_A, atom_B, atom_C, coords):
    # Gives the vector in the plane A,B,C and perpendicular to A to B
    diff_AB = coords[atom_B, :] - coords[atom_A, :]
    norm_diff_AB = np.linalg.norm(diff_AB)
    u_AB = diff_AB / norm_diff_AB
    diff_CB = coords[atom_B, :] - coords[atom_C, :]
    norm_diff_CB = np.linalg.norm(diff_CB)
    u_CB = diff_CB / norm_diff_CB
    u_N = unit_vector_N(u_CB, u_AB)
    u_PA = np.cross(u_N, u_AB)
    norm_PA = np.linalg.norm(u_PA)
    u_PA = u_PA / norm_PA
    return u_PA


def force_angle_constant(
    atom_A,
    atom_B,
    atom_C,
    bond_lengths,
    eigenvalues,
    eigenvectors,
    coords,
    scaling_1,
    scaling_2,
):
    # Force Constant- Equation 14 of seminario calculation paper - gives force constant for angle 
    # (in kcal/mol/rad^2) and equilibrium angle in degrees
    # Vectors along bonds calculated
    diff_AB = coords[atom_B, :] - coords[atom_A, :]
    norm_diff_AB = np.linalg.norm(diff_AB)
    u_AB = diff_AB / norm_diff_AB
    diff_CB = coords[atom_B, :] - coords[atom_C, :]
    norm_diff_CB = np.linalg.norm(diff_CB)
    u_CB = diff_CB / norm_diff_CB
    # Bond lengths and eigenvalues found
    bond_length_AB = bond_lengths[atom_A, atom_B]
    eigenvalues_AB = eigenvalues[atom_A, atom_B, :]
    eigenvectors_AB = eigenvectors[0:3, 0:3, atom_A, atom_B]
    bond_length_BC = bond_lengths[atom_B, atom_C]
    eigenvalues_CB = eigenvalues[atom_C, atom_B, :]
    eigenvectors_CB = eigenvectors[0:3, 0:3, atom_C, atom_B]
    # Normal vector to angle plane found
    u_N = unit_vector_N(u_CB, u_AB)
    u_PA = np.cross(u_N, u_AB)
    norm_u_PA = np.linalg.norm(u_PA)
    u_PA = u_PA / norm_u_PA
    u_PC = np.cross(u_CB, u_N)
    norm_u_PC = np.linalg.norm(u_PC)
    u_PC = u_PC / norm_u_PC
    sum_first = 0
    sum_second = 0
    # Projections of eigenvalues
    for i in range(0, 3):
        eig_AB_i = eigenvectors_AB[:, i]
        eig_BC_i = eigenvectors_CB[:, i]
        sum_first = sum_first + (
            eigenvalues_AB[i] * abs(dot_product(u_PA, eig_AB_i))
        )
        sum_second = sum_second + (
            eigenvalues_CB[i] * abs(dot_product(u_PC, eig_BC_i))
        )
    # Scaling due to additional angles - Modified Seminario Part
    sum_first = sum_first / scaling_1
    sum_second = sum_second / scaling_2
    # Added as two springs in series
    k_theta = (1 / ((bond_length_AB ** 2) * sum_first)) + (
        1 / ((bond_length_BC ** 2) * sum_second)
    )
    k_theta = 1 / k_theta
    k_theta = -k_theta  # Change to OPLS form
    k_theta = abs(k_theta * 0.5)  # Change to OPLS form
    # Equilibrium Angle
    theta_0 = math.degrees(math.acos(np.dot(u_AB, u_CB)))
    # If the vectors u_CB and u_AB are linearly dependent u_N cannot be defined
    # This case is dealt with here
    if abs(sum((u_CB) - (u_AB))) &lt; 0.01 or (
        abs(sum((u_CB) - (u_AB))) &gt; 1.99 and abs(sum((u_CB) - (u_AB))) &lt; 2.01
    ):
        scaling_1 = 1
        scaling_2 = 1
        [k_theta, theta_0] = force_angle_constant_special_case(
            atom_A,
            atom_B,
            atom_C,
            bond_lengths,
            eigenvalues,
            eigenvectors,
            coords,
            scaling_1,
            scaling_2,
        )
    return k_theta, theta_0


def dot_product(u_PA, eig_AB):
    x = 0
    for i in range(0, 3):
        x = x + u_PA[i] * eig_AB[i].conjugate()
    return x


def force_angle_constant_special_case(
    atom_A,
    atom_B,
    atom_C,
    bond_lengths,
    eigenvalues,
    eigenvectors,
    coords,
    scaling_1,
    scaling_2,
):
    # Force Constant- Equation 14 of seminario calculation paper - gives force constant for angle 
    # (in kcal/mol/rad^2) and equilibrium angle in degrees
    # Deals with cases when u_N cannot be defined and instead takes samples of u_N across a unit sphere.
    # Vectors along bonds calculated
    diff_AB = coords[atom_B, :] - coords[atom_A, :]
    norm_diff_AB = np.linalg.norm(diff_AB)
    u_AB = diff_AB / norm_diff_AB
    diff_CB = coords[atom_B, :] - coords[atom_C, :]
    norm_diff_CB = np.linalg.norm(diff_CB)
    u_CB = diff_CB / norm_diff_CB
    # Bond lengths and eigenvalues found
    bond_length_AB = bond_lengths[atom_A, atom_B]
    eigenvalues_AB = eigenvalues[atom_A, atom_B, :]
    eigenvectors_AB = eigenvectors[0:3, 0:3, atom_A, atom_B]
    bond_length_BC = bond_lengths[atom_B, atom_C]
    eigenvalues_CB = eigenvalues[atom_C, atom_B, :]
    eigenvectors_CB = eigenvectors[0:3, 0:3, atom_C, atom_B]
    k_theta_array = np.zeros((180, 360))
    # Find force constant with varying u_N (with vector uniformly sampled across a sphere)
    for theta in range(0, 180):
        for phi in range(0, 360):
            r = 1
            u_N = [
                r
                * math.sin(math.radians(theta))
                * math.cos(math.radians(theta)),
                r
                * math.sin(math.radians(theta))
                * math.sin(math.radians(theta)),
                r * math.cos(math.radians(theta)),
            ]
            u_PA = np.cross(u_N, u_AB)
            u_PA = u_PA / np.linalg.norm(u_PA)
            u_PC = np.cross(u_CB, u_N)
            u_PC = u_PC / np.linalg.norm(u_PC)
            sum_first = 0
            sum_second = 0
            # Projections of eigenvalues
            for i in range(0, 3):
                eig_AB_i = eigenvectors_AB[:, i]
                eig_BC_i = eigenvectors_CB[:, i]
                sum_first = sum_first + (
                    eigenvalues_AB[i] * abs(dot_product(u_PA, eig_AB_i))
                )
                sum_second = sum_second + (
                    eigenvalues_CB[i] * abs(dot_product(u_PC, eig_BC_i))
                )
            # Added as two springs in series
            k_theta_ij = (1 / ((bond_length_AB ** 2) * sum_first)) + (
                1 / ((bond_length_BC ** 2) * sum_second)
            )
            k_theta_ij = 1 / k_theta_ij
            k_theta_ij = -k_theta_ij  # Change to OPLS form
            k_theta_ij = abs(k_theta_ij * 0.5)  # Change to OPLS form
            k_theta_array[theta, phi] = k_theta_ij
    # Removes cases where u_N was linearly dependent of u_CB or u_AB
    # Force constant used is taken as the mean
    k_theta = np.mean(np.mean(k_theta_array))
    # Equilibrium Angle independent of u_N
    theta_0 = math.degrees(math.cos(np.dot(u_AB, u_CB)))
    return k_theta, theta_0


def force_constant_bond(atom_A, atom_B, eigenvalues, eigenvectors, coords):
    # Force Constant - Equation 10 of Seminario paper - gives force 
    # constant for bond
    # Eigenvalues and eigenvectors calculated
    eigenvalues_AB = eigenvalues[atom_A, atom_B, :]
    eigenvectors_AB = eigenvectors[:, :, atom_A, atom_B]
    # Vector along bond
    diff_AB = np.array(coords[atom_B, :]) - np.array(coords[atom_A, :])
    norm_diff_AB = np.linalg.norm(diff_AB)
    unit_vectors_AB = diff_AB / norm_diff_AB
    k_AB = 0
    # Projections of eigenvalues
    for i in range(0, 3):
        dot_product = abs(np.dot(unit_vectors_AB, eigenvectors_AB[:, i]))
        k_AB = k_AB + (eigenvalues_AB[i] * dot_product)
    k_AB = -k_AB * 0.5  # Convert to OPLS form
    return k_AB


def u_PA_from_angles(atom_A, atom_B, atom_C, coords):
    # Gives the vector in the plane A,B,C and perpendicular to A to B
    diff_AB = coords[atom_B, :] - coords[atom_A, :]
    norm_diff_AB = np.linalg.norm(diff_AB)
    u_AB = diff_AB / norm_diff_AB
    diff_CB = coords[atom_B, :] - coords[atom_C, :]
    norm_diff_CB = np.linalg.norm(diff_CB)
    u_CB = diff_CB / norm_diff_CB
    u_N = unit_vector_N(u_CB, u_AB)
    u_PA = np.cross(u_N, u_AB)
    norm_PA = np.linalg.norm(u_PA)
    u_PA = u_PA / norm_PA
    return u_PA


def reverse_list(lst):
    reversed_list = lst[::-1]
    return reversed_list


def uniq(input_):
    output = []
    for x in input_:
        if x not in output:
            output.append(x)
    return output


def search_in_file(file: str, word: str) -&gt; list:
    &#34;&#34;&#34;
    Search for the given string in file and return lines containing 
    that string along with line numbers
    &#34;&#34;&#34;
    line_number = 0
    list_of_results = []
    with open(file, &#34;r&#34;) as f:
        for line in f:
            line_number += 1
            if word in line:
                list_of_results.append((line_number, line.rstrip()))
    return list_of_results


def OPLS_LJ(system):
    forces = {
        system.getForce(index).__class__.__name__: system.getForce(index)
        for index in range(system.getNumForces())
    }
    nonbonded_force = forces[&#34;NonbondedForce&#34;]
    lorentz = simtk.openmm.openmm.CustomNonbondedForce(
        &#34;4*epsilon*((sigma/r)^12-(sigma/r)^6); sigma=sqrt(sigma1*sigma2); epsilon=sqrt(epsilon1*epsilon2)&#34;
    )
    lorentz.setNonbondedMethod(nonbonded_force.getNonbondedMethod())
    lorentz.addPerParticleParameter(&#34;sigma&#34;)
    lorentz.addPerParticleParameter(&#34;epsilon&#34;)
    lorentz.setCutoffDistance(nonbonded_force.getCutoffDistance())
    system.addForce(lorentz)
    LJset = {}
    for index in range(nonbonded_force.getNumParticles()):
        charge, sigma, epsilon = nonbonded_force.getParticleParameters(index)
        LJset[index] = (sigma, epsilon)
        lorentz.addParticle([sigma, epsilon])
        nonbonded_force.setParticleParameters(
            index, charge, sigma, epsilon * 0
        )
    for i in range(nonbonded_force.getNumExceptions()):
        (p1, p2, q, sig, eps) = nonbonded_force.getExceptionParameters(i)
        lorentz.addExclusion(p1, p2)
        if eps._value != 0.0:
            # print (p1,p2,sig,eps)
            sig14 = math.sqrt(
                LJset[p1][0].value_in_unit(simtk.unit.nanometer)
                * LJset[p2][0].value_in_unit(simtk.unit.nanometer)
            )
            eps14 = math.sqrt(
                LJset[p1][1].value_in_unit(
                    simtk.unit.kilojoule / simtk.unit.mole
                )
                * LJset[p2][1].value_in_unit(
                    simtk.unit.kilojoule / simtk.unit.mole
                )
            )
            nonbonded_force.setExceptionParameters(i, p1, p2, q, sig14, eps)
    return system


def list_to_dict(lst):
    res_dct = {lst[i]: lst[i + 1] for i in range(0, len(lst), 2)}
    return res_dct


def scale_list(list_):
    scaled_list = [i - min(list_) for i in list_]
    return scaled_list


def list_kJ_kcal(list_):
    converted_list = [i / 4.184 for i in list_]
    return converted_list


def list_hartree_kcal(list_):
    converted_list = [i * 627.5094 for i in list_]
    return converted_list


def torsiondrive_input_to_xyz(psi_input_file, xyz_file):
    with open(psi_input_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;molecule {&#34; in lines[i]:
            to_begin = int(i)
        if &#34;set {&#34; in lines[i]:
            to_end = int(i)
    xyz_lines = lines[to_begin + 2 : to_end - 1]
    with open(xyz_file, &#34;w&#34;) as f:
        f.write(str(len(xyz_lines)) + &#34;\n&#34;)
        f.write(xyz_file + &#34;\n&#34;)
        for i in xyz_lines:
            f.write(i)


def xyz_to_pdb(xyz_file, coords_file, template_pdb, system_pdb):
    with open(xyz_file, &#34;r&#34;) as f:
        lines = f.readlines()
    needed_lines = lines[2:]
    with open(coords_file, &#34;w&#34;) as f:
        for i in needed_lines:
            f.write(i)
    df = pd.read_csv(coords_file, header=None, delimiter=r&#34;\s+&#34;)
    df.columns = [&#34;atom&#34;, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;]
    ppdb = PandasPdb()
    ppdb.read_pdb(template_pdb)
    ppdb.df[&#34;ATOM&#34;][&#34;x_coord&#34;] = df[&#34;x&#34;]
    ppdb.df[&#34;ATOM&#34;][&#34;y_coord&#34;] = df[&#34;y&#34;]
    ppdb.df[&#34;ATOM&#34;][&#34;z_coord&#34;] = df[&#34;z&#34;]
    ppdb.to_pdb(system_pdb)


def generate_xml_from_pdb_sdf(system_pdb, system_sdf, system_xml):
    &#34;&#34;&#34;
    This function generates an openforcefield xml file from the pdb file
    &#34;&#34;&#34;
    command = &#34;babel -ipdb &#34; + system_pdb + &#34; -osdf &#34; + system_sdf
    os.system(command)
    off_molecule = openforcefield.topology.Molecule(system_sdf)
    force_field = openforcefield.typing.engines.smirnoff.ForceField(
        &#34;openff_unconstrained-1.0.0.offxml&#34;
    )
    system = force_field.create_openmm_system(off_molecule.to_topology())
    pdbfile = simtk.openmm.app.PDBFile(system_pdb)
    structure = parmed.openmm.load_topology(
        pdbfile.topology, system, xyz=pdbfile.positions
    )
    with open(system_xml, &#34;w&#34;) as f:
        f.write(simtk.openmm.XmlSerializer.serialize(system))


def generate_xml_from_charged_pdb_sdf(
    system_pdb,
    system_init_sdf,
    system_sdf,
    num_charge_atoms,
    index_charge_atom_1,
    charge_atom_1,
    system_xml,
):
    &#34;&#34;&#34;
    This function generates an openforcefield xml file from the pdb 
    file via SDF file and openforcefield.
    &#34;&#34;&#34;
    command = &#34;babel -ipdb &#34; + system_pdb + &#34; -osdf &#34; + system_init_sdf
    os.system(command)
    with open(system_init_sdf, &#34;r&#34;) as f1:
        filedata = f1.readlines()
        filedata = filedata[:-2]
    with open(system_sdf, &#34;w+&#34;) as out:
        for i in filedata:
            out.write(i)
        line_1 = (
            &#34;M  CHG  &#34;
            + str(num_charge_atoms)
            + &#34;   &#34;
            + str(index_charge_atom_1)
            + &#34;   &#34;
            + str(charge_atom_1)
            + &#34;\n&#34;
        )
        line_2 = &#34;M  END&#34; + &#34;\n&#34;
        line_3 = &#34;$$$$&#34;
        out.write(line_1)
        out.write(line_2)
        out.write(line_3)
    off_molecule = openforcefield.topology.Molecule(system_sdf)
    force_field = openforcefield.typing.engines.smirnoff.ForceField(
        &#34;openff_unconstrained-1.0.0.offxml&#34;
    )
    system = force_field.create_openmm_system(off_molecule.to_topology())
    pdbfile = simtk.openmm.app.PDBFile(system_pdb)
    structure = parmed.openmm.load_topology(
        pdbfile.topology, system, xyz=pdbfile.positions
    )
    with open(system_xml, &#34;w&#34;) as f:
        f.write(simtk.openmm.XmlSerializer.serialize(system))


def get_dihedrals(qm_scan_file):
    with open(qm_scan_file, &#34;r&#34;) as f:
        lines = f.readlines()
    energy_dihedral_lines = []
    for i in range(len(lines)):
        if &#34;Dihedral&#34; in lines[i]:
            energy_dihedral_lines.append(lines[i])
    dihedrals = []
    for i in energy_dihedral_lines:
        energy_dihedral = i
        energy_dihedral = re.findall(r&#34;[-+]?\d+[.]?\d*&#34;, energy_dihedral)
        dihedral = float(energy_dihedral[0])
        dihedrals.append(dihedral)
    return dihedrals


def get_qm_energies(qm_scan_file):
    with open(qm_scan_file, &#34;r&#34;) as f:
        lines = f.readlines()
    energy_dihedral_lines = []
    for i in range(len(lines)):
        if &#34;Dihedral&#34; in lines[i]:
            energy_dihedral_lines.append(lines[i])
    qm_energies = []
    for i in energy_dihedral_lines:
        energy_dihedral = i
        energy_dihedral = re.findall(r&#34;[-+]?\d+[.]?\d*&#34;, energy_dihedral)
        energy = float(energy_dihedral[1])
        qm_energies.append(energy)
    return qm_energies


def generate_mm_pdbs(qm_scan_file, template_pdb):
    with open(qm_scan_file, &#34;r&#34;) as f:
        lines = f.readlines()
    energy_dihedral_lines = []
    for i in range(len(lines)):
        if &#34;Dihedral&#34; in lines[i]:
            energy_dihedral_lines.append(lines[i])
    dihedrals = []
    for i in energy_dihedral_lines:
        energy_dihedral = i
        energy_dihedral = re.findall(r&#34;[-+]?\d+[.]?\d*&#34;, energy_dihedral)
        dihedral = float(energy_dihedral[0])
        dihedrals.append(dihedral)
    lines_markers = []
    for i in range(len(lines)):
        if &#34;Dihedral&#34; in lines[i]:
            lines_markers.append(i)
    lines_markers.append(len(lines) + 1)
    for i in range(len(lines_markers) - 1):
        # pdb_file_to_write = str(dihedrals[i]) + &#34;.pdb&#34;
        if dihedrals[i] &gt; 0:
            pdb_file_to_write = &#34;plus_&#34; + str(abs(dihedrals[i])) + &#34;.pdb&#34;
        if dihedrals[i] &lt; 0:
            pdb_file_to_write = &#34;minus_&#34; + str(abs(dihedrals[i])) + &#34;.pdb&#34;
        to_begin = lines_markers[i]
        to_end = lines_markers[i + 1]
        lines_to_write = lines[to_begin + 1 : to_end - 1]
        x_coords = []
        y_coords = []
        z_coords = []
        for i in lines_to_write:
            coordinates = i
            coordinates = re.findall(r&#34;[-+]?\d+[.]?\d*&#34;, coordinates)
            x = float(coordinates[0])
            y = float(coordinates[1])
            z = float(coordinates[2])
            x_coords.append(x)
            y_coords.append(y)
            z_coords.append(z)
        ppdb = PandasPdb()
        ppdb.read_pdb(template_pdb)
        ppdb.df[&#34;ATOM&#34;][&#34;x_coord&#34;] = x_coords
        ppdb.df[&#34;ATOM&#34;][&#34;y_coord&#34;] = y_coords
        ppdb.df[&#34;ATOM&#34;][&#34;z_coord&#34;] = z_coords
        ppdb.to_pdb(pdb_file_to_write)


def remove_mm_files(qm_scan_file):
    mm_pdb_list = []
    for i in get_dihedrals(qm_scan_file):
        if i &gt; 0:
            pdb_file = &#34;plus_&#34; + str(abs(i)) + &#34;.pdb&#34;
        if i &lt; 0:
            pdb_file = &#34;minus_&#34; + str(abs(i)) + &#34;.pdb&#34;
        mm_pdb_list.append(pdb_file)
    for i in mm_pdb_list:
        command = &#34;rm -rf  &#34; + i
        os.system(command)
        command = &#34;rm -rf  &#34; + i[:-4] + &#34;.inpcrd&#34;
        os.system(command)
        command = &#34;rm -rf  &#34; + i[:-4] + &#34;.prmtop&#34;
        os.system(command)


def get_non_torsion_mm_energy(system_pdb, load_topology, system_xml):
    system_prmtop = system_pdb[:-4] + &#34;.prmtop&#34;
    system_inpcrd = system_pdb[:-4] + &#34;.inpcrd&#34;
    if load_topology == &#34;parmed&#34;:
        openmm_system = parmed.openmm.load_topology(
            parmed.load_file(system_pdb, structure=True).topology,
            parmed.load_file(system_xml),
        )
    if load_topology == &#34;openmm&#34;:
        openmm_system = parmed.openmm.load_topology(
            simtk.openmm.app.PDBFile(system_pdb).topology,
            parmed.load_file(system_xml),
        )
    openmm_system.save(system_prmtop, overwrite=True)
    openmm_system.coordinates = parmed.load_file(
        system_pdb, structure=True
    ).coordinates
    openmm_system.save(system_inpcrd, overwrite=True)
    parm = parmed.load_file(system_prmtop, system_inpcrd)
    prmtop_energy_decomposition = parmed.openmm.energy_decomposition_system(
        parm, parm.createSystem()
    )
    # print(prmtop_energy_decomposition)
    prmtop_energy_decomposition_value_no_torsion = [
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicBondForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicAngleForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;NonbondedForce&#34;),
    ]
    return sum(prmtop_energy_decomposition_value_no_torsion)


def get_mm_potential_energies(qm_scan_file, load_topology, system_xml):
    mm_pdb_list = []
    for i in get_dihedrals(qm_scan_file):
        if i &gt; 0:
            pdb_file = &#34;plus_&#34; + str(abs(i)) + &#34;.pdb&#34;
        if i &lt; 0:
            pdb_file = &#34;minus_&#34; + str(abs(i)) + &#34;.pdb&#34;
        mm_pdb_list.append(pdb_file)
    for i in mm_pdb_list:
        mm_pdb_file = i
    mm_potential_energies = []
    for i in mm_pdb_list:
        mm_pdb_file = i
        mm_energy = get_non_torsion_mm_energy(
            system_pdb=i, load_topology=load_topology, system_xml=system_xml
        )
        mm_potential_energies.append(mm_energy)
    return mm_potential_energies


def list_diff(list_1, list_2):
    diff_list = []
    zipped_list = zip(list_1, list_2)
    for list1_i, list2_i in zipped_list:
        diff_list.append(list1_i - list2_i)
    return diff_list


def dihedral_energy(x, k1, k2, k3, k4=0):
    energy_1 = k1 * (1 + np.cos(1 * x * 0.01745))
    energy_2 = k2 * (1 - np.cos(2 * x * 0.01745))
    energy_3 = k3 * (1 + np.cos(3 * x * 0.01745))
    energy_4 = k4 * (1 - np.cos(4 * x * 0.01745))
    dihedral_energy = energy_1 + energy_2 + energy_3 + energy_4
    return dihedral_energy


def error_function(delta_qm, delta_mm):
    squared_error = np.square(np.subtract(delta_qm, delta_mm))
    mean_squared_error = squared_error.mean()
    root_mean_squared_error = math.sqrt(mean_squared_error)
    return root_mean_squared_error


def error_function_boltzmann(delta_qm, delta_mm, T):
    kb = 3.297623483 * 10 ** (-24)  # in cal/K
    delta_qm_boltzmann_weighted = [np.exp(-i / (kb * T)) for i in delta_qm]
    squared_error = (
        np.square(np.subtract(delta_qm, delta_mm))
        * delta_qm_boltzmann_weighted
    )
    mean_squared_error = squared_error.mean()
    root_mean_squared_error = math.sqrt(mean_squared_error)
    return root_mean_squared_error


def gen_init_guess(qm_scan_file, load_topology, system_xml):
    x = get_dihedrals(qm_scan_file)
    y = scale_list(
        list_=get_mm_potential_energies(
            qm_scan_file=qm_scan_file,
            load_topology=load_topology,
            system_xml=system_xml,
        )
    )
    init_vals = [0.0, 0.0, 0.0, 0.0]
    k_init_guess, covar = scipy.optimize.curve_fit(
        dihedral_energy, x, y, p0=init_vals
    )
    for i in range(len(k_init_guess)):
        if k_init_guess[i] &lt; 0:
            k_init_guess[i] = 0
    return k_init_guess


def objective_function(k_array, x, delta_qm):
    delta_mm = dihedral_energy(
        x, k1=k_array[0], k2=k_array[1], k3=k_array[2], k4=k_array[3]
    )
    loss_function = error_function(delta_qm, delta_mm)
    return loss_function


def fit_params(qm_scan_file, load_topology, system_xml, method):
    k_guess = gen_init_guess(
        qm_scan_file=qm_scan_file,
        load_topology=load_topology,
        system_xml=system_xml,
    )
    x_data = np.array(get_dihedrals(qm_scan_file))
    delta_qm = np.array(
        scale_list(list_hartree_kcal(list_=get_qm_energies(qm_scan_file)))
    )
    optimise = scipy.optimize.minimize(
        objective_function,
        k_guess,
        args=(x_data, delta_qm),
        method=method,
        bounds=[(0.00, None), (0.00, None), (0.00, None), (0.00, None)],
    )
    return optimise.x


def get_tor_params(
    qm_scan_file, template_pdb, load_topology, system_xml, method
):
    qm_e = get_qm_energies(qm_scan_file=qm_scan_file)
    qm_e_kcal = list_hartree_kcal(qm_e)
    delta_qm = scale_list(qm_e_kcal)
    generate_mm_pdbs(qm_scan_file=qm_scan_file, template_pdb=template_pdb)
    mm_pe_no_torsion_kcal = get_mm_potential_energies(
        qm_scan_file=qm_scan_file,
        load_topology=load_topology,
        system_xml=system_xml,
    )
    delta_mm = scale_list(mm_pe_no_torsion_kcal)
    opt_param = fit_params(
        qm_scan_file=qm_scan_file,
        load_topology=load_topology,
        system_xml=system_xml,
        method=method,
    )
    return opt_param


def get_torsional_lines(
    template_pdb,
    system_xml,
    qm_scan_file,
    load_topology,
    method,
    dihedral_text_file,
):
    opt_param = get_tor_params(
        qm_scan_file=qm_scan_file,
        template_pdb=template_pdb,
        load_topology=load_topology,
        system_xml=system_xml,
        method=method,
    )
    dihedral_text = open(dihedral_text_file, &#34;r&#34;)
    dihedral_text_lines = dihedral_text.readlines()
    atom_numbers = dihedral_text_lines[-1]
    atom_index_from_1 = [
        int(re.findall(r&#34;\d+&#34;, atom_numbers)[0]),
        int(re.findall(r&#34;\d+&#34;, atom_numbers)[1]),
        int(re.findall(r&#34;\d+&#34;, atom_numbers)[2]),
        int(re.findall(r&#34;\d+&#34;, atom_numbers)[3]),
    ]
    atom_index = [i - 1 for i in atom_index_from_1]
    atom_index_lines = (
        &#34; &#34;
        + &#34;p1=&#34;
        + &#39;&#34;&#39;
        + str(atom_index[0])
        + &#39;&#34;&#39;
        + &#34; &#34;
        + &#34;p2=&#34;
        + &#39;&#34;&#39;
        + str(atom_index[1])
        + &#39;&#34;&#39;
        + &#34; &#34;
        + &#34;p3=&#34;
        + &#39;&#34;&#39;
        + str(atom_index[2])
        + &#39;&#34;&#39;
        + &#34; &#34;
        + &#34;p4=&#34;
        + &#39;&#34;&#39;
        + str(atom_index[3])
        + &#39;&#34;&#39;
        + &#34; &#34;
    )
    tor_lines = []
    for i in range(len(opt_param)):
        line_to_append = (
            &#34;                &#34;
            + &#34;&lt;Torsion &#34;
            + &#34;k=&#34;
            + &#39;&#34;&#39;
            + str(round(opt_param[i], 8))
            + &#39;&#34;&#39;
            + atom_index_lines
            + &#34;periodicity=&#34;
            + &#39;&#34;&#39;
            + str(i + 1)
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;phase=&#34;
            + &#39;&#34;&#39;
            + &#34;0&#34;
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
        )
        # print(line_to_append)
        tor_lines.append(line_to_append)
    return tor_lines


class PrepareQMMM:

    &#34;&#34;&#34;
    A class used to segregate the QM and MM regions.

    This class contains methods to remove the solvent, ions and all
    entities that are exclusive of receptor and the ligand. It also
    defines the Quantum Mechanical (QM) region and the Molecular
    Mechanical (MM) region based upon the distance of the ligand
    from the receptor and the chosen number of receptor residues. It
    is also assumed that the initial PDB file will have the receptor
    followed by the ligand.

    ...

    Attributes
    ----------
    init_pdb : str
        Initial PDB file containing the receptor-ligand complex with
        solvent, ions, etc.

    cleaned_pdb : str
        Formatted PDB file containing only the receptor and the ligand.

    guest_init_pdb : str
        A separate ligand PDB file with atom numbers not beginning from 1.

    host_pdb : str
        A separate receptor PDB file with atom numbers beginning from 1.

    guest_resname : str
        Three letter residue ID for the ligand.

    guest_pdb : str, optional
        Ligand PDB file with atom numbers beginning from 1.
        
    guest_xyz : str, optional
        A text file of the XYZ corordinates of the ligand.
        
    distance : float, optional
        The distance required to define the QM region of the receptor.
        This is the distance between the atoms of the ligand and the
        atoms of the receptor.

    residue_list : str, optional
        A text file of the residue numbers of the receptor within the
        proximity (as defined by the distance) from the ligand.
        
    host_qm_atoms : str, optional
        A text file of the atom numbers of the receptors in the QM
        region.

    host_mm_atoms : str, optional
        A text file of the atom numbers of the receptors in the MM
        region (all atoms except atoms in the QM region)
        
    host_qm_pdb : str, optional
        PDB file for the receptor&#39;s QM region.
        
    host_mm_pdb : str, optional
        PDB file for the receptor&#39;s MM region.
        
    qm_pdb : str, optional
        PDB file for the QM region (receptor&#39;s QM region and the
        ligand).
        
    mm_pdb : str, optional
        PDB file for the MM region.
        
    host_mm_region_I_atoms : str, optional
        A text file of the atom numbers of the receptors in the MM
        region preceeding the QM region.

    host_mm_region_II_atoms : str, optional
        A text file of the atom numbers of the receptors in the MM
        region following the QM region.

    host_mm_region_I_pdb : str, optional
        PDB file of the receptor in the MM region preceeding the
        QM region.

    host_mm_region_II_pdb : str, optional
        PDB file of the receptor in the MM region following the
        QM region.   

    num_residues : int, optional
        Number of residues required in the QM region of the receptor.
    &#34;&#34;&#34;

    def __init__(
        self,
        init_pdb,
        distance,
        num_residues,
        guest_resname,
        cleaned_pdb=&#34;system.pdb&#34;,
        guest_init_pdb=&#34;guest_init.pdb&#34;,
        host_pdb=&#34;host.pdb&#34;,
        guest_pdb=&#34;guest_init_II.pdb&#34;,
        guest_xyz=&#34;guest_coord.txt&#34;,
        residue_list=&#34;residue_list.txt&#34;,
        host_qm_atoms=&#34;host_qm.txt&#34;,
        host_mm_atoms=&#34;host_mm.txt&#34;,
        host_qm_pdb=&#34;host_qm.pdb&#34;,
        host_mm_pdb=&#34;host_mm.pdb&#34;,
        qm_pdb=&#34;qm.pdb&#34;,
        mm_pdb=&#34;mm.pdb&#34;,
        host_mm_region_I_atoms=&#34;host_mm_region_I.txt&#34;,
        host_mm_region_II_atoms=&#34;host_mm_region_II.txt&#34;,
        host_mm_region_I_pdb=&#34;host_mm_region_I.pdb&#34;,
        host_mm_region_II_pdb=&#34;host_mm_region_II.pdb&#34;,
    ):

        &#34;&#34;&#34;
        Parameters
        ----------
        init_pdb : str
            Initial PDB file containing the receptor-ligand complex with
            solvent, ions, etc.

        cleaned_pdb : str
            Formatted PDB file containing only the receptor and the ligand.
            
        guest_init_pdb : str
            A separate ligand PDB file with atom numbers not beginning from 1.           

        host_pdb : str
            A separate receptor PDB file with atom numbers beginning from 1.

        guest_resname : str
            Three letter residue ID for the ligand.

        guest_pdb : str
            Ligand PDB file with atom numbers beginning from 1.           

        guest_xyz : str
            A text file of the XYZ corordinates of the ligand.
            
        distance : float
            The distance required to define the QM region of the receptor.
            This is the distance between the atoms of the ligand and the
            atoms of the receptor.

        residue_list : str
            A text file of the residue numbers of the receptor within the
            proximity (as defined by the distance) from the ligand.
         
        host_qm_atoms : str
            A text file of the atom numbers of the receptors in the QM
            region.          

        host_mm_atoms : str
            A text file of the atom numbers of the receptors in the MM
            region (all atoms except atoms in the QM region)
            
        host_qm_pdb : str
            PDB file for the receptor&#39;s QM region.
            
        host_mm_pdb : str
            PDB file for the receptor&#39;s MM region.

        qm_pdb : str
            PDB file for the QM region (receptor&#39;s QM region and the
            ligand).

        mm_pdb : str
            PDB file for the MM region.

        host_mm_region_I_atoms : str
            A text file of the atom numbers of the receptors in the MM
            region preceeding the QM region.

        host_mm_region_II_atoms : str
            A text file of the atom numbers of the receptors in the MM
            region following the QM region.
            
        host_mm_region_I_pdb : str
            PDB file of the receptor in the MM region preceeding the
            QM region.

        host_mm_region_II_pdb : str
            PDB file of the receptor in the MM region following the
            QM region.

        num_residues : int
            Number of residues required in the QM region of the receptor.

        &#34;&#34;&#34;
        self.init_pdb = init_pdb
        self.distance = distance
        self.num_residues = num_residues
        self.guest_resname = guest_resname
        self.cleaned_pdb = cleaned_pdb
        self.guest_init_pdb = guest_init_pdb
        self.host_pdb = host_pdb
        self.guest_pdb = guest_pdb
        self.guest_xyz = guest_xyz
        self.residue_list = residue_list
        self.host_qm_atoms = host_qm_atoms
        self.host_mm_atoms = host_mm_atoms
        self.host_qm_pdb = host_qm_pdb
        self.host_mm_pdb = host_mm_pdb
        self.qm_pdb = qm_pdb
        self.mm_pdb = mm_pdb
        self.host_mm_region_I_atoms = host_mm_region_I_atoms
        self.host_mm_region_II_atoms = host_mm_region_II_atoms
        self.host_mm_region_I_pdb = host_mm_region_I_pdb
        self.host_mm_region_II_pdb = host_mm_region_II_pdb

    def clean_up(self):
        &#34;&#34;&#34;
        Reads the given PDB file, removes all entities except the
        receptor and ligand and saves a new pdb file.
        &#34;&#34;&#34;
        ions = [
            &#34;Na+&#34;,
            &#34;Cs+&#34;,
            &#34;K+&#34;,
            &#34;Li+&#34;,
            &#34;Rb+&#34;,
            &#34;Cl-&#34;,
            &#34;Br-&#34;,
            &#34;F-&#34;,
            &#34;I-&#34;,
            &#34;Ca2&#34;,
        ]
        intermediate_file_1 = self.cleaned_pdb[:-4] + &#34;_intermediate_1.pdb&#34;
        intermediate_file_2 = self.cleaned_pdb[:-4] + &#34;_intermediate_2.pdb&#34;
        command = (
            &#34;pdb4amber -i &#34;
            + self.init_pdb
            + &#34; -o &#34;
            + intermediate_file_1
            + &#34; --noter --dry&#34;
        )
        os.system(command)
        to_delete = (
            intermediate_file_1[:-4] + &#34;_nonprot.pdb&#34;,
            intermediate_file_1[:-4] + &#34;_renum.txt&#34;,
            intermediate_file_1[:-4] + &#34;_sslink&#34;,
            intermediate_file_1[:-4] + &#34;_water.pdb&#34;,
        )
        os.system(
            &#34;rm -rf &#34;
            + to_delete[0]
            + &#34; &#34;
            + to_delete[1]
            + &#34; &#34;
            + to_delete[2]
            + &#34; &#34;
            + to_delete[3]
        )
        with open(intermediate_file_1) as f1, open(
            intermediate_file_2, &#34;w&#34;
        ) as f2:
            for line in f1:
                if not any(ion in line for ion in ions):
                    f2.write(line)
        with open(intermediate_file_2, &#34;r&#34;) as f1:
            filedata = f1.read()
        filedata = filedata.replace(&#34;HETATM&#34;, &#34;ATOM  &#34;)
        with open(self.cleaned_pdb, &#34;w&#34;) as f2:
            f2.write(filedata)
        command = &#34;rm -rf &#34; + intermediate_file_1 + &#34; &#34; + intermediate_file_2
        os.system(command)

    def create_host_guest(self):
        &#34;&#34;&#34;
        Saves separate receptor and ligand PDB files.
        &#34;&#34;&#34;
        with open(self.cleaned_pdb) as f1, open(self.host_pdb, &#34;w&#34;) as f2:
            for line in f1:
                if not self.guest_resname in line and not &#34;CRYST1&#34; in line:
                    f2.write(line)
        with open(self.cleaned_pdb) as f1, open(
            self.guest_init_pdb, &#34;w&#34;
        ) as f2:
            for line in f1:
                if self.guest_resname in line or &#34;END&#34; in line:
                    f2.write(line)

    def realign_guest(self):
        &#34;&#34;&#34;
        Saves a ligand PDB file with atom numbers beginning from 1.
        &#34;&#34;&#34;
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_init_pdb)
        to_substract = min(ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;]) - 1
        ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] = (
            ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] - to_substract
        )
        intermediate_file_1 = self.guest_pdb[:-4] + &#34;_intermediate_1.pdb&#34;
        intermediate_file_2 = self.guest_pdb[:-4] + &#34;_intermediate_2.pdb&#34;
        ppdb.to_pdb(path=intermediate_file_1)
        command = (
            &#34;pdb4amber -i &#34;
            + intermediate_file_1
            + &#34; -o &#34;
            + intermediate_file_2
        )
        os.system(command)
        to_delete = (
            intermediate_file_2[:-4] + &#34;_nonprot.pdb&#34;,
            intermediate_file_2[:-4] + &#34;_renum.txt&#34;,
            intermediate_file_2[:-4] + &#34;_sslink&#34;,
        )
        os.system(
            &#34;rm -rf &#34; + to_delete[0] + &#34; &#34; + to_delete[1] + &#34; &#34; + to_delete[2]
        )
        with open(intermediate_file_2, &#34;r&#34;) as f1:
            filedata = f1.read()
        filedata = filedata.replace(&#34;HETATM&#34;, &#34;ATOM  &#34;)
        with open(self.guest_pdb, &#34;w&#34;) as f2:
            f2.write(filedata)
        command = &#34;rm -rf &#34; + intermediate_file_1 + &#34; &#34; + intermediate_file_2
        os.system(command)

    def get_guest_coord(self):
        &#34;&#34;&#34;
        Saves a text file of the XYZ corordinates of the ligand.
        &#34;&#34;&#34;
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_pdb)
        xyz = ppdb.df[&#34;ATOM&#34;][[&#34;x_coord&#34;, &#34;y_coord&#34;, &#34;z_coord&#34;]]
        xyz_to_list = xyz.values.tolist()
        np.savetxt(self.guest_xyz, xyz_to_list)

    def get_qm_resids(self):
        &#34;&#34;&#34;
        Saves a text file of the residue numbers of the receptor within the
        proximity (as defined by the distance) from the ligand.
        &#34;&#34;&#34;
        guest_coord_list = np.loadtxt(self.guest_xyz)
        host_atom_list = []
        for i in range(len(guest_coord_list)):
            reference_point = guest_coord_list[i]
            ppdb = PandasPdb()
            ppdb.read_pdb(self.host_pdb)
            distances = ppdb.distance(xyz=reference_point, records=(&#34;ATOM&#34;))
            all_within_distance = ppdb.df[&#34;ATOM&#34;][
                distances &lt; float(self.distance)
            ]
            host_df = all_within_distance[&#34;atom_number&#34;]
            host_list = host_df.values.tolist()
            host_atom_list.append(host_list)
        host_atom_list = list(itertools.chain(*host_atom_list))
        host_atom_list = set(host_atom_list)
        host_atom_list = list(host_atom_list)
        host_atom_list.sort()
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        df = ppdb.df[&#34;ATOM&#34;][[&#34;atom_number&#34;, &#34;residue_number&#34;, &#34;residue_name&#34;]]
        index_list = []
        for i in host_atom_list:
            indices = np.where(df[&#34;atom_number&#34;] == i)
            indices = list(indices)[0]
            indices = list(indices)
            index_list.append(indices)
        index_list = list(itertools.chain.from_iterable(index_list))
        df1 = df.iloc[
            index_list,
        ]
        resid_num = list(df1.residue_number.unique())
        np.savetxt(self.residue_list, resid_num)

    def get_host_qm_mm_atoms(self):
        &#34;&#34;&#34;
        Saves a text file of the atom numbers of the receptors in the QM
        region and MM region separately.
        &#34;&#34;&#34;
        resid_num = np.loadtxt(self.residue_list)
        # approximated_res_list = [int(i) for i in resid_num]
        approximated_res_list = []
        for i in range(
            int(statistics.median(resid_num))
            - int(int(self.num_residues) / 2),
            int(statistics.median(resid_num))
            + int(int(self.num_residues) / 2),
        ):
            approximated_res_list.append(i)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        df = ppdb.df[&#34;ATOM&#34;][[&#34;atom_number&#34;, &#34;residue_number&#34;, &#34;residue_name&#34;]]
        host_index_nested_list = []
        for i in approximated_res_list:
            indices = np.where(df[&#34;residue_number&#34;] == i)
            indices = list(indices)[0]
            indices = list(indices)
            host_index_nested_list.append(indices)
        host_index_list = list(
            itertools.chain.from_iterable(host_index_nested_list)
        )
        df_atom = df.iloc[host_index_list]
        df_atom_number = df_atom[&#34;atom_number&#34;]
        host_atom_list = df_atom_number.values.tolist()
        selected_atoms = []
        selected_atoms.extend(host_atom_list)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        len_atoms = []
        for i in range(len(ppdb.df[&#34;ATOM&#34;])):
            len_atoms.append(i + 1)
        non_selected_atoms = list(set(len_atoms).difference(selected_atoms))
        if len(non_selected_atoms) + len(selected_atoms) == len(len_atoms):
            print(
                &#34;Sum of the atoms in the selected and non-selected region \
                 equals the length of list of total atoms&#34;
            )
        else:
            print(&#34;Error&#34;)
        np.savetxt(self.host_qm_atoms, selected_atoms)
        np.savetxt(self.host_mm_atoms, non_selected_atoms)

    def save_host_pdbs(self):
        &#34;&#34;&#34;
        Saves a PDB file for the receptor&#39;s QM region and MM
        region separately.
        &#34;&#34;&#34;
        selected_atoms = np.loadtxt(self.host_qm_atoms)
        selected_atoms = [int(i) for i in selected_atoms]
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        for i in selected_atoms:
            ppdb.df[&#34;ATOM&#34;] = ppdb.df[&#34;ATOM&#34;][
                ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] != i
            ]
        ppdb.to_pdb(
            path=self.host_mm_pdb, records=None, gz=False, append_newline=True
        )
        non_selected_atoms = np.loadtxt(self.host_mm_atoms)
        non_selected_atoms = [int(i) for i in non_selected_atoms]
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        for i in non_selected_atoms:
            ppdb.df[&#34;ATOM&#34;] = ppdb.df[&#34;ATOM&#34;][
                ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] != i
            ]
        ppdb.to_pdb(
            path=self.host_qm_pdb, records=None, gz=False, append_newline=True
        )

    def get_host_mm_region_atoms(self):
        &#34;&#34;&#34;
        Saves a text file for the atoms of the receptor&#39;s MM region
        preceding the QM region and saves another text file for the
        atoms of the receptor&#39;s MM region folllowing the QM region.
        &#34;&#34;&#34;
        resid_num = np.loadtxt(self.residue_list)
        approximated_res_list = []
        for i in range(
            int(statistics.median(resid_num))
            - int(int(self.num_residues) / 2),
            int(statistics.median(resid_num))
            + int(int(self.num_residues) / 2),
        ):
            approximated_res_list.append(i)
        # print(approximated_res_list)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        df = ppdb.df[&#34;ATOM&#34;][[&#34;residue_number&#34;]]
        res_list = list(set(df[&#34;residue_number&#34;].to_list()))
        res_mm_list = list(set(res_list).difference(approximated_res_list))
        # print(res_mm_list)
        res_mm_region_I_list = []
        for i in res_mm_list:
            for j in approximated_res_list:
                if i &lt; j:
                    res_mm_region_I_list.append(i)
        res_mm_region_I_list = list(set(res_mm_region_I_list))
        # print(res_mm_region_I_list)
        res_mm_region_II_list = list(
            set(res_mm_list).difference(res_mm_region_I_list)
        )
        # print(res_mm_region_II_list)
        ppdb.read_pdb(self.host_mm_pdb)
        df = ppdb.df[&#34;ATOM&#34;][[&#34;atom_number&#34;, &#34;residue_number&#34;, &#34;residue_name&#34;]]
        mm_region_I_index_nested_list = []
        for i in res_mm_region_I_list:
            indices = np.where(df[&#34;residue_number&#34;] == i)
            indices = list(indices)[0]
            indices = list(indices)
            mm_region_I_index_nested_list.append(indices)
        mm_region_I_index_list = list(
            itertools.chain.from_iterable(mm_region_I_index_nested_list)
        )
        df_atom = df.iloc[mm_region_I_index_list]
        df_atom_number = df_atom[&#34;atom_number&#34;]
        mm_region_I_atom_list = df_atom_number.values.tolist()
        mm_region_I_atoms = []
        mm_region_I_atoms.extend(mm_region_I_atom_list)
        mm_region_II_index_nested_list = []
        for i in res_mm_region_II_list:
            indices = np.where(df[&#34;residue_number&#34;] == i)
            indices = list(indices)[0]
            indices = list(indices)
            mm_region_II_index_nested_list.append(indices)
        mm_region_II_index_list = list(
            itertools.chain.from_iterable(mm_region_II_index_nested_list)
        )
        df_atom = df.iloc[mm_region_II_index_list]
        df_atom_number = df_atom[&#34;atom_number&#34;]
        mm_region_II_atom_list = df_atom_number.values.tolist()
        mm_region_II_atoms = []
        mm_region_II_atoms.extend(mm_region_II_atom_list)
        ppdb.read_pdb(self.host_mm_pdb)
        len_atoms = []
        for i in range(len(ppdb.df[&#34;ATOM&#34;])):
            len_atoms.append(i + 1)
        if len(mm_region_I_atoms) + len(mm_region_II_atoms) == len(len_atoms):
            print(
                &#34;Sum of the MM region I atoms and  MM region II atoms equals \
                 the length of list of total MM atoms&#34;
            )
        else:
            print(&#34;Error&#34;)
        np.savetxt(self.host_mm_region_I_atoms, mm_region_I_atoms)
        np.savetxt(self.host_mm_region_II_atoms, mm_region_II_atoms)

    def save_host_mm_regions_pdbs(self):
        &#34;&#34;&#34;
        Saves a PDB file for the receptor&#39;s MM region preceding
        the QM region and saves another PDB file for the receptor&#39;s
        MM region folllowing the QM region.
        &#34;&#34;&#34;
        mm_region_I_atoms = np.loadtxt(self.host_mm_region_I_atoms)
        mm_region_I_atoms = [int(i) for i in mm_region_I_atoms]
        mm_region_II_atoms = np.loadtxt(self.host_mm_region_II_atoms)
        mm_region_II_atoms = [int(i) for i in mm_region_II_atoms]
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_mm_pdb)
        for i in mm_region_II_atoms:
            ppdb.df[&#34;ATOM&#34;] = ppdb.df[&#34;ATOM&#34;][
                ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] != i
            ]
        ppdb.to_pdb(
            path=self.host_mm_region_I_pdb,
            records=None,
            gz=False,
            append_newline=True,
        )
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_mm_pdb)
        for i in mm_region_I_atoms:
            ppdb.df[&#34;ATOM&#34;] = ppdb.df[&#34;ATOM&#34;][
                ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] != i
            ]
        ppdb.to_pdb(
            path=self.host_mm_region_II_pdb,
            records=None,
            gz=False,
            append_newline=True,
        )

    def get_qm_mm_regions(self):
        &#34;&#34;&#34;
        Saves separate PDB files for the QM and MM regions.
        QM regions comprise the QM region of the receptor
        and the entire ligand where the MM region comprise
        the non-selected QM regions of the receptor.
        &#34;&#34;&#34;
        with open(self.host_qm_pdb) as f1, open(self.qm_pdb, &#34;w&#34;) as f2:
            for line in f1:
                if &#34;ATOM&#34; in line:
                    f2.write(line)
        with open(self.guest_pdb) as f1, open(self.qm_pdb, &#34;a&#34;) as f2:
            for line in f1:
                if &#34;ATOM&#34; in line:
                    f2.write(line)
        with open(self.qm_pdb, &#34;a&#34;) as f:
            f.write(&#34;END&#34;)
        with open(self.host_mm_pdb) as f1, open(self.mm_pdb, &#34;w&#34;) as f2:
            for line in f1:
                if &#34;ATOM&#34; in line:
                    f2.write(line)
        with open(self.mm_pdb, &#34;a&#34;) as f:
            f.write(&#34;END&#34;)


class PrepareGaussianGuest:
    &#34;&#34;&#34;
    A class used to prepare the QM engine input file (Gaussian) 
    for the ligand and run QM calculations with appropriate 
    keywords. 

    This class contain methods to write an input file (.com extension)
    for the QM engine. It then runs a QM calculation with the given
    basis set and functional. Checkpoint file is then converted to 
    a formatted checkpoint file. Output files (.log, .chk, and .fhck)
    will then be used to extract ligand&#39;s force field parameters. 

    ...

    Attributes
    ----------
    charge : int
        Charge of the ligand. 

    multiplicity: int
        Spin Multiplicity (2S+1) of the ligand where S represents 
        the total spin of the ligand. 

    guest_pdb: str, optional
        Ligand PDB file with atom numbers beginning from 1.

    n_processors : int, optional
        Number of processors to be used for Gaussian program to run and 
        set in %NProcShared command of Gaussian.

    memory : int, optional
        Memory (in GB) to be used set in %Mem command of Gaussian.

    functional: str, optional
        Exchange/Correlation or hybrid functional to use in the Gaussian
        QM calculation.

    basis_set: str, optional
        Basis set to use for the Gaussian QM calculation.

    optimisation: str, optional
        set to &#34;OPT&#34; to perform a geometry optimization on the ligand
        specified in the system; else set to an empty string.

    frequency: str, optional
        set to &#34;FREQ&#34; for Gaussian to perform a frequency calculation;
        else set to an empty string.

    add_keywords_I: str, optional
        Specifies the integration grid.

    add_keywords_II: str, optional
        Specifies the Gaussian described options for generating
        population.

    add_keywords_III: str, optional
        Used to include the IOp keyword (to set the internal options to
        specific values) in the Gaussian command.

    gauss_out_file: str, optional
        This file contains the output script obtained after running
        the Gaussian QM calculation.

    fchk_out_file: str, optional
        Formatted checkpoint file obtained from the checkpoint file
        using formchk command.


    &#34;&#34;&#34;
    def __init__(
        self,
        charge,
        multiplicity,
        guest_pdb=&#34;guest_init_II.pdb&#34;,
        n_processors=12,
        memory=50,
        functional=&#34;B3LYP&#34;,
        basis_set=&#34;6-31G&#34;,
        optimisation=&#34;OPT&#34;,
        frequency=&#34;FREQ&#34;,
        add_keywords_I=&#34;Integral=(Grid=UltraFine)&#34;,
        add_keywords_II=&#34;Pop(MK,ReadRadii)&#34;,
        add_keywords_III=&#34;IOp(6/33=2,6/42=6)&#34;,
        gauss_out_file=&#34;guest.out&#34;,
        fchk_out_file=&#34;guest_fchk.out&#34;,
    ):

        &#34;&#34;&#34;
        Parameters
        ----------
        charge : int
            Charge of the ligand. 

        multiplicity: int
            Spin Multiplicity (2S+1) of the ligand where S represents 
            the total spin of the ligand. 

        guest_pdb: str, optional
            Ligand PDB file with atom numbers beginning from 1.

        n_processors : int, optional
            Number of processors to be used for Gaussian program to run and 
            set in %NProcShared command of Gaussian.

        memory : int, optional
            Memory (in GB) to be used set in %Mem command of Gaussian.

        functional: str, optional
            Exchange/Correlation or hybrid functional to use in the Gaussian
            QM calculation.

        basis_set: str, optional
            Basis set to use for the Gaussian QM calculation.

        optimisation: str, optional
            set to &#34;OPT&#34; to perform a geometry optimization on the ligand
            specified in the system; else set to an empty string.

        frequency: str, optional
            set to &#34;FREQ&#34; for Gaussian to perform a frequency calculation;
            else set to an empty string.

        add_keywords_I: str, optional
            Specifies the integration grid.

        add_keywords_II: str, optional
            Specifies the Gaussian described options for generating
            population.

        add_keywords_III: str, optional
            Used to include the IOp keyword (to set the internal options to
            specific values) in the Gaussian command.

        gauss_out_file: str, optional
            This file contains the output script obtained after running
            the Gaussian QM calculation.

        fchk_out_file: str, optional
            Formatted checkpoint file obtained from the checkpoint file
            using formchk command.

        &#34;&#34;&#34;

        self.charge = charge
        self.multiplicity = multiplicity
        self.guest_pdb = guest_pdb
        self.n_processors = n_processors
        self.memory = memory
        self.functional = functional
        self.basis_set = basis_set
        self.optimisation = optimisation
        self.frequency = frequency
        self.gauss_out_file = gauss_out_file
        self.fchk_out_file = fchk_out_file
        self.add_keywords_I = add_keywords_I
        self.add_keywords_II = add_keywords_II
        self.add_keywords_III = add_keywords_III

    def write_input(self):
        &#34;&#34;&#34;
        Writes a Gaussian input file for the ligand. 
        &#34;&#34;&#34;

        command_line_1 = &#34;%Chk = &#34; + self.guest_pdb[:-4] + &#34;.chk&#34;
        command_line_2 = &#34;%Mem = &#34; + str(self.memory) + &#34;GB&#34;
        command_line_3 = &#34;%NProcShared = &#34; + str(self.n_processors)
        command_line_4 = (
            &#34;# &#34;
            + self.functional
            + &#34; &#34;
            + self.basis_set
            + &#34; &#34;
            + self.optimisation
            + &#34; &#34;
            + self.frequency
            + &#34; &#34;
            + self.add_keywords_I
            + &#34; &#34;
            + self.add_keywords_II
            + &#34; &#34;
            + self.add_keywords_III
        )
        command_line_5 = &#34; &#34;
        command_line_6 = self.guest_pdb[:-4] + &#34; &#34; + &#34;gaussian input file&#34;
        command_line_7 = &#34; &#34;
        command_line_8 = str(self.charge) + &#34; &#34; + str(self.multiplicity)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_pdb)
        df = ppdb.df[&#34;ATOM&#34;]
        df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
        df_1.columns = [&#34;atom&#34;]
        df_2 = df[[&#34;x_coord&#34;, &#34;y_coord&#34;, &#34;z_coord&#34;]]
        df_merged = pd.concat([df_1, df_2], axis=1)
        command_line_9 = df_merged.to_string(header=False, index=False)
        command_line_10 = &#34; &#34;
        command = [
            command_line_1,
            command_line_2,
            command_line_3,
            command_line_4,
            command_line_5,
            command_line_6,
            command_line_7,
            command_line_8,
            command_line_9,
            command_line_10,
        ]
        commands = &#34;\n&#34;.join(command)
        with open(self.guest_pdb[:-4] + &#34;.com&#34;, &#34;w&#34;) as f:
            f.write(commands)

    def run_gaussian(self):
        &#34;&#34;&#34;
        Runs the Gaussian QM calculation for the ligand locally.
        &#34;&#34;&#34;
        execute_command = (
            &#34;g16&#34;
            + &#34; &lt; &#34;
            + self.guest_pdb[:-4]
            + &#34;.com&#34;
            + &#34; &gt; &#34;
            + self.guest_pdb[:-4]
            + &#34;.log&#34;
        )
        with open(self.gauss_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell=True, stdout=f, stderr=sp.STDOUT)

    def get_fchk(self):
        &#34;&#34;&#34;
        Converts the Gaussian checkpoint file (.chk) to a formatted checkpoint
        file (.fchk).
        &#34;&#34;&#34;
        execute_command = (
            &#34;formchk&#34;
            + &#34; &#34;
            + self.guest_pdb[:-4]
            + &#34;.chk&#34;
            + &#34; &#34;
            + self.guest_pdb[:-4]
            + &#34;.fchk&#34;
        )
        with open(self.fchk_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell=True, stdout=f, stderr=sp.STDOUT)


class PrepareGaussianHostGuest:
    &#34;&#34;&#34;
    A class used to prepare the QM engine input file (Gaussian) for 
    the receptor - ligand complex and run the QM calculations with 
    the appropriate keywords. 

    This class contain methods to write an input file (.com extension)
    for the QM engine for the receptor - ligand complex. It then runs 
    a QM calculation with the given basis set and functional. Checkpoint
    file is then converted to a formatted checkpoint file. Output files
    (.log, .chk, and .fhck) will then be used to extract charges for the 
    ligand and the receptor.

    ...

    Attributes
    ----------
    charge : int
        Total charge of the receptor - ligand complex.

    multiplicity : int
        Spin Multiplicity (2S+1) of the ligand where S represents 
        the total spin of the ligand. 

    guest_pdb : str, optional
        Ligand PDB file with atom numbers beginning from 1.

    host_qm_pdb : str, optional
        PDB file for the receptor&#39;s QM region.

    n_processors : int, optional
        Number of processors to be used for Gaussian program to run and 
        set in %NProcShared command of Gaussian.

    memory : int, optional
        Memory (in GB) to be used set in %Mem command of Gaussian.

    functional: str, optional
        Exchange/Correlation or hybrid functional to use in the Gaussian
        QM calculation.

    basis_set: str, optional
        Basis set to use for the Gaussian QM calculation.

    optimisation: str, optional
        set to &#34;OPT&#34; to perform a geometry optimization on the ligand
        specified in the system; else set to an empty string.

    frequency: str, optional
        set to &#34;FREQ&#34; for Gaussian to perform a frequency calculation;
        else set to an empty string.

    add_keywords_I: str, optional
        Specifies the integration grid.

    add_keywords_II: str, optional
        Specifies the Gaussian described options for generating
        population.

    add_keywords_III: str, optional
        Used to include the IOp keyword (to set the internal options to
        specific values) in the Gaussian command.

    gauss_system_out_file : str, optional
        This file contains the output script obtained after running
        the Gaussian QM calculation.

    fchk_system_out_file : str, optional
        Formatted checkpoint file obtained from the checkpoint file
        using formchk command.

    host_guest_input : str, optional
        Gaussian input file (.com extension) for the receptor - ligand 
        QM region.

    qm_guest_charge_parameter_file : str, optional
        File containing the charges of ligand atoms and their corresponding
        atoms. Charge obtained are the polarised charged due to the 
        surrounding receptor&#39;s region.

    qm_host_charge_parameter_file : str, optional
        File containing the charges of the QM region of the receptor. 

    qm_guest_atom_charge_parameter_file : str, optional
        File containing the charges of ligand atoms. Charge obtained 
        are the polarised charged due to the surrounding receptor&#39;s region.

    &#34;&#34;&#34;
    def __init__(
        self,
        charge,
        multiplicity,
        guest_pdb=&#34;guest_init_II.pdb&#34;,
        host_qm_pdb=&#34;host_qm.pdb&#34;,
        n_processors=12,
        memory=50,
        functional=&#34;B3LYP&#34;,
        basis_set=&#34;6-31G&#34;,
        optimisation=&#34;&#34;,
        frequency=&#34;&#34;,
        add_keywords_I=&#34;Integral=(Grid=UltraFine)&#34;,
        add_keywords_II=&#34;Pop(MK,ReadRadii)&#34;,
        add_keywords_III=&#34;IOp(6/33=2,6/42=6)&#34;,
        gauss_system_out_file=&#34;system_qm.out&#34;,
        fchk_system_out_file=&#34;system_qm_fchk.out&#34;,
        host_guest_input=&#34;host_guest.com&#34;,
        qm_guest_charge_parameter_file=&#34;guest_qm_surround_charges.txt&#34;,
        qm_host_charge_parameter_file=&#34;host_qm_surround_charges.txt&#34;,
        qm_guest_atom_charge_parameter_file=&#34;guest_qm_atom_surround_charges.txt&#34;,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        charge : int
            Total charge of the receptor - ligand complex.

        multiplicity : int
            Spin Multiplicity (2S+1) of the ligand where S represents 
            the total spin of the ligand. 

        guest_pdb : str, optional
            Ligand PDB file with atom numbers beginning from 1.

        host_qm_pdb : str, optional
            PDB file for the receptor&#39;s QM region.

        n_processors : int, optional
            Number of processors to be used for Gaussian program to run and 
            set in %NProcShared command of Gaussian.

        memory : int, optional
            Memory (in GB) to be used set in %Mem command of Gaussian.

        functional: str, optional
            Exchange/Correlation or hybrid functional to use in the Gaussian
            QM calculation.

        basis_set: str, optional
            Basis set to use for the Gaussian QM calculation.

        optimisation: str, optional
            set to &#34;OPT&#34; to perform a geometry optimization on the ligand
            specified in the system; else set to an empty string.

        frequency: str, optional
            set to &#34;FREQ&#34; for Gaussian to perform a frequency calculation;
            else set to an empty string.

        add_keywords_I: str, optional
            Specifies the integration grid.

        add_keywords_II: str, optional
            Specifies the Gaussian described options for generating
            population.

        add_keywords_III: str, optional
            Used to include the IOp keyword (to set the internal options to
            specific values) in the Gaussian command.

        gauss_system_out_file : str, optional
            This file contains the output script obtained after running
            the Gaussian QM calculation.

        fchk_system_out_file : str, optional
            Formatted checkpoint file obtained from the checkpoint file
            using formchk command.

        host_guest_input : str, optional
            Gaussian input file (.com extension) for the receptor - ligand 
            QM region.

        qm_guest_charge_parameter_file : str, optional
            File containing the charges of ligand atoms and their corresponding
            atoms. Charge obtained are the polarised charged due to the 
            surrounding receptor&#39;s region.

        qm_host_charge_parameter_file : str, optional
            File containing the charges of the QM region of the receptor. 

        qm_guest_atom_charge_parameter_file : str, optional
            File containing the charges of ligand atoms. Charge obtained 
            are the polarised charged due to the surrounding receptor&#39;s region.
  
        &#34;&#34;&#34;
        self.charge = charge
        self.multiplicity = multiplicity
        self.guest_pdb = guest_pdb
        self.host_qm_pdb = host_qm_pdb
        self.n_processors = n_processors
        self.memory = memory
        self.functional = functional
        self.basis_set = basis_set
        self.optimisation = optimisation
        self.frequency = frequency
        self.add_keywords_I = add_keywords_I
        self.add_keywords_II = add_keywords_II
        self.add_keywords_III = add_keywords_III
        self.gauss_system_out_file = gauss_system_out_file
        self.fchk_system_out_file = fchk_system_out_file
        self.host_guest_input = host_guest_input
        self.qm_guest_charge_parameter_file = qm_guest_charge_parameter_file
        self.qm_host_charge_parameter_file = qm_host_charge_parameter_file
        self.qm_guest_atom_charge_parameter_file = qm_guest_atom_charge_parameter_file

    def write_input(self):
        &#34;&#34;&#34;
        Writes a Gaussian input file for the receptor - ligand QM region. 
        &#34;&#34;&#34;
        command_line_1 = &#34;%Chk = &#34; + self.host_guest_input[:-4] + &#34;.chk&#34;
        command_line_2 = &#34;%Mem = &#34; + str(self.memory) + &#34;GB&#34;
        command_line_3 = &#34;%NProcShared = &#34; + str(self.n_processors)
        command_line_4 = (
            &#34;# &#34;
            + self.functional
            + &#34; &#34;
            + self.basis_set
            + &#34; &#34;
            + self.optimisation
            + &#34; &#34;
            + self.frequency
            + &#34; &#34;
            + self.add_keywords_I
            + &#34; &#34;
            + self.add_keywords_II
            + &#34; &#34;
            + self.add_keywords_III
        )
        command_line_5 = &#34; &#34;
        command_line_6 = &#34;Gaussian Input File&#34;
        command_line_7 = &#34; &#34;
        command_line_8 = str(self.charge) + &#34; &#34; + str(self.multiplicity)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_pdb)
        df = ppdb.df[&#34;ATOM&#34;]
        df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
        df_1.columns = [&#34;atom&#34;]
        df_3 = df[[&#34;x_coord&#34;, &#34;y_coord&#34;, &#34;z_coord&#34;]]
        df_2 = pd.Series([&#34;0&#34;] * len(df), name=&#34;decide_freeze&#34;)
        df_merged_1 = pd.concat([df_1, df_2, df_3], axis=1)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_qm_pdb)
        df = ppdb.df[&#34;ATOM&#34;]
        df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
        df_1.columns = [&#34;atom&#34;]
        df_3 = df[[&#34;x_coord&#34;, &#34;y_coord&#34;, &#34;z_coord&#34;]]
        df_2 = pd.Series([&#34;0&#34;] * len(df), name=&#34;decide_freeze&#34;)
        df_merged_2 = pd.concat([df_1, df_2, df_3], axis=1)
        df_merged = pd.concat([df_merged_1, df_merged_2], axis=0)
        command_line_9 = df_merged.to_string(header=False, index=False)
        command_line_10 = &#34; &#34;
        command = [
            command_line_1,
            command_line_2,
            command_line_3,
            command_line_4,
            command_line_5,
            command_line_6,
            command_line_7,
            command_line_8,
            command_line_9,
            command_line_10,
        ]
        commands = &#34;\n&#34;.join(command)

        with open(self.host_guest_input, &#34;w&#34;) as f:
            f.write(commands)

    def run_gaussian(self):
        &#34;&#34;&#34;
        Runs the Gaussian QM calculation for the ligand - receptor region 
        locally.
        &#34;&#34;&#34;
        execute_command = (
            &#34;g16&#34;
            + &#34; &lt; &#34;
            + self.host_guest_input
            + &#34; &gt; &#34;
            + self.host_guest_input[:-4]
            + &#34;.log&#34;
        )
        with open(self.gauss_system_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell=True, stdout=f, stderr=sp.STDOUT)

    def get_fchk(self):
        &#34;&#34;&#34;
        Converts the Gaussian checkpoint file (.chk) to a formatted checkpoint
        file (.fchk).
        &#34;&#34;&#34;
        execute_command = (
            &#34;formchk&#34;
            + &#34; &#34;
            + self.host_guest_input[:-4]
            + &#34;.chk&#34;
            + &#34; &#34;
            + self.host_guest_input[:-4]
            + &#34;.fchk&#34;
        )
        with open(self.fchk_system_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell=True, stdout=f, stderr=sp.STDOUT)

    def get_qm_host_guest_charges(self):
        &#34;&#34;&#34;
        Extract charge information for the receptor - ligand QM region.
        &#34;&#34;&#34;
        log_file = self.host_guest_input[:-4] + &#34;.log&#34;
        with open(log_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Fitting point charges to electrostatic potential&#34; in lines[i]:
                to_begin = int(i)
            if &#34; Sum of ESP charges =&#34; in lines[i]:
                to_end = int(i)
        charges = lines[to_begin + 4 : to_end]
        charge_list = []
        for i in range(len(charges)):
            charge_list.append(charges[i].strip().split())
        charge_list_value = []
        atom_list = []
        for i in range(len(charge_list)):
            charge_list_value.append(charge_list[i][2])
            atom_list.append(charge_list[i][1])
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_pdb)
        df_guest = ppdb.df[&#34;ATOM&#34;]
        number_guest_atoms = df_guest.shape[0]
        data_tuples = list(zip(atom_list, charge_list_value))
        df_charge = pd.DataFrame(data_tuples, columns=[&#34;Atom&#34;, &#34;Charge&#34;])
        number_host_atoms = df_charge.shape[0] - number_guest_atoms
        df_charge_guest = df_charge.head(number_guest_atoms)
        df_charge_host = df_charge.tail(number_host_atoms)
        df_charge_only_guest = df_charge_guest[&#34;Charge&#34;]
        df_charge_guest.to_csv(
            self.qm_guest_charge_parameter_file,
            index=False,
            header=False,
            sep=&#34; &#34;,
        )
        df_charge_host.to_csv(
            self.qm_host_charge_parameter_file,
            index=False,
            header=False,
            sep=&#34; &#34;,
        )
        df_charge_only_guest.to_csv(
            self.qm_guest_atom_charge_parameter_file,
            index=False,
            header=False,
            sep=&#34; &#34;,
        )


class ParameterizeGuest:
    &#34;&#34;&#34;
    A class used to obtain force field parameters for the ligand (bond, 
    angle and charge parameters) from QM calculations.

    This class contain methods to process the output files of the 
    Gaussian QM output files (.chk, .fchk and .log files). Methods 
    in the class extract the unprocessed hessian matrix from the 
    Gaussian QM calculations, processes it and uses the Modified 
    Seminario Method to ontain the bond and angle parameters. The 
    class also extracts the QM charges from the log file.

    ...

    Attributes
    ----------
    vibrational_scaling: float
        Vibrational scaling factor for the DFT deficits/anharmonicities
        in the bond parameters.

    xyz_file: str, optional
        XYZ file for ligand coordinates obtained from its corresponding 
        formatted checkpoint file.

    coordinate_file: str, optional
        Text file containing the ligand coordinates (extracted
        from the formatted checkpoint file).

    unprocessed_hessian_file: str, optional
        Unprocessed hessian matrix of the ligand obtained from the 
        formatted checkpoint file.

    bond_list_file: str, optional
        Text file containing the bond information of the ligand extracted 
        from the log file.

    angle_list_file: str, optional
        Text file containing the angle information of the ligand extracted 
        from the log file.

    hessian_file: str, optional
        Processed hessian matrix of the ligand.

    atom_names_file: str, optional
        Text file containing the list of atom names from the fchk file.

    bond_parameter_file: str, optional
        Text file containing the bond parameters for the ligand obtained 
        using the Modified Seminario method.

    angle_parameter_file: str, optional
        Text file containing the angle parameters of the ligand obtained 
        using the Modified Seminario method..

    charge_parameter_file: str, optional
        Text file containing the QM charges of the ligand.

    guest_pdb: str, optional
        Ligand PDB file with atom numbers beginning from 1.

    proper_dihedral_file: str, optional
        A text file containing proper dihedral angles of the ligand.

    &#34;&#34;&#34;
    def __init__(
        self,
        vibrational_scaling,
        xyz_file=&#34;guest_coords.xyz&#34;,
        coordinate_file=&#34;guest_coordinates.txt&#34;,
        unprocessed_hessian_file=&#34;guest_unprocessed_hessian.txt&#34;,
        bond_list_file=&#34;guest_bond_list.txt&#34;,
        angle_list_file=&#34;guest_angle_list.txt&#34;,
        hessian_file=&#34;guest_hessian.txt&#34;,
        atom_names_file=&#34;guest_atom_names.txt&#34;,
        bond_parameter_file=&#34;guest_bonds.txt&#34;,
        angle_parameter_file=&#34;guest_angles.txt&#34;,
        charge_parameter_file=&#34;guest_charges.txt&#34;,
        guest_pdb=&#34;guest_init_II.pdb&#34;,
        proper_dihedral_file=&#34;proper_dihedrals.txt&#34;,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        vibrational_scaling: float
            Vibrational scaling factor for the DFT deficits/anharmonicities
            in the bond parameters.

        xyz_file: str, optional
            XYZ file for ligand coordinates obtained from its corresponding 
            formatted checkpoint file.

        coordinate_file: str, optional
            Text file containing the ligand coordinates (extracted
            from the formatted checkpoint file).

        unprocessed_hessian_file: str, optional
            Unprocessed hessian matrix of the ligand obtained from the 
            formatted checkpoint file.

        bond_list_file: str, optional
            Text file containing the bond information of the ligand extracted 
            from the log file.

        angle_list_file: str, optional

            Text file containing the angle information of the ligand extracted 
            from the log file.

        hessian_file: str, optional
            Processed hessian matrix of the ligand.

        atom_names_file: str, optional
            Text file containing the list of atom names from the fchk file.

        bond_parameter_file: str, optional
            Text file containing the bond parameters for the ligand obtained 
            using the Modified Seminario method.

        angle_parameter_file: str, optional
            Text file containing the angle parameters of the ligand.

        charge_parameter_file: str, optional
            Text file containing the QM charges of the ligand.

        guest_pdb: str, optional
            Ligand PDB file with atom numbers beginning from 1.

        proper_dihedral_file: str, optional
            A text file containing proper dihedral angles of the ligand.

        &#34;&#34;&#34;
        self.vibrational_scaling = vibrational_scaling
        self.xyz_file = xyz_file
        self.coordinate_file = coordinate_file
        self.unprocessed_hessian_file = unprocessed_hessian_file
        self.bond_list_file = bond_list_file
        self.angle_list_file = angle_list_file
        self.hessian_file = hessian_file
        self.atom_names_file = atom_names_file
        self.bond_parameter_file = bond_parameter_file
        self.angle_parameter_file = angle_parameter_file
        self.charge_parameter_file = charge_parameter_file
        self.guest_pdb = guest_pdb
        self.proper_dihedral_file = proper_dihedral_file

    def get_xyz(self):
        &#34;&#34;&#34;
        Saves XYZ file from the formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
        with open(fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
                no_coordinates = int(no_coordinates[0])
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                to_begin = int(i)
        cartesian_coords = lines[
            to_begin + 1 : to_begin + 1 + int(math.ceil(no_coordinates / 5))
        ]
        cartesian_list = []
        for i in range(len(cartesian_coords)):
            cartesian_list.append(cartesian_coords[i].strip().split())
        coordinates_list = [
            item for sublist in cartesian_list for item in sublist
        ]
        list_coords = [float(x) * float(0.529) for x in coordinates_list]
        for i in range(len(lines)):
            if &#34;Atomic numbers&#34; in lines[i]:
                to_begin = int(i)
            if &#34;Nuclear charges&#34; in lines[i]:
                to_end = int(i)
        atomic_numbers = lines[to_begin + 1 : to_end]
        atom_numbers = []
        for i in range(len(atomic_numbers)):
            atom_numbers.append(atomic_numbers[i].strip().split())
        numbers = [item for sublist in atom_numbers for item in sublist]
        N = int(no_coordinates / 3)
        # Opens the new xyz file
        file = open(self.xyz_file, &#34;w&#34;)
        file.write(str(N) + &#34;\n \n&#34;)
        coords = np.zeros((N, 3))
        n = 0
        names = []
        # Gives name for atomic number
        for x in range(0, len(numbers)):
            names.append(element_list[int(numbers[x]) - 1][1])
        # Print coordinates to new input_coords.xyz file
        for i in range(0, N):
            for j in range(0, 3):
                coords[i][j] = list_coords[n]
                n = n + 1
            file.write(
                names[i]
                + str(round(coords[i][0], 3))
                + &#34; &#34;
                + str(round(coords[i][1], 3))
                + &#34; &#34;
                + str(round(coords[i][2], 3))
                + &#34;\n&#34;
            )
        file.close()
        np.savetxt(self.coordinate_file, coords, fmt=&#34;%s&#34;)

    def get_unprocessed_hessian(self):
        &#34;&#34;&#34;
        Saves a text file of the unprocessed hessian matrix from the 
        formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
        with open(fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Cartesian Force Constants&#34; in lines[i]:
                no_hessian = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
                no_hessian = int(no_hessian[0])
        for i in range(len(lines)):
            if &#34;Cartesian Force Constants&#34; in lines[i]:
                to_begin = int(i)
        hessian = lines[
            to_begin + 1 : to_begin + 1 + int(math.ceil(no_hessian / 5))
        ]
        hessian_list = []
        for i in range(len(hessian)):
            hessian_list.append(hessian[i].strip().split())
        unprocessed_Hessian = [
            item for sublist in hessian_list for item in sublist
        ]
        np.savetxt(
            self.unprocessed_hessian_file, unprocessed_Hessian, fmt=&#34;%s&#34;
        )

    def get_bond_angles(self):
        &#34;&#34;&#34;
        Saves a text file containing bonds and angles from the gaussian 
        log file.
        &#34;&#34;&#34;
        log_file = self.guest_pdb[:-4] + &#34;.log&#34;
        fid = open(log_file, &#34;r&#34;)
        tline = fid.readline()
        bond_list = []
        angle_list = []
        n = 1
        n_bond = 1
        n_angle = 1
        tmp = &#34;R&#34;  # States if bond or angle
        B = []
        # Finds the bond and angles from the .log file
        while tline:
            tline = fid.readline()
            # Line starts at point when bond and angle list occurs
            if (
                len(tline) &gt; 80
                and tline[0:81].strip()
                == &#34;! Name  Definition              Value          Derivative Info.                !&#34;
            ):
                tline = fid.readline()
                tline = fid.readline()
                # Stops when all bond and angles recorded
                while (tmp[0] == &#34;R&#34;) or (tmp[0] == &#34;A&#34;):
                    line = tline.split()
                    tmp = line[1]
                    # Bond or angles listed as string
                    list_terms = line[2][2:-1]
                    # Bond List
                    if tmp[0] == &#34;R&#34;:
                        x = list_terms.split(&#34;,&#34;)
                        # Subtraction due to python array indexing at 0
                        x = [(int(i) - 1) for i in x]
                        bond_list.append(x)
                        # Angle List
                    if tmp[0] == &#34;A&#34;:
                        x = list_terms.split(&#34;,&#34;)
                        # Subtraction due to python array indexing at 0
                        x = [(int(i) - 1) for i in x]
                        angle_list.append(x)
                    tline = fid.readline()
                # Leave loop
                tline = -1
        np.savetxt(self.bond_list_file, bond_list, fmt=&#34;%s&#34;)
        np.savetxt(self.angle_list_file, angle_list, fmt=&#34;%s&#34;)

    def get_hessian(self):
        &#34;&#34;&#34;
        Extracts hessian matrix from the unprocessed hessian matrix 
        and saves into a new file.
        &#34;&#34;&#34;
        unprocessed_Hessian = np.loadtxt(self.unprocessed_hessian_file)
        fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
        with open(fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
                no_coordinates = int(no_coordinates[0])
        N = int(no_coordinates / 3)
        length_hessian = 3 * N
        hessian = np.zeros((length_hessian, length_hessian))
        m = 0
        # Write the hessian in a 2D array format
        for i in range(0, (length_hessian)):
            for j in range(0, (i + 1)):
                hessian[i][j] = unprocessed_Hessian[m]
                hessian[j][i] = unprocessed_Hessian[m]
                m = m + 1
        hessian = (hessian * (627.509391)) / (
            0.529 ** 2
        )  # Change from Hartree/bohr to kcal/mol/ang
        np.savetxt(self.hessian_file, hessian, fmt=&#34;%s&#34;)

    def get_atom_names(self):
        &#34;&#34;&#34;
        Saves a list of atom names from the formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
        with open(fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Atomic numbers&#34; in lines[i]:
                to_begin = int(i)
            if &#34;Nuclear charges&#34; in lines[i]:
                to_end = int(i)
        atomic_numbers = lines[to_begin + 1 : to_end]
        atom_numbers = []
        for i in range(len(atomic_numbers)):
            atom_numbers.append(atomic_numbers[i].strip().split())
        numbers = [item for sublist in atom_numbers for item in sublist]
        names = []
        # Gives name for atomic number
        for x in range(0, len(numbers)):
            names.append(element_list[int(numbers[x]) - 1][1])
        atom_names = []
        for i in range(0, len(names)):
            atom_names.append(names[i].strip() + str(i + 1))
        np.savetxt(self.atom_names_file, atom_names, fmt=&#34;%s&#34;)

    def get_bond_angle_params(self):
        &#34;&#34;&#34;
        Saves the bond and angle parameter files obtained from 
        the formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
        with open(fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
                no_coordinates = int(no_coordinates[0])
        N = int(no_coordinates / 3)
        coords = np.loadtxt(self.coordinate_file)
        hessian = np.loadtxt(self.hessian_file)
        bond_list = np.loadtxt(self.bond_list_file, dtype=int)
        atom_names = np.loadtxt(self.atom_names_file, dtype=str)
        # Find bond lengths
        bond_lengths = np.zeros((N, N))
        for i in range(0, N):
            for j in range(0, N):
                diff_i_j = np.array(coords[i, :]) - np.array(coords[j, :])
                bond_lengths[i][j] = np.linalg.norm(diff_i_j)
        eigenvectors = np.empty((3, 3, N, N), dtype=complex)
        eigenvalues = np.empty((N, N, 3), dtype=complex)
        partial_hessian = np.zeros((3, 3))
        for i in range(0, N):
            for j in range(0, N):
                partial_hessian = hessian[
                    (i * 3) : ((i + 1) * 3), (j * 3) : ((j + 1) * 3)
                ]
                [a, b] = np.linalg.eig(partial_hessian)
                eigenvalues[i, j, :] = a
                eigenvectors[:, :, i, j] = b
        # Modified Seminario method to find the bond parameters and print them to file
        file_bond = open(self.bond_parameter_file, &#34;w&#34;)
        k_b = np.zeros(len(bond_list))
        bond_length_list = np.zeros(len(bond_list))
        unique_values_bonds = []  # Used to find average values
        for i in range(0, len(bond_list)):
            AB = force_constant_bond(
                bond_list[i][0],
                bond_list[i][1],
                eigenvalues,
                eigenvectors,
                coords,
            )
            BA = force_constant_bond(
                bond_list[i][1],
                bond_list[i][0],
                eigenvalues,
                eigenvectors,
                coords,
            )
            # Order of bonds sometimes causes slight differences, find the mean
            k_b[i] = np.real((AB + BA) / 2)
            # Vibrational_scaling takes into account DFT deficities/ anharmocity
            vibrational_scaling_squared = self.vibrational_scaling ** 2
            k_b[i] = k_b[i] * vibrational_scaling_squared
            bond_length_list[i] = bond_lengths[bond_list[i][0]][
                bond_list[i][1]
            ]
            file_bond.write(
                atom_names[bond_list[i][0]]
                + &#34;-&#34;
                + atom_names[bond_list[i][1]]
                + &#34;  &#34;
            )
            file_bond.write(
                str(&#34;%#.5g&#34; % k_b[i])
                + &#34;   &#34;
                + str(&#34;%#.4g&#34; % bond_length_list[i])
                + &#34;   &#34;
                + str(bond_list[i][0] + 1)
                + &#34;   &#34;
                + str(bond_list[i][1] + 1)
            )
            file_bond.write(&#34;\n&#34;)
            unique_values_bonds.append(
                [
                    atom_names[bond_list[i][0]],
                    atom_names[bond_list[i][1]],
                    k_b[i],
                    bond_length_list[i],
                    1,
                ]
            )
        file_bond.close()
        angle_list = np.loadtxt(self.angle_list_file, dtype=int)
        # Modified Seminario method to find the angle parameters and print them to file
        file_angle = open(self.angle_parameter_file, &#34;w&#34;)
        k_theta = np.zeros(len(angle_list))
        theta_0 = np.zeros(len(angle_list))
        unique_values_angles = []  # Used to find average values
        # Modified Seminario part goes here ...
        # Connectivity information for Modified Seminario Method
        central_atoms_angles = []
        # A structure is created with the index giving the central atom of the angle, 
        # an array then lists the angles with that central atom.
        # i.e. central_atoms_angles{3} contains an array of angles with central atom 3
        for i in range(0, len(coords)):
            central_atoms_angles.append([])
            for j in range(0, len(angle_list)):
                if i == angle_list[j][1]:
                    # For angle ABC, atoms A C are written to array
                    AC_array = [angle_list[j][0], angle_list[j][2], j]
                    central_atoms_angles[i].append(AC_array)
                    # For angle ABC, atoms C A are written to array
                    CA_array = [angle_list[j][2], angle_list[j][0], j]
                    central_atoms_angles[i].append(CA_array)
        # Sort rows by atom number
        for i in range(0, len(coords)):
            central_atoms_angles[i] = sorted(
                central_atoms_angles[i], key=itemgetter(0)
            )
        # Find normals u_PA for each angle
        unit_PA_all_angles = []
        for i in range(0, len(central_atoms_angles)):
            unit_PA_all_angles.append([])
            for j in range(0, len(central_atoms_angles[i])):
                # For the angle at central_atoms_angles[i][j,:] the corresponding u_PA value
                # is found for the plane ABC and bond AB, where ABC corresponds to the order 
                # of the arguements. This is why the reverse order was also added
                unit_PA_all_angles[i].append(
                    u_PA_from_angles(
                        central_atoms_angles[i][j][0],
                        i,
                        central_atoms_angles[i][j][1],
                        coords,
                    )
                )
        # Finds the contributing factors from the other angle terms scaling_factor_all_angles 
        # = cell(max(max(angle_list))); %This array will contain scaling factor and angle
        # list position
        scaling_factor_all_angles = []
        for i in range(0, len(central_atoms_angles)):
            scaling_factor_all_angles.append([])
            for j in range(0, len(central_atoms_angles[i])):
                n = 1
                m = 1
                angles_around = 0
                additional_contributions = 0
                scaling_factor_all_angles[i].append([0, 0])
                # Position in angle list
                scaling_factor_all_angles[i][j][1] = central_atoms_angles[i][
                    j
                ][2]
                # Goes through the list of angles with the same central atom and computes the 
                # term need for the modified Seminario method
                # Forwards directions, finds the same bonds with the central atom i
                while (
                    (j + n) &lt; len(central_atoms_angles[i])
                ) and central_atoms_angles[i][j][0] == central_atoms_angles[i][
                    j + n
                ][
                    0
                ]:
                    additional_contributions = (
                        additional_contributions
                        + (
                            abs(
                                np.dot(
                                    unit_PA_all_angles[i][j][:],
                                    unit_PA_all_angles[i][j + n][:],
                                )
                            )
                        )
                        ** 2
                    )
                    n = n + 1
                    angles_around = angles_around + 1
                # Backwards direction, finds the same bonds with the central atom i
                while ((j - m) &gt;= 0) and central_atoms_angles[i][j][
                    0
                ] == central_atoms_angles[i][j - m][0]:
                    additional_contributions = (
                        additional_contributions
                        + (
                            abs(
                                np.dot(
                                    unit_PA_all_angles[i][j][:],
                                    unit_PA_all_angles[i][j - m][:],
                                )
                            )
                        )
                        ** 2
                    )
                    m = m + 1
                    angles_around = angles_around + 1
                if n != 1 or m != 1:
                    # Finds the mean value of the additional contribution to change to normal 
                    # Seminario method comment out + part
                    scaling_factor_all_angles[i][j][0] = 1 + (
                        additional_contributions / (m + n - 2)
                    )
                else:
                    scaling_factor_all_angles[i][j][0] = 1
        scaling_factors_angles_list = []
        for i in range(0, len(angle_list)):
            scaling_factors_angles_list.append([])
        # Orders the scaling factors according to the angle list
        for i in range(0, len(central_atoms_angles)):
            for j in range(0, len(central_atoms_angles[i])):
                scaling_factors_angles_list[
                    scaling_factor_all_angles[i][j][1]
                ].append(scaling_factor_all_angles[i][j][0])
        # Finds the angle force constants with the scaling factors included for each angle
        for i in range(0, len(angle_list)):
            # Ensures that there is no difference when the ordering is changed
            [AB_k_theta, AB_theta_0] = force_angle_constant(
                angle_list[i][0],
                angle_list[i][1],
                angle_list[i][2],
                bond_lengths,
                eigenvalues,
                eigenvectors,
                coords,
                scaling_factors_angles_list[i][0],
                scaling_factors_angles_list[i][1],
            )
            [BA_k_theta, BA_theta_0] = force_angle_constant(
                angle_list[i][2],
                angle_list[i][1],
                angle_list[i][0],
                bond_lengths,
                eigenvalues,
                eigenvectors,
                coords,
                scaling_factors_angles_list[i][1],
                scaling_factors_angles_list[i][0],
            )
            k_theta[i] = (AB_k_theta + BA_k_theta) / 2
            theta_0[i] = (AB_theta_0 + BA_theta_0) / 2
            # Vibrational_scaling takes into account DFT deficities/ anharmonicity
            k_theta[i] = k_theta[i] * vibrational_scaling_squared
            file_angle.write(
                atom_names[angle_list[i][0]]
                + &#34;-&#34;
                + atom_names[angle_list[i][1]]
                + &#34;-&#34;
                + atom_names[angle_list[i][2]]
                + &#34;  &#34;
            )
            file_angle.write(
                str(&#34;%#.4g&#34; % k_theta[i])
                + &#34;   &#34;
                + str(&#34;%#.4g&#34; % theta_0[i])
                + &#34;   &#34;
                + str(angle_list[i][0] + 1)
                + &#34;   &#34;
                + str(angle_list[i][1] + 1)
                + &#34;   &#34;
                + str(angle_list[i][2] + 1)
            )
            file_angle.write(&#34;\n&#34;)
            unique_values_angles.append(
                [
                    atom_names[angle_list[i][0]],
                    atom_names[angle_list[i][1]],
                    atom_names[angle_list[i][2]],
                    k_theta[i],
                    theta_0[i],
                    1,
                ]
            )
        file_angle.close()

    def get_charges(self):
        &#34;&#34;&#34;
        Saves the atomic charges in a text file obtained from
        the Gaussian log file.
        &#34;&#34;&#34;
        log_file = self.guest_pdb[:-4] + &#34;.log&#34;
        with open(log_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Fitting point charges to electrostatic potential&#34; in lines[i]:
                to_begin = int(i)
            if &#34; Sum of ESP charges =&#34; in lines[i]:
                to_end = int(i)
        charges = lines[to_begin + 4 : to_end]
        charge_list = []
        for i in range(len(charges)):
            charge_list.append(charges[i].strip().split())
        charge_list_value = []
        atom_list = []
        for i in range(len(charge_list)):
            charge_list_value.append(charge_list[i][2])
            atom_list.append(charge_list[i][1])
        data_tuples = list(zip(atom_list, charge_list_value))
        df_charge = pd.DataFrame(data_tuples, columns=[&#34;Atom&#34;, &#34;Charge&#34;])
        df_charge.to_csv(
            self.charge_parameter_file, index=False, header=False, sep=&#34; &#34;
        )

    def get_proper_dihedrals(self):
        &#34;&#34;&#34;
        Saves proper dihedral angles of the ligand in a text file.
        &#34;&#34;&#34;
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_pdb)
        no_atoms = len(ppdb.df[&#34;ATOM&#34;])
        atom_index_list = []
        for i in range(no_atoms):
            atom_index_list.append(i + 1)
        possible_dihedrals = []
        for dihed in itertools.permutations(atom_index_list, 4):
            possible_dihedrals.append(dihed)
        df_bonds = pd.read_csv(
            self.bond_parameter_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df_bonds.columns = [
            &#34;bond&#34;,
            &#34;k_bond&#34;,
            &#34;bond_length&#34;,
            &#34;bond_1&#34;,
            &#34;bond_2&#34;,
        ]
        bond1 = df_bonds[&#34;bond_1&#34;].values.tolist()
        bond2 = df_bonds[&#34;bond_2&#34;].values.tolist()
        bond_list_list = []
        for i in range(len(bond1)):
            args = (bond1[i], bond2[i])
            bond_list_list.append(list(args))
        reverse_bond_list_list = []
        for bonds in bond_list_list:
            reverse_bond_list_list.append(reverse_list(bonds))
        bond_lists = bond_list_list + reverse_bond_list_list
        proper_dihed_repeated = []
        for i in range(len(possible_dihedrals)):
            dihed_frag = (
                [possible_dihedrals[i][0], possible_dihedrals[i][1]],
                [possible_dihedrals[i][1], possible_dihedrals[i][2]],
                [possible_dihedrals[i][2], possible_dihedrals[i][3]],
            )
            a = [
                dihed_frag[0] in bond_lists,
                dihed_frag[1] in bond_lists,
                dihed_frag[2] in bond_lists,
            ]
            if a == [True, True, True]:
                proper_dihed_repeated.append(possible_dihedrals[i])

        len_repeated_dihed_list = len(proper_dihed_repeated)
        proper_dihedrals = proper_dihed_repeated
        for x in proper_dihedrals:
            z = x[::-1]
            if z in proper_dihedrals:
                proper_dihedrals.remove(z)
        len_non_repeated_dihed_list = len(proper_dihedrals)
        # print(len_repeated_dihed_list == len_non_repeated_dihed_list * 2)
        np.savetxt(self.proper_dihedral_file, proper_dihedrals, fmt=&#34;%s&#34;)
        # return(proper_dihedrals)


class PrepareGaussianHost:
    &#34;&#34;&#34;
    A class used to prepare the QM engine input file (Gaussian) 
    for the receptor and run QM calculations with appropriate keywords. 

    This class contain methods to write an input file (.com extension)
    for the QM engine. It then runs a QM calculation with the given
    basis set and functional. Checkpoint file is then converted to 
    a formatted checkpoint file. Output files (.log, .chk, and .fhck)
    will then be used to extract receptors&#39;s force field parameters. 

    ...

    Attributes
    ----------
    charge : int
        Charge of the receptor. 

    multiplicity: int
        Spin Multiplicity (2S+1) of the receptor where S represents 
        the total spin of the receptor. 

    host_qm_pdb: str, optional
        PDB file of the receptor&#39;s QM region with atom numbers 
        beginning from 1.

    n_processors : int, optional
        Number of processors to be used for Gaussian program to run and 
        set in %NProcShared command of Gaussian.

    memory : int, optional
        Memory (in GB) to be used set in %Mem command of Gaussian.

    functional: str, optional
        Exchange/Correlation or hybrid functional to use in the Gaussian
        QM calculation.

    basis_set: str, optional
        Basis set to use for the Gaussian QM calculation.

    optimisation: str, optional
        set to &#34;OPT&#34; to perform a geometry optimization on the receptor
        specified in the system; else set to an empty string.

    frequency: str, optional
        set to &#34;FREQ&#34; for Gaussian to perform a frequency calculation;
        else set to an empty string.

    add_keywords_I: str, optional
        Specifies the integration grid.

    add_keywords_II: str, optional
        Specifies the Gaussian described options for generating
        population.

    add_keywords_III: str, optional
        Used to include the IOp keyword (to set the internal options to
        specific values) in the Gaussian command.

    gauss_out_file: str, optional
        This file contains the output script obtained after running
        the Gaussian QM calculation.

    fchk_out_file: str, optional
        Formatted checkpoint file obtained from the checkpoint file
        using formchk command.

    &#34;&#34;&#34;

    def __init__(
        self,
        charge,
        multiplicity,
        host_qm_pdb=&#34;host_qm.pdb&#34;,
        n_processors=12,
        memory=50,
        functional=&#34;B3LYP&#34;,
        basis_set=&#34;6-31G&#34;,
        optimisation=&#34;OPT&#34;,
        frequency=&#34;FREQ&#34;,
        add_keywords_I=&#34;Integral=(Grid=UltraFine)&#34;,
        add_keywords_II=&#34;Pop(MK,ReadRadii)&#34;,
        add_keywords_III=&#34;IOp(6/33=2,6/42=6)&#34;,
        gauss_out_file=&#34;host_qm.out&#34;,
        fchk_out_file=&#34;host_qm_fchk.out&#34;,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        charge : int
            Charge of the receptor. 

        multiplicity: int
            Spin Multiplicity (2S+1) of the receptor where S represents 
            the total spin of the receptor. 

        host_qm_pdb: str, optional
            PDB file of the receptor&#39;s QM region with atom numbers 
            beginning from 1.

        n_processors : int, optional
            Number of processors to be used for Gaussian program to run and 
            set in %NProcShared command of Gaussian.

        memory : int, optional
            Memory (in GB) to be used set in %Mem command of Gaussian.

        functional: str, optional
            Exchange/Correlation or hybrid functional to use in the Gaussian
            QM calculation.

        basis_set: str, optional
            Basis set to use for the Gaussian QM calculation.

        optimisation: str, optional
            set to &#34;OPT&#34; to perform a geometry optimization on the receptor
            specified in the system; else set to an empty string.

        frequency: str, optional
            set to &#34;FREQ&#34; for Gaussian to perform a frequency calculation;
            else set to an empty string.

        add_keywords_I: str, optional
            Specifies the integration grid.

        add_keywords_II: str, optional
            Specifies the Gaussian described options for generating
            population.

        add_keywords_III: str, optional
            Used to include the IOp keyword (to set the internal options to
            specific values) in the Gaussian command.

        gauss_out_file: str, optional
            This file contains the output script obtained after running
            the Gaussian QM calculation.

        fchk_out_file: str, optional
            Formatted checkpoint file obtained from the checkpoint file
            using formchk command.

        &#34;&#34;&#34;
        self.charge = charge
        self.multiplicity = multiplicity
        self.host_qm_pdb = host_qm_pdb
        self.n_processors = n_processors
        self.memory = memory
        self.functional = functional
        self.basis_set = basis_set
        self.optimisation = optimisation
        self.frequency = frequency
        self.gauss_out_file = gauss_out_file
        self.fchk_out_file = fchk_out_file
        self.add_keywords_I = add_keywords_I
        self.add_keywords_II = add_keywords_II
        self.add_keywords_III = add_keywords_III

    def write_input(self):
        &#34;&#34;&#34;
        Writes a Gaussian input file for the receptor QM region. 
        &#34;&#34;&#34;
        command_line_1 = &#34;%Chk = &#34; + self.host_qm_pdb[:-4] + &#34;.chk&#34;
        command_line_2 = &#34;%Mem = &#34; + str(self.memory) + &#34;GB&#34;
        command_line_3 = &#34;%NProcShared = &#34; + str(self.n_processors)
        command_line_4 = (
            &#34;# &#34;
            + self.functional
            + &#34; &#34;
            + self.basis_set
            + &#34; &#34;
            + self.optimisation
            + &#34; &#34;
            + self.frequency
            + &#34; &#34;
            + self.add_keywords_I
            + &#34; &#34;
            + self.add_keywords_II
            + &#34; &#34;
            + self.add_keywords_III
        )
        command_line_5 = &#34; &#34;
        command_line_6 = self.host_qm_pdb[:-4] + &#34; &#34; + &#34;gaussian input file&#34;
        command_line_7 = &#34; &#34;
        command_line_8 = str(self.charge) + &#34; &#34; + str(self.multiplicity)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_qm_pdb)
        df = ppdb.df[&#34;ATOM&#34;]
        df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
        df_1.columns = [&#34;atom&#34;]
        df_2 = df[[&#34;x_coord&#34;, &#34;y_coord&#34;, &#34;z_coord&#34;]]
        df_merged = pd.concat([df_1, df_2], axis=1)
        command_line_9 = df_merged.to_string(header=False, index=False)
        command_line_10 = &#34; &#34;
        command = [
            command_line_1,
            command_line_2,
            command_line_3,
            command_line_4,
            command_line_5,
            command_line_6,
            command_line_7,
            command_line_8,
            command_line_9,
            command_line_10,
        ]
        commands = &#34;\n&#34;.join(command)
        with open(self.host_qm_pdb[:-4] + &#34;.com&#34;, &#34;w&#34;) as f:
            f.write(commands)

    def run_gaussian(self):
        &#34;&#34;&#34;
        Runs the Gaussian QM calculation for the receptor locally.
        &#34;&#34;&#34;
        execute_command = (
            &#34;g16&#34;
            + &#34; &lt; &#34;
            + self.host_qm_pdb[:-4]
            + &#34;.com&#34;
            + &#34; &gt; &#34;
            + self.host_qm_pdb[:-4]
            + &#34;.log&#34;
        )
        with open(self.gauss_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell=True, stdout=f, stderr=sp.STDOUT)

    def get_fchk(self):
        &#34;&#34;&#34;
        Converts the Gaussian checkpoint file (.chk) to a formatted checkpoint
        file (.fchk).
        &#34;&#34;&#34;
        execute_command = (
            &#34;formchk&#34;
            + &#34; &#34;
            + self.host_qm_pdb[:-4]
            + &#34;.chk&#34;
            + &#34; &#34;
            + self.host_qm_pdb[:-4]
            + &#34;.fchk&#34;
        )
        with open(self.fchk_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell=True, stdout=f, stderr=sp.STDOUT)


class ParameterizeHost:
    &#34;&#34;&#34;
    A class used to obtain force field parameters for the QM region 
    of the receptor (bond, angle and charge parameters) from QM 
    calculations.

    This class contain methods to process the output files of the 
    Gaussian QM output files (.chk, .fchk and .log files). Methods 
    in the class extract the unprocessed hessian matrix from the 
    Gaussian QM calculations, processes it and uses the Modified 
    Seminario Method to ontain the bond and angle parameters. The 
    class also extracts the QM charges from the log file.

    ...

    Attributes
    ----------
    vibrational_scaling: float
        Vibrational scaling factor for the DFT deficits/anharmonicities
        in the bond parameters.

    xyz_file: str, optional
        XYZ file for ligand coordinates obtained from its corresponding 
        formatted checkpoint file.

    coordinate_file: str, optional
        Text file containing the receptor coordinates (extracted
        from the formatted checkpoint file).

    unprocessed_hessian_file: str, optional
        Unprocessed hessian matrix of the receptor obtained from the 
        formatted checkpoint file.

    bond_list_file: str, optional
        Text file containing the bond information of the receptor 
        extracted from the log file.

    angle_list_file: str, optional
        Text file containing the angle information of the receptor 
        extracted from the log file.

    hessian_file: str, optional
        Processed hessian matrix of the receptor.

    atom_names_file: str, optional
        Text file containing the list of atom names from the fchk file.

    bond_parameter_file: str, optional
        Text file containing the bond parameters for the receptor 
        obtained using the Modified Seminario method.

    angle_parameter_file: str, optional
        Text file containing the angle parameters of the receptor.

    charge_parameter_file: str, optional
        Text file containing the QM charges of the receptor.

    host_qm_pdb: str, optional
        PDB file for the receptor&#39;s QM region.

    &#34;&#34;&#34;

    def __init__(
        self,
        vibrational_scaling,
        xyz_file=&#34;host_qm_coords.xyz&#34;,
        coordinate_file=&#34;host_qm_coordinates.txt&#34;,
        unprocessed_hessian_file=&#34;host_qm_unprocessed_hessian.txt&#34;,
        bond_list_file=&#34;host_qm_bond_list.txt&#34;,
        angle_list_file=&#34;host_qm_angle_list.txt&#34;,
        hessian_file=&#34;host_qm_hessian.txt&#34;,
        atom_names_file=&#34;host_qm_atom_names.txt&#34;,
        bond_parameter_file=&#34;host_qm_bonds.txt&#34;,
        angle_parameter_file=&#34;host_qm_angles.txt&#34;,
        charge_parameter_file=&#34;host_qm_surround_charges.txt&#34;,
        host_qm_pdb=&#34;host_qm.pdb&#34;,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        vibrational_scaling: float
            Vibrational scaling factor for the DFT deficits/anharmonicities
            in the bond parameters.

        xyz_file: str, optional
            XYZ file for ligand coordinates obtained from its corresponding 
            formatted checkpoint file.

        coordinate_file: str, optional
            Text file containing the receptor coordinates (extracted
            from the formatted checkpoint file).

        unprocessed_hessian_file: str, optional
            Unprocessed hessian matrix of the receptor obtained from the 
            formatted checkpoint file.

        bond_list_file: str, optional
            Text file containing the bond information of the receptor 
            extracted from the log file.

        angle_list_file: str, optional
            Text file containing the angle information of the receptor 
            extracted from the log file.

        hessian_file: str, optional
            Processed hessian matrix of the receptor.

        atom_names_file: str, optional
            Text file containing the list of atom names from the fchk file.

        bond_parameter_file: str, optional
            Text file containing the bond parameters for the receptor 
            obtained using the Modified Seminario method.

        angle_parameter_file: str, optional
            Text file containing the angle parameters of the receptor.

        charge_parameter_file: str, optional
            Text file containing the QM charges of the receptor.

        host_qm_pdb: str, optional
            PDB file for the receptor&#39;s QM region.

        &#34;&#34;&#34;
        self.vibrational_scaling = vibrational_scaling
        self.xyz_file = xyz_file
        self.coordinate_file = coordinate_file
        self.unprocessed_hessian_file = unprocessed_hessian_file
        self.bond_list_file = bond_list_file
        self.angle_list_file = angle_list_file
        self.hessian_file = hessian_file
        self.atom_names_file = atom_names_file
        self.bond_parameter_file = bond_parameter_file
        self.angle_parameter_file = angle_parameter_file
        self.charge_parameter_file = charge_parameter_file
        self.host_qm_pdb = host_qm_pdb

    def get_xyz(self):
        &#34;&#34;&#34;
        Saves XYZ file from the formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
        with open(fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
                no_coordinates = int(no_coordinates[0])
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                to_begin = int(i)
        cartesian_coords = lines[
            to_begin + 1 : to_begin + 1 + int(math.ceil(no_coordinates / 5))
        ]
        cartesian_list = []
        for i in range(len(cartesian_coords)):
            cartesian_list.append(cartesian_coords[i].strip().split())
        coordinates_list = [
            item for sublist in cartesian_list for item in sublist
        ]
        list_coords = [float(x) * float(0.529) for x in coordinates_list]
        for i in range(len(lines)):
            if &#34;Atomic numbers&#34; in lines[i]:
                to_begin = int(i)
            if &#34;Nuclear charges&#34; in lines[i]:
                to_end = int(i)
        atomic_numbers = lines[to_begin + 1 : to_end]
        atom_numbers = []
        for i in range(len(atomic_numbers)):
            atom_numbers.append(atomic_numbers[i].strip().split())
        numbers = [item for sublist in atom_numbers for item in sublist]
        N = int(no_coordinates / 3)
        # Opens the new xyz file
        file = open(self.xyz_file, &#34;w&#34;)
        file.write(str(N) + &#34;\n \n&#34;)
        coords = np.zeros((N, 3))
        n = 0
        names = []
        # Gives name for atomic number
        for x in range(0, len(numbers)):
            names.append(element_list[int(numbers[x]) - 1][1])
        # Print coordinates to new input_coords.xyz file
        for i in range(0, N):
            for j in range(0, 3):
                coords[i][j] = list_coords[n]
                n = n + 1
            file.write(
                names[i]
                + str(round(coords[i][0], 3))
                + &#34; &#34;
                + str(round(coords[i][1], 3))
                + &#34; &#34;
                + str(round(coords[i][2], 3))
                + &#34;\n&#34;
            )
        file.close()
        np.savetxt(self.coordinate_file, coords, fmt=&#34;%s&#34;)

    def get_unprocessed_hessian(self):
        &#34;&#34;&#34;
        Saves a text file of the unprocessed hessian matrix from the 
        formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
        with open(fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Cartesian Force Constants&#34; in lines[i]:
                no_hessian = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
                no_hessian = int(no_hessian[0])
        for i in range(len(lines)):
            if &#34;Cartesian Force Constants&#34; in lines[i]:
                to_begin = int(i)
        hessian = lines[
            to_begin + 1 : to_begin + 1 + int(math.ceil(no_hessian / 5))
        ]
        hessian_list = []
        for i in range(len(hessian)):
            hessian_list.append(hessian[i].strip().split())
        unprocessed_Hessian = [
            item for sublist in hessian_list for item in sublist
        ]
        np.savetxt(
            self.unprocessed_hessian_file, unprocessed_Hessian, fmt=&#34;%s&#34;
        )

    def get_bond_angles(self):
        &#34;&#34;&#34;
        Saves a text file containing bonds and angles from the gaussian 
        log file.
        &#34;&#34;&#34;
        log_file = self.host_qm_pdb[:-4] + &#34;.log&#34;
        fid = open(log_file, &#34;r&#34;)
        tline = fid.readline()
        bond_list = []
        angle_list = []
        n = 1
        n_bond = 1
        n_angle = 1
        tmp = &#34;R&#34;  # States if bond or angle
        B = []
        # Finds the bond and angles from the .log file
        while tline:
            tline = fid.readline()
            # Line starts at point when bond and angle list occurs
            if (
                len(tline) &gt; 80
                and tline[0:81].strip()
                == &#34;! Name  Definition              Value          Derivative Info.                !&#34;
            ):
                tline = fid.readline()
                tline = fid.readline()
                # Stops when all bond and angles recorded
                while (tmp[0] == &#34;R&#34;) or (tmp[0] == &#34;A&#34;):
                    line = tline.split()
                    tmp = line[1]
                    # Bond or angles listed as string
                    list_terms = line[2][2:-1]
                    # Bond List
                    if tmp[0] == &#34;R&#34;:
                        x = list_terms.split(&#34;,&#34;)
                        # Subtraction due to python array indexing at 0
                        x = [(int(i) - 1) for i in x]
                        bond_list.append(x)
                        # Angle List
                    if tmp[0] == &#34;A&#34;:
                        x = list_terms.split(&#34;,&#34;)
                        # Subtraction due to python array indexing at 0
                        x = [(int(i) - 1) for i in x]
                        angle_list.append(x)
                    tline = fid.readline()
                # Leave loop
                tline = -1
        np.savetxt(self.bond_list_file, bond_list, fmt=&#34;%s&#34;)
        np.savetxt(self.angle_list_file, angle_list, fmt=&#34;%s&#34;)

    def get_hessian(self):
        &#34;&#34;&#34;
        Extracts hessian matrix from the unprocessed hessian matrix 
        and saves into a new file.
        &#34;&#34;&#34;
        unprocessed_Hessian = np.loadtxt(self.unprocessed_hessian_file)
        fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
        with open(fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
                no_coordinates = int(no_coordinates[0])
        N = int(no_coordinates / 3)
        length_hessian = 3 * N
        hessian = np.zeros((length_hessian, length_hessian))
        m = 0
        # Write the hessian in a 2D array format
        for i in range(0, (length_hessian)):
            for j in range(0, (i + 1)):
                hessian[i][j] = unprocessed_Hessian[m]
                hessian[j][i] = unprocessed_Hessian[m]
                m = m + 1
        hessian = (hessian * (627.509391)) / (
            0.529 ** 2
        )  # Change from Hartree/bohr to kcal/mol/ang
        np.savetxt(self.hessian_file, hessian, fmt=&#34;%s&#34;)

    def get_atom_names(self):
        &#34;&#34;&#34;
        Saves a list of atom names from the formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
        with open(fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Atomic numbers&#34; in lines[i]:
                to_begin = int(i)
            if &#34;Nuclear charges&#34; in lines[i]:
                to_end = int(i)
        atomic_numbers = lines[to_begin + 1 : to_end]
        atom_numbers = []
        for i in range(len(atomic_numbers)):
            atom_numbers.append(atomic_numbers[i].strip().split())
        numbers = [item for sublist in atom_numbers for item in sublist]
        names = []
        # Gives name for atomic number
        for x in range(0, len(numbers)):
            names.append(element_list[int(numbers[x]) - 1][1])
        atom_names = []
        for i in range(0, len(names)):
            atom_names.append(names[i].strip() + str(i + 1))
        np.savetxt(self.atom_names_file, atom_names, fmt=&#34;%s&#34;)

    def get_bond_angle_params(self):
        &#34;&#34;&#34;
        Saves the bond and angle parameter files obtained from 
        the formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
        with open(fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
                no_coordinates = int(no_coordinates[0])
        N = int(no_coordinates / 3)
        coords = np.loadtxt(self.coordinate_file)
        hessian = np.loadtxt(self.hessian_file)
        bond_list = np.loadtxt(self.bond_list_file, dtype=int)
        atom_names = np.loadtxt(self.atom_names_file, dtype=str)
        # Find bond lengths
        bond_lengths = np.zeros((N, N))
        for i in range(0, N):
            for j in range(0, N):
                diff_i_j = np.array(coords[i, :]) - np.array(coords[j, :])
                bond_lengths[i][j] = np.linalg.norm(diff_i_j)
        eigenvectors = np.empty((3, 3, N, N), dtype=complex)
        eigenvalues = np.empty((N, N, 3), dtype=complex)
        partial_hessian = np.zeros((3, 3))
        for i in range(0, N):
            for j in range(0, N):
                partial_hessian = hessian[
                    (i * 3) : ((i + 1) * 3), (j * 3) : ((j + 1) * 3)
                ]
                [a, b] = np.linalg.eig(partial_hessian)
                eigenvalues[i, j, :] = a
                eigenvectors[:, :, i, j] = b
        # Modified Seminario method to find the bond parameters and print them to file
        file_bond = open(self.bond_parameter_file, &#34;w&#34;)
        k_b = np.zeros(len(bond_list))
        bond_length_list = np.zeros(len(bond_list))
        unique_values_bonds = []  # Used to find average values
        for i in range(0, len(bond_list)):
            AB = force_constant_bond(
                bond_list[i][0],
                bond_list[i][1],
                eigenvalues,
                eigenvectors,
                coords,
            )
            BA = force_constant_bond(
                bond_list[i][1],
                bond_list[i][0],
                eigenvalues,
                eigenvectors,
                coords,
            )
            # Order of bonds sometimes causes slight differences, find the mean
            k_b[i] = np.real((AB + BA) / 2)
            # Vibrational_scaling takes into account DFT deficities/ anharmocity
            vibrational_scaling_squared = self.vibrational_scaling ** 2
            k_b[i] = k_b[i] * vibrational_scaling_squared
            bond_length_list[i] = bond_lengths[bond_list[i][0]][
                bond_list[i][1]
            ]
            file_bond.write(
                atom_names[bond_list[i][0]]
                + &#34;-&#34;
                + atom_names[bond_list[i][1]]
                + &#34;  &#34;
            )
            file_bond.write(
                str(&#34;%#.5g&#34; % k_b[i])
                + &#34;   &#34;
                + str(&#34;%#.4g&#34; % bond_length_list[i])
                + &#34;   &#34;
                + str(bond_list[i][0] + 1)
                + &#34;   &#34;
                + str(bond_list[i][1] + 1)
            )
            file_bond.write(&#34;\n&#34;)
            unique_values_bonds.append(
                [
                    atom_names[bond_list[i][0]],
                    atom_names[bond_list[i][1]],
                    k_b[i],
                    bond_length_list[i],
                    1,
                ]
            )
        file_bond.close()
        angle_list = np.loadtxt(self.angle_list_file, dtype=int)
        # Modified Seminario method to find the angle parameters and print them to file
        file_angle = open(self.angle_parameter_file, &#34;w&#34;)
        k_theta = np.zeros(len(angle_list))
        theta_0 = np.zeros(len(angle_list))
        unique_values_angles = []  # Used to find average values
        # Modified Seminario part goes here ...
        # Connectivity information for Modified Seminario Method
        central_atoms_angles = []
        # A structure is created with the index giving the central atom of the angle, an array then lists the angles with that central atom.
        # i.e. central_atoms_angles{3} contains an array of angles with central atom 3
        for i in range(0, len(coords)):
            central_atoms_angles.append([])
            for j in range(0, len(angle_list)):
                if i == angle_list[j][1]:
                    # For angle ABC, atoms A C are written to array
                    AC_array = [angle_list[j][0], angle_list[j][2], j]
                    central_atoms_angles[i].append(AC_array)
                    # For angle ABC, atoms C A are written to array
                    CA_array = [angle_list[j][2], angle_list[j][0], j]
                    central_atoms_angles[i].append(CA_array)
        # Sort rows by atom number
        for i in range(0, len(coords)):
            central_atoms_angles[i] = sorted(
                central_atoms_angles[i], key=itemgetter(0)
            )
        # Find normals u_PA for each angle
        unit_PA_all_angles = []
        for i in range(0, len(central_atoms_angles)):
            unit_PA_all_angles.append([])
            for j in range(0, len(central_atoms_angles[i])):
                # For the angle at central_atoms_angles[i][j,:] the corresponding u_PA value is found for the plane ABC and bond AB, where ABC corresponds to the order of the arguements. This is why the reverse order was also added
                unit_PA_all_angles[i].append(
                    u_PA_from_angles(
                        central_atoms_angles[i][j][0],
                        i,
                        central_atoms_angles[i][j][1],
                        coords,
                    )
                )
        # Finds the contributing factors from the other angle terms scaling_factor_all_angles = cell(max(max(angle_list))); %This array will contain scaling factor and angle list position
        scaling_factor_all_angles = []
        for i in range(0, len(central_atoms_angles)):
            scaling_factor_all_angles.append([])
            for j in range(0, len(central_atoms_angles[i])):
                n = 1
                m = 1
                angles_around = 0
                additional_contributions = 0
                scaling_factor_all_angles[i].append([0, 0])
                # Position in angle list
                scaling_factor_all_angles[i][j][1] = central_atoms_angles[i][
                    j
                ][2]
                # Goes through the list of angles with the same central atom and computes the term need for the modified Seminario method
                # Forwards directions, finds the same bonds with the central atom i
                while (
                    (j + n) &lt; len(central_atoms_angles[i])
                ) and central_atoms_angles[i][j][0] == central_atoms_angles[i][
                    j + n
                ][
                    0
                ]:
                    additional_contributions = (
                        additional_contributions
                        + (
                            abs(
                                np.dot(
                                    unit_PA_all_angles[i][j][:],
                                    unit_PA_all_angles[i][j + n][:],
                                )
                            )
                        )
                        ** 2
                    )
                    n = n + 1
                    angles_around = angles_around + 1
                # Backwards direction, finds the same bonds with the central atom i
                while ((j - m) &gt;= 0) and central_atoms_angles[i][j][
                    0
                ] == central_atoms_angles[i][j - m][0]:
                    additional_contributions = (
                        additional_contributions
                        + (
                            abs(
                                np.dot(
                                    unit_PA_all_angles[i][j][:],
                                    unit_PA_all_angles[i][j - m][:],
                                )
                            )
                        )
                        ** 2
                    )
                    m = m + 1
                    angles_around = angles_around + 1
                if n != 1 or m != 1:
                    # Finds the mean value of the additional contribution to change to normal Seminario method comment out + part
                    scaling_factor_all_angles[i][j][0] = 1 + (
                        additional_contributions / (m + n - 2)
                    )
                else:
                    scaling_factor_all_angles[i][j][0] = 1
        scaling_factors_angles_list = []
        for i in range(0, len(angle_list)):
            scaling_factors_angles_list.append([])
        # Orders the scaling factors according to the angle list
        for i in range(0, len(central_atoms_angles)):
            for j in range(0, len(central_atoms_angles[i])):
                scaling_factors_angles_list[
                    scaling_factor_all_angles[i][j][1]
                ].append(scaling_factor_all_angles[i][j][0])
        # Finds the angle force constants with the scaling factors included for each angle
        for i in range(0, len(angle_list)):
            # Ensures that there is no difference when the ordering is changed
            [AB_k_theta, AB_theta_0] = force_angle_constant(
                angle_list[i][0],
                angle_list[i][1],
                angle_list[i][2],
                bond_lengths,
                eigenvalues,
                eigenvectors,
                coords,
                scaling_factors_angles_list[i][0],
                scaling_factors_angles_list[i][1],
            )
            [BA_k_theta, BA_theta_0] = force_angle_constant(
                angle_list[i][2],
                angle_list[i][1],
                angle_list[i][0],
                bond_lengths,
                eigenvalues,
                eigenvectors,
                coords,
                scaling_factors_angles_list[i][1],
                scaling_factors_angles_list[i][0],
            )
            k_theta[i] = (AB_k_theta + BA_k_theta) / 2
            theta_0[i] = (AB_theta_0 + BA_theta_0) / 2
            # Vibrational_scaling takes into account DFT deficities/ anharmonicity
            k_theta[i] = k_theta[i] * vibrational_scaling_squared
            file_angle.write(
                atom_names[angle_list[i][0]]
                + &#34;-&#34;
                + atom_names[angle_list[i][1]]
                + &#34;-&#34;
                + atom_names[angle_list[i][2]]
                + &#34;  &#34;
            )
            file_angle.write(
                str(&#34;%#.4g&#34; % k_theta[i])
                + &#34;   &#34;
                + str(&#34;%#.4g&#34; % theta_0[i])
                + &#34;   &#34;
                + str(angle_list[i][0] + 1)
                + &#34;   &#34;
                + str(angle_list[i][1] + 1)
                + &#34;   &#34;
                + str(angle_list[i][2] + 1)
            )
            file_angle.write(&#34;\n&#34;)
            unique_values_angles.append(
                [
                    atom_names[angle_list[i][0]],
                    atom_names[angle_list[i][1]],
                    atom_names[angle_list[i][2]],
                    k_theta[i],
                    theta_0[i],
                    1,
                ]
            )
        file_angle.close()

    def get_charges(self):
        &#34;&#34;&#34;
        Saves the atomic charges in a text file obtained from
        the Gaussian log file.
        &#34;&#34;&#34;
        log_file = self.host_qm_pdb[:-4] + &#34;.log&#34;
        with open(log_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Fitting point charges to electrostatic potential&#34; in lines[i]:
                to_begin = int(i)
            if &#34; Sum of ESP charges =&#34; in lines[i]:
                to_end = int(i)
        charges = lines[to_begin + 4 : to_end]
        charge_list = []
        for i in range(len(charges)):
            charge_list.append(charges[i].strip().split())
        charge_list_value = []
        atom_list = []
        for i in range(len(charge_list)):
            charge_list_value.append(charge_list[i][2])
            atom_list.append(charge_list[i][1])
        data_tuples = list(zip(atom_list, charge_list_value))
        df_charge = pd.DataFrame(data_tuples, columns=[&#34;Atom&#34;, &#34;Charge&#34;])
        df_charge.to_csv(
            self.charge_parameter_file, index=False, header=False, sep=&#34; &#34;
        )


class GuestAmberXMLAmber:
    &#34;&#34;&#34;
    A class used to generate a template force field XML file for the ligand 
    in order regenerate the reparametrised forcefield XML file.

    This class contains methods to generate a template XML force field through 
    openforcefield. XML template generation can be obtained through different
    file formats such as PDB, SDF, and SMI. Methods support charged ligands as 
    well. Re-parameterized XML force field files are then generated from the 
    template files. Different energy components such as the bond, angle, 
    torsional and non-bonded energies are computed for the non-reparametrized 
    and the reparameterized force fields. Difference between the 
    non-reparameterized and reparameterized force field energies can then be 
    analyzed. 
    ...

    Attributes
    ----------
    charge : int
        Charge of the ligand. 

    num_charge_atoms: int
        Number of charged atoms in the molecule.

    charge_atom_1: int
        Charge on the first charged atom.

    index_charge_atom_1: int
        Index of the first charged atom.

    system_pdb: str, optional
        Ligand PDB file with atom numbers beginning from 1.

    system_mol2: str, optional
        Ligand Mol2 file obtained from PDB file.

    system_in: str, optional
        Prepi file as required by antechamber.

    system_frcmod: str, optional
        FRCMOD file as required by antechamber.

    prmtop_system : str, optional
        Topology file obtained from the ligand PDB.

    inpcrd_system : str, optional
        Coordinate file obtained from the Ligand PDB using the
        command saveamberparm.

    system_leap : str, optional
        Amber generated leap file for generating and saving topology 
        and coordinate files. 

    system_xml: str, optional
        Serialized XML force field file of the ligand.

    system_smi: str, optional
        Ligand SMILES format file. 

    system_sdf: str, optional
        Ligand SDF (structure-data) format file. 

    system_init_sdf: str, optional
        Ligand SDF (structure-data) format file. This file will be 
        generated only if the ligand is charged.

    index_charge_atom_2: int, optional
        Index of the second charged atom of the ligand.

    charge_atom_2: int, optional
        Charge on the second charged atom of the ligand.

    charge_parameter_file: str, optional
        File containing the charges of ligand atoms and their corresponding
        atoms.

    system_qm_pdb: str, optional
        Ligand PDB file with atom numbers beginning from 1.

    bond_parameter_file: str, optional
        Text file containing the bond parameters for the ligand.

    angle_parameter_file: str, optional
        Text file containing the angle parameters of the ligand.

    system_qm_params_file: str, optional
        A text file containing the QM obtained parameters for the 
        ligand. 

    reparameterised_intermediate_system_xml_file: str, optional
        XML foce field file with bond and angle parameter lines replaced by
        corresponding values obtained from the QM calculations.

    system_xml_non_bonded_file: str, optional
        A text file to write the NonBondedForce Charge Parameters from
        the non-parametrised system XML file.

    system_xml_non_bonded_reparams_file: str, optional
        Text file containing the non-bonded parameters parsed from the 
        XML force field file.

    reparameterised_system_xml_file: str, optional
        Reparameterized force field XML file obtained using 
        openforcefield.

    non_reparameterised_system_xml_file: str, optional
        Non-reparameterized force field XML file obtained using 
        openforcefield.

    prmtop_system_non_params: str, optional
        Amber generated topology file saved from the non-reparameterized 
        force field XML file for the ligand.

    inpcrd_system_non_params: str, optional
        Amber generated coordinate file saved from the non-reparameterized 
        force field XML file for the ligand.

    prmtop_system_params: str, optional
        Amber generated topology file saved from the reparameterized 
        force field XML file for the ligand.

    inpcrd_system_params: str, optional
        Amber generated coordinate file saved from the reparameterized 
        force field XML file for the ligand.

    load_topology: str, optional
        Argument to specify how to load the topology. Can either be &#34;openmm&#34;
        or &#34;parmed&#34;.

    &#34;&#34;&#34;

    def __init__(
        self,
        charge,
        num_charge_atoms,
        charge_atom_1,
        index_charge_atom_1,
        system_pdb=&#34;guest_init_II.pdb&#34;,
        system_mol2=&#34;guest.mol2&#34;,
        system_in=&#34;guest.in&#34;,
        system_frcmod=&#34;guest.frcmod&#34;,
        prmtop_system=&#34;guest.prmtop&#34;,
        inpcrd_system=&#34;guest.inpcrd&#34;,
        system_leap=&#34;guest.leap&#34;,
        system_xml=&#34;guest_init.xml&#34;,
        system_smi=&#34;guest.smi&#34;,
        system_sdf=&#34;guest.sdf&#34;,
        system_init_sdf=&#34;guest_init.sdf&#34;,
        index_charge_atom_2=&#34; &#34;,
        charge_atom_2=&#34; &#34;,
        charge_parameter_file=&#34;guest_charges.txt&#34;,
        system_qm_pdb=&#34;guest_init_II.pdb&#34;,
        bond_parameter_file=&#34;guest_bonds.txt&#34;,
        angle_parameter_file=&#34;guest_angles.txt&#34;,
        system_qm_params_file=&#34;guest_qm_params.txt&#34;,
        reparameterised_intermediate_system_xml_file=&#34;guest_intermediate_reparameterised.xml&#34;,
        system_xml_non_bonded_file=&#34;guest_xml_non_bonded.txt&#34;,
        system_xml_non_bonded_reparams_file=&#34;guest_xml_non_bonded_reparams.txt&#34;,
        reparameterised_system_xml_file=&#34;guest_reparameterised.xml&#34;,
        non_reparameterised_system_xml_file=&#34;guest_init.xml&#34;,
        prmtop_system_non_params=&#34;guest_non_params.prmtop&#34;,
        inpcrd_system_non_params=&#34;guest_non_params.inpcrd&#34;,
        prmtop_system_params=&#34;guest_params.prmtop&#34;,
        inpcrd_system_params=&#34;guest_params.inpcrd&#34;,
        load_topology=&#34;openmm&#34;,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        charge : int
            Charge of the ligand. 

        num_charge_atoms: int
            Number of charged atoms in the molecule.

        charge_atom_1: int
            Charge on the first charged atom.

        index_charge_atom_1: int
            Index of the first charged atom.

        system_pdb: str, optional
            Ligand PDB file with atom numbers beginning from 1.

        system_mol2: str, optional
            Ligand Mol2 file obtained from PDB file.

        system_in: str, optional
            Prepi file as required by antechamber.

        system_frcmod: str, optional
            FRCMOD file as required by antechamber.

        prmtop_system : str, optional
            Topology file obtained from the ligand PDB.

        inpcrd_system : str, optional
            Coordinate file obtained from the Ligand PDB using the
            command saveamberparm.

        system_leap : str, optional
            Amber generated leap file for generating and saving topology 
            and coordinate files. 

        system_xml: str, optional
            Serilazed XML force field file of the ligand.

        system_smi: str, optional
            Ligand SMILES format file. 

        system_sdf: str, optional
            Ligand SDF (structure-data) format file. 

        system_init_sdf: str, optional
            Ligand SDF (structure-data) format file. This file will be 
            generated only if the ligand is charged.

        index_charge_atom_2: int, optional
            Index of the second charged atom of the ligand.

        charge_atom_2: int, optional
            Charge on the second charged atom of the ligand.

        charge_parameter_file: str, optional
            File containing the charges of ligand atoms and their corresponding
            atoms.

        system_qm_pdb: str, optional
            Ligand PDB file with atom numbers beginning from 1.

        bond_parameter_file: str, optional
            Text file containing the bond parameters for the ligand.

        angle_parameter_file: str, optional
            Text file containing the angle parameters of the ligand.

        system_qm_params_file: str, optional
            A text file containing the QM obtained parameters for the 
            ligand. 

        reparameterised_intermediate_system_xml_file: str, optional
            XML foce field file with bond and angle parameter lines replaced by
            corresponding values obtained from the QM calculations.

        system_xml_non_bonded_file: str, optional
            A text file to write the NonBondedForce Charge Parameters from
            the non-parametrised system XML file.

        system_xml_non_bonded_reparams_file: str, optional
            Text file containing the non-bonded parameters parsed from the 
            XML force field file.

        reparameterised_system_xml_file: str, optional
            Reparameterized force field XML file obtained using 
            openforcefield.

        non_reparameterised_system_xml_file: str, optional
            Non-reparameterized force field XML file obtained using 
            openforcefield.

        prmtop_system_non_params: str, optional
            Amber generated topology file saved from the non-reparameterized 
            force field XML file for the ligand.

        inpcrd_system_non_params: str, optional
            Amber generated coordinate file saved from the non-reparameterized 
            force field XML file for the ligand.

        prmtop_system_params: str, optional
            Amber generated topology file saved from the reparameterized 
            force field XML file for the ligand.

        inpcrd_system_params: str, optional
            Amber generated coordinate file saved from the reparameterized 
            force field XML file for the ligand.

        load_topology: str, optional
            Argument to specify how to load the topology. Can either be &#34;openmm&#34;
            or &#34;parmed&#34;.

        &#34;&#34;&#34;
        self.charge = charge
        self.num_charge_atoms = num_charge_atoms
        self.charge_atom_1 = charge_atom_1
        self.index_charge_atom_1 = index_charge_atom_1
        self.system_pdb = system_pdb
        self.system_mol2 = system_mol2
        self.system_in = system_in
        self.system_frcmod = system_frcmod
        self.prmtop_system = prmtop_system
        self.inpcrd_system = inpcrd_system
        self.system_leap = system_leap
        self.system_xml = system_xml
        self.system_smi = system_smi
        self.system_sdf = system_sdf
        self.system_init_sdf = system_init_sdf
        self.index_charge_atom_2 = index_charge_atom_2
        self.charge_atom_2 = charge_atom_2
        self.charge_parameter_file = charge_parameter_file
        self.system_qm_pdb = system_qm_pdb
        self.bond_parameter_file = bond_parameter_file
        self.angle_parameter_file = angle_parameter_file
        self.system_qm_params_file = system_qm_params_file
        self.reparameterised_intermediate_system_xml_file = reparameterised_intermediate_system_xml_file
        self.system_xml_non_bonded_file = system_xml_non_bonded_file
        self.system_xml_non_bonded_reparams_file = system_xml_non_bonded_reparams_file
        self.reparameterised_system_xml_file = reparameterised_system_xml_file
        self.non_reparameterised_system_xml_file = non_reparameterised_system_xml_file
        self.prmtop_system_non_params = prmtop_system_non_params
        self.inpcrd_system_non_params = inpcrd_system_non_params
        self.prmtop_system_params = prmtop_system_params
        self.inpcrd_system_params = inpcrd_system_params
        self.load_topology = load_topology

    def generate_xml_antechamber(self):
        &#34;&#34;&#34;
        Generates an XML forcefield file from the PDB file through antechamber.
        &#34;&#34;&#34;
        command = (
            &#34;babel -ipdb &#34; + self.system_pdb + &#34; -omol2 &#34; + self.system_mol2
        )
        os.system(command)
        command = (
            &#34;antechamber -i &#34;
            + self.system_mol2
            + &#34; -fi mol2 -o &#34;
            + self.system_in
            + &#34; -fo prepi -c bcc -nc &#34;
            + str(self.charge)
        )
        os.system(command)
        command = (
            &#34;parmchk2 -i &#34;
            + self.system_in
            + &#34; -o &#34;
            + self.system_frcmod
            + &#34; -f prepi -a Y&#34;
        )
        os.system(command)
        os.system(
            &#34;rm -rf ANTECHAMBER* leap.log sqm* ATOMTYPE.INF PREP.INF NEWPDB.PDB&#34;
        )
        line_1 = &#34;loadamberprep &#34; + self.system_in
        line_2 = &#34;loadamberparams &#34; + self.system_frcmod
        line_3 = &#34;pdb = loadpdb &#34; + self.system_pdb
        line_4 = (
            &#34;saveamberparm pdb &#34;
            + self.prmtop_system
            + &#34; &#34;
            + self.inpcrd_system
        )
        line_5 = &#34;quit&#34;
        with open(self.system_leap, &#34;w&#34;) as f:
            f.write(&#34;    &#34; + &#34;\n&#34;)
            f.write(line_1 + &#34;\n&#34;)
            f.write(line_2 + &#34;\n&#34;)
            f.write(line_3 + &#34;\n&#34;)
            f.write(line_4 + &#34;\n&#34;)
            f.write(line_5 + &#34;\n&#34;)
        command = &#34;tleap -f &#34; + self.system_leap
        os.system(command)
        parm = parmed.load_file(self.prmtop_system, self.inpcrd_system)
        system = parm.createSystem()
        with open(self.system_xml, &#34;w&#34;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))

    def generate_xml_from_pdb_smi(self):
        &#34;&#34;&#34;
        Generates an XML forcefield file from the SMILES file through 
        openforcefield.
        &#34;&#34;&#34;
        off_molecule = openforcefield.topology.Molecule(self.system_smi)
        force_field = openforcefield.typing.engines.smirnoff.ForceField(
            &#34;openff_unconstrained-1.0.0.offxml&#34;
        )
        system = force_field.create_openmm_system(off_molecule.to_topology())
        pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
        structure = parmed.openmm.load_topology(
            pdbfile.topology, system, xyz=pdbfile.positions
        )
        with open(self.system_xml, &#34;w&#34;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))

    def generate_xml_from_pdb_sdf(self):
        &#34;&#34;&#34;
        Generates an XML forcefield file from the SDF file through 
        openforcefield.
        &#34;&#34;&#34;
        command = (
            &#34;babel -ipdb &#34; + self.system_pdb + &#34; -osdf &#34; + self.system_sdf
        )
        os.system(command)
        off_molecule = openforcefield.topology.Molecule(self.system_sdf)
        force_field = openforcefield.typing.engines.smirnoff.ForceField(
            &#34;openff_unconstrained-1.0.0.offxml&#34;
        )
        system = force_field.create_openmm_system(off_molecule.to_topology())
        pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
        structure = parmed.openmm.load_topology(
            pdbfile.topology, system, xyz=pdbfile.positions
        )
        with open(self.system_xml, &#34;w&#34;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))

    def generate_xml_from_charged_pdb_sdf(self):
        &#34;&#34;&#34;
        Generates an XML forcefield file for a singly charged ligand molecule 
        from the SDF file through openforcefield.
        &#34;&#34;&#34;
        command = (
            &#34;babel -ipdb &#34; + self.system_pdb + &#34; -osdf &#34; + self.system_init_sdf
        )
        os.system(command)
        with open(self.system_init_sdf, &#34;r&#34;) as f1:
            filedata = f1.readlines()
            filedata = filedata[:-2]
        with open(self.system_sdf, &#34;w+&#34;) as out:
            for i in filedata:
                out.write(i)
            line_1 = (
                &#34;M  CHG  &#34;
                + str(self.num_charge_atoms)
                + &#34;   &#34;
                + str(self.index_charge_atom_1)
                + &#34;   &#34;
                + str(self.charge_atom_1)
                + &#34;\n&#34;
            )
            line_2 = &#34;M  END&#34; + &#34;\n&#34;
            line_3 = &#34;$$$$&#34;
            out.write(line_1)
            out.write(line_2)
            out.write(line_3)
        off_molecule = openforcefield.topology.Molecule(self.system_sdf)
        force_field = openforcefield.typing.engines.smirnoff.ForceField(
            &#34;openff_unconstrained-1.0.0.offxml&#34;
        )
        system = force_field.create_openmm_system(off_molecule.to_topology())
        pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
        structure = parmed.openmm.load_topology(
            pdbfile.topology, system, xyz=pdbfile.positions
        )
        with open(self.system_xml, &#34;w&#34;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))

    def generate_xml_from_doubly_charged_pdb_sdf(self):
        &#34;&#34;&#34;
        Generates an XML forcefield file for a singly charged ligand molecule 
        from the SDF file through openforcefield.
        &#34;&#34;&#34;
        command = (
            &#34;babel -ipdb &#34; + self.system_pdb + &#34; -osdf &#34; + self.system_init_sdf
        )
        os.system(command)
        with open(self.system_init_sdf, &#34;r&#34;) as f1:
            filedata = f1.readlines()
            filedata = filedata[:-2]
        with open(self.system_sdf, &#34;w+&#34;) as out:
            for i in filedata:
                out.write(i)
            line_1 = (
                &#34;M  CHG  &#34;
                + str(self.num_charge_atoms)
                + &#34;   &#34;
                + str(self.index_charge_atom_1)
                + &#34;   &#34;
                + str(self.charge_atom_1)
                + &#34;   &#34;
                + str(self.index_charge_atom_2)
                + &#34;   &#34;
                + str(self.charge_atom_2)
                + &#34;\n&#34;
            )
            line_2 = &#34;M  END&#34; + &#34;\n&#34;
            line_3 = &#34;$$$$&#34;
            out.write(line_1)
            out.write(line_2)
            out.write(line_3)
        off_molecule = openforcefield.topology.Molecule(self.system_sdf)
        force_field = openforcefield.typing.engines.smirnoff.ForceField(
            &#34;openff_unconstrained-1.0.0.offxml&#34;
        )
        system = force_field.create_openmm_system(off_molecule.to_topology())
        pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
        structure = parmed.openmm.load_topology(
            pdbfile.topology, system, xyz=pdbfile.positions
        )
        with open(self.system_xml, &#34;w&#34;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))

    def write_system_params(self):
        &#34;&#34;&#34;
        Saves the parameters obtained from the QM log files in a text file.
        &#34;&#34;&#34;
        # Charges from QM files
        df_charges = pd.read_csv(
            self.charge_parameter_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df_charges.columns = [&#34;atom&#34;, &#34;charges&#34;]
        qm_charges = df_charges[&#34;charges&#34;].values.tolist()
        qm_charges = [round(num, 6) for num in qm_charges]
        # print(qm_charges)
        # Bond Parameters from QM files
        ppdb = PandasPdb()
        ppdb.read_pdb(self.system_qm_pdb)
        atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
        atom_name_list = [i - 1 for i in atom_name_list]
        # print(atom_name_list)
        df = pd.read_csv(
            self.bond_parameter_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df.columns = [&#34;bond&#34;, &#34;k_bond&#34;, &#34;bond_length&#34;, &#34;bond_1&#34;, &#34;bond_2&#34;]
        # print(df.head())
        bond_1_list = df[&#34;bond_1&#34;].values.tolist()
        bond_1_list = [x - 1 + min(atom_name_list) for x in bond_1_list]
        bond_2_list = df[&#34;bond_2&#34;].values.tolist()
        bond_2_list = [x - 1 + min(atom_name_list) for x in bond_2_list]
        # print(bond_1_list)
        # print(bond_2_list)
        k_bond_list = df[&#34;k_bond&#34;].values.tolist()
        k_bond_list = [i * 1000.00 for i in k_bond_list]
        k_bond_list = [round(num, 10) for num in k_bond_list]
        # print(k_bond_list)
        bond_length_list = df[&#34;bond_length&#34;].values.tolist()
        bond_length_list = [i / 10.00 for i in bond_length_list]
        bond_length_list = [round(num, 6) for num in bond_length_list]
        # print(bond_length_list)
        # Angle Parameters from QM files
        ppdb = PandasPdb()
        ppdb.read_pdb(self.system_qm_pdb)
        atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
        atom_name_list = [i - 1 for i in atom_name_list]
        # print(atom_name_list)
        df = pd.read_csv(
            self.angle_parameter_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df.columns = [
            &#34;angle&#34;,
            &#34;k_angle&#34;,
            &#34;angle_degrees&#34;,
            &#34;angle_1&#34;,
            &#34;angle_2&#34;,
            &#34;angle_3&#34;,
        ]
        # print(df.head())
        angle_1_list = df[&#34;angle_1&#34;].values.tolist()
        angle_1_list = [x - 1 + min(atom_name_list) for x in angle_1_list]
        # print(angle_1_list)
        angle_2_list = df[&#34;angle_2&#34;].values.tolist()
        angle_2_list = [x - 1 + min(atom_name_list) for x in angle_2_list]
        # print(angle_2_list)
        angle_3_list = df[&#34;angle_3&#34;].values.tolist()
        angle_3_list = [x - 1 + min(atom_name_list) for x in angle_3_list]
        # print(angle_3_list)
        k_angle_list = df[&#34;k_angle&#34;].values.tolist()
        k_angle_list = [round(num, 6) for num in k_angle_list]
        # print(k_angle_list)
        angle_list = df[&#34;angle_degrees&#34;].values.tolist()
        angle_list = [(i * math.pi) / 180.00 for i in angle_list]
        angle_list = [round(num, 6) for num in angle_list]
        # print(angle_list)
        xml = open(self.system_qm_params_file, &#34;w&#34;)
        xml.write(&#34;Begin writing the Bond Parameters&#34; + &#34;\n&#34;)
        for i in range(len(k_bond_list)):
            xml.write(
                &#34;                                &#34;
                + &#34;&lt;Bond&#34;
                + &#34; &#34;
                + &#34;d=&#34;
                + &#39;&#34;&#39;
                + str(bond_length_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;k=&#34;
                + &#39;&#34;&#39;
                + str(k_bond_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p1=&#34;
                + &#39;&#34;&#39;
                + str(bond_1_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + str(bond_2_list[i])
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
                + &#34;\n&#34;
            )
        xml.write(&#34;Finish writing the Bond Parameters&#34; + &#34;\n&#34;)
        xml.write(&#34;Begin writing the Angle Parameters&#34; + &#34;\n&#34;)
        for i in range(len(k_angle_list)):
            xml.write(
                &#34;                                &#34;
                + &#34;&lt;Angle&#34;
                + &#34; &#34;
                + &#34;a=&#34;
                + &#39;&#34;&#39;
                + str(angle_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;k=&#34;
                + &#39;&#34;&#39;
                + str(k_angle_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p1=&#34;
                + &#39;&#34;&#39;
                + str(angle_1_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + str(angle_2_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + str(angle_3_list[i])
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
                + &#34;\n&#34;
            )
        xml.write(&#34;Finish writing the Angle Parameters&#34; + &#34;\n&#34;)
        xml.write(&#34;Begin writing the Charge Parameters&#34; + &#34;\n&#34;)
        for i in range(len(qm_charges)):
            xml.write(
                &#34;&lt;Particle&#34;
                + &#34; &#34;
                + &#34;q=&#34;
                + &#39;&#34;&#39;
                + str(qm_charges[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;eps=&#34;
                + &#39;&#34;&#39;
                + str(0.00)
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;sig=&#34;
                + &#39;&#34;&#39;
                + str(0.00)
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;atom=&#34;
                + &#39;&#34;&#39;
                + str(atom_name_list[i])
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
                + &#34;\n&#34;
            )
        xml.write(&#34;Finish writing the Charge Parameters&#34; + &#34;\n&#34;)
        xml.close()

    def write_reparameterised_system_xml(self):
        &#34;&#34;&#34;
        Writes a reparameterised XML force field file for the ligand.
        &#34;&#34;&#34;
        # Bond Parameters
        f_params = open(self.system_qm_params_file, &#34;r&#34;)
        lines_params = f_params.readlines()
        # Bond Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Bond Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Bond Parameters&#34; in lines_params[i]:
                to_end = int(i)
        bond_params = lines_params[to_begin + 1 : to_end]
        index_search_replace_bond = []
        for i in bond_params:
            bond_line_to_replace = i
            # print(bond_line_to_replace)
            atom_number_list = [
                re.findall(&#34;\d*\.?\d+&#34;, i)[3],
                re.findall(&#34;\d*\.?\d+&#34;, i)[5],
            ]
            # print(atom_number_list)
            comb_1 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_2 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_list_bond = [comb_1, comb_2]
            # print(comb_list_bond)
            list_search_bond = [
                search_in_file(file=self.system_xml, word=comb_1),
                search_in_file(file=self.system_xml, word=comb_2),
            ]
            # print(list_search_bond)
            for j in range(len(list_search_bond)):
                if list_search_bond[j] != []:
                    to_add = (list_search_bond[j], i)
                    # print(to_add)
                    index_search_replace_bond.append(to_add)
        # Angle Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Angle Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Angle Parameters&#34; in lines_params[i]:
                to_end = int(i)
        angle_params = lines_params[to_begin + 1 : to_end]
        index_search_replace_angle = []
        for i in angle_params:
            angle_line_to_replace = i
            # print(angle_line_to_replace)
        index_search_replace_angle = []
        for i in angle_params:
            angle_line_to_replace = i
            # print(angle_line_to_replace)
            atom_number_list = [
                re.findall(&#34;\d*\.?\d+&#34;, i)[3],
                re.findall(&#34;\d*\.?\d+&#34;, i)[5],
                re.findall(&#34;\d*\.?\d+&#34;, i)[7],
            ]
            # print(atom_number_list)
            comb_1 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_2 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_3 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_4 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_5 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_6 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_list_angle = [comb_1, comb_2, comb_3, comb_4, comb_5, comb_6]
            # print(comb_list_angle)
            list_search_angle = [
                search_in_file(file=self.system_xml, word=comb_1),
                search_in_file(file=self.system_xml, word=comb_2),
                search_in_file(file=self.system_xml, word=comb_3),
                search_in_file(file=self.system_xml, word=comb_4),
                search_in_file(file=self.system_xml, word=comb_5),
                search_in_file(file=self.system_xml, word=comb_6),
            ]
            # print(list_search_angle)
            for j in range(len(list_search_angle)):
                if list_search_angle[j] != []:
                    to_add = (list_search_angle[j], i)
                    # print(to_add)
                    index_search_replace_angle.append(to_add)
        f_org = open(self.system_xml)
        lines = f_org.readlines()
        for i in range(len(index_search_replace_bond)):
            line_number = index_search_replace_bond[i][0][0][0] - 1
            line_to_replace = index_search_replace_bond[i][0][0][1]
            line_to_replace_with = index_search_replace_bond[i][1]
            lines[line_number] = line_to_replace_with
        for i in range(len(index_search_replace_angle)):
            line_number = index_search_replace_angle[i][0][0][0] - 1
            line_to_replace = index_search_replace_angle[i][0][0][1]
            line_to_replace_with = index_search_replace_angle[i][1]
            lines[line_number] = line_to_replace_with
        f_cop = open(self.reparameterised_intermediate_system_xml_file, &#34;w&#34;)
        for i in lines:
            f_cop.write(i)
        f_cop.close()

        f_params = open(self.system_qm_params_file)
        lines_params = f_params.readlines()
        # Charge Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Charge Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Charge Parameters&#34; in lines_params[i]:
                to_end = int(i)
        charge_params = lines_params[to_begin + 1 : to_end]
        non_bonded_index = []
        for k in charge_params:
            non_bonded_index.append(int(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, k)[3]))
        charge_for_index = []
        for k in charge_params:
            charge_for_index.append(
                float(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, k)[0])
            )

        xml_off = open(self.system_xml)
        xml_off_lines = xml_off.readlines()
        for i in range(len(xml_off_lines)):
            if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
                to_begin = int(i)
            if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
                to_end = int(i)
        nonbond_params = xml_off_lines[to_begin + 4 : to_end - 1]
        # print(len(nonbond_params))
        f_non_bonded = open(self.system_xml_non_bonded_file, &#34;w&#34;)
        for x in nonbond_params:
            f_non_bonded.write(x)

        f_non_bonded = open(self.system_xml_non_bonded_file)
        lines_non_bonded = f_non_bonded.readlines()
        # print(len(lines_non_bonded))
        lines_non_bonded_to_write = []
        for i in range(len(non_bonded_index)):
            line_ = lines_non_bonded[non_bonded_index[i]]
            # print(line_)
            eps = float(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, line_)[0])
            sig = float(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, line_)[2])
            line_to_replace = (
                &#34;                                &#34;
                + &#34;&lt;Particle &#34;
                + &#34;eps=&#34;
                + &#39;&#34;&#39;
                + str(eps)
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;q=&#34;
                + &#39;&#34;&#39;
                + str(charge_for_index[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;sig=&#34;
                + &#39;&#34;&#39;
                + str(sig)
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            lines_non_bonded_to_write.append(line_to_replace)
        data_ = list(zip(non_bonded_index, lines_non_bonded_to_write))

        df_non_bonded_params = pd.DataFrame(
            data_, columns=[&#34;line_index&#34;, &#34;line&#34;]
        )
        # print(df_non_bonded_params.head())
        f_non_bonded_ = open(self.system_xml_non_bonded_file)
        lines_non_bonded_ = f_non_bonded_.readlines()
        for i in range(len(lines_non_bonded_)):
            if i in non_bonded_index:
                lines_non_bonded_[i] = (
                    df_non_bonded_params.loc[
                        df_non_bonded_params.line_index == i, &#34;line&#34;
                    ].values[0]
                ) + &#34;\n&#34;
        # print(len(lines_non_bonded_))
        f_write_non_bonded_reparams = open(
            self.system_xml_non_bonded_reparams_file, &#34;w&#34;
        )
        for p in range(len(lines_non_bonded_)):
            f_write_non_bonded_reparams.write(lines_non_bonded_[p])
        f_write_non_bonded_reparams.close()
        f_ = open(self.system_xml_non_bonded_reparams_file)
        lines_ = f_.readlines()
        print(len(lines_) == len(lines_non_bonded))

        xml_off = open(self.reparameterised_intermediate_system_xml_file)
        xml_off_lines = xml_off.readlines()
        for i in range(len(xml_off_lines)):
            if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
                to_begin = int(i)
            if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
                to_end = int(i)

        lines_before_params = xml_off_lines[: to_begin + 4]
        f__ = open(self.system_xml_non_bonded_reparams_file)
        lines_params_non_bonded = f__.readlines()
        lines_after_params = xml_off_lines[to_end - 1 :]
        f_reparams_xml = open(self.reparameterised_system_xml_file, &#34;w&#34;)
        for x in lines_before_params:
            f_reparams_xml.write(x)
        for x in lines_params_non_bonded:
            f_reparams_xml.write(x)
        for x in lines_after_params:
            f_reparams_xml.write(x)
        f_reparams_xml.close()

    def save_amber_params(self):
        &#34;&#34;&#34;
        Saves amber generated topology files for the ligand.
        &#34;&#34;&#34;
        if self.load_topology == &#34;parmed&#34;:
            openmm_system = parmed.openmm.load_topology(
                parmed.load_file(self.system_pdb, structure=True).topology,
                parmed.load_file(self.non_reparameterised_system_xml_file),
            )
        if self.load_topology == &#34;openmm&#34;:
            openmm_system = parmed.openmm.load_topology(
                simtk.openmm.app.PDBFile(self.system_pdb).topology,
                parmed.load_file(self.non_reparameterised_system_xml_file),
            )
        openmm_system.save(self.prmtop_system_non_params, overwrite=True)
        openmm_system.coordinates = parmed.load_file(
            self.system_pdb, structure=True
        ).coordinates
        openmm_system.save(self.inpcrd_system_non_params, overwrite=True)
        parm = parmed.load_file(
            self.prmtop_system_non_params, self.inpcrd_system_non_params
        )

        xml_energy_decomposition = parmed.openmm.energy_decomposition_system(
            openmm_system,
            parmed.load_file(self.non_reparameterised_system_xml_file),
        )
        xml_energy_decomposition_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        xml_energy_decomposition_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_xml = pd.DataFrame(
            list(
                zip(
                    xml_energy_decomposition_list,
                    xml_energy_decomposition_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_xml_non_params&#34;],
        )
        df_energy_xml = df_energy_xml.set_index(&#34;Energy_term&#34;)

        prmtop_energy_decomposition = (
            parmed.openmm.energy_decomposition_system(
                parm, parm.createSystem()
            )
        )
        prmtop_energy_decomposition_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        prmtop_energy_decomposition_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_prmtop = pd.DataFrame(
            list(
                zip(
                    prmtop_energy_decomposition_list,
                    prmtop_energy_decomposition_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_prmtop_non_params&#34;],
        )
        df_energy_prmtop = df_energy_prmtop.set_index(&#34;Energy_term&#34;)

        df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
        print(df_compare)

        if self.load_topology == &#34;parmed&#34;:
            openmm_system = parmed.openmm.load_topology(
                parmed.load_file(self.system_pdb, structure=True).topology,
                parmed.load_file(self.reparameterised_system_xml_file),
            )
        if self.load_topology == &#34;openmm&#34;:
            openmm_system = parmed.openmm.load_topology(
                simtk.openmm.app.PDBFile(self.system_pdb).topology,
                parmed.load_file(self.reparameterised_system_xml_file),
            )
        openmm_system.save(self.prmtop_system_params, overwrite=True)
        openmm_system.coordinates = parmed.load_file(
            self.system_pdb, structure=True
        ).coordinates
        openmm_system.save(self.inpcrd_system_params, overwrite=True)
        parm = parmed.load_file(
            self.prmtop_system_params, self.inpcrd_system_params
        )

        xml_energy_decomposition = parmed.openmm.energy_decomposition_system(
            openmm_system,
            parmed.load_file(self.reparameterised_system_xml_file),
        )
        xml_energy_decomposition_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        xml_energy_decomposition_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_xml = pd.DataFrame(
            list(
                zip(
                    xml_energy_decomposition_list,
                    xml_energy_decomposition_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_xml_params&#34;],
        )
        df_energy_xml = df_energy_xml.set_index(&#34;Energy_term&#34;)

        prmtop_energy_decomposition = (
            parmed.openmm.energy_decomposition_system(
                parm, parm.createSystem()
            )
        )
        prmtop_energy_decomposition_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        prmtop_energy_decomposition_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_prmtop = pd.DataFrame(
            list(
                zip(
                    prmtop_energy_decomposition_list,
                    prmtop_energy_decomposition_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_prmtop_params&#34;],
        )
        df_energy_prmtop = df_energy_prmtop.set_index(&#34;Energy_term&#34;)

        df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
        print(df_compare)

    def analyze_diff_energies(self):
        &#34;&#34;&#34;
        Compares the energies of the ligand obtained from the non-parameterized 
        and the parameterized force field files.
        &#34;&#34;&#34;
        parm_non_params = parmed.load_file(
            self.prmtop_system_non_params, self.inpcrd_system_non_params
        )
        prmtop_energy_decomposition_non_params = (
            parmed.openmm.energy_decomposition_system(
                parm_non_params, parm_non_params.createSystem()
            )
        )
        prmtop_energy_decomposition_non_params_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_non_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_non_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_non_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_non_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        prmtop_energy_decomposition_non_params_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_non_params = pd.DataFrame(
            list(
                zip(
                    prmtop_energy_decomposition_non_params_list,
                    prmtop_energy_decomposition_non_params_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_parm_non_params&#34;],
        )
        df_energy_non_params = df_energy_non_params.set_index(&#34;Energy_term&#34;)
        # print(df_energy_non_params)
        parm_params = parmed.load_file(
            self.prmtop_system_params, self.inpcrd_system_params
        )
        prmtop_energy_decomposition_params = (
            parmed.openmm.energy_decomposition_system(
                parm_params, parm_params.createSystem()
            )
        )
        prmtop_energy_decomposition_params_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        prmtop_energy_decomposition_params_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_params = pd.DataFrame(
            list(
                zip(
                    prmtop_energy_decomposition_params_list,
                    prmtop_energy_decomposition_params_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_parm_params&#34;],
        )
        df_energy_params = df_energy_params.set_index(&#34;Energy_term&#34;)
        # print(df_energy_params)
        df_compare = pd.concat(
            [df_energy_non_params, df_energy_params], axis=1
        )
        df_compare[&#34;Energy_difference&#34;] = df_compare[
            &#34;Energy_parm_non_params&#34;
        ].sub(df_compare[&#34;Energy_parm_params&#34;], axis=0)
        print(df_compare)


class HostAmberXMLAmber:
    &#34;&#34;&#34;
    A class used to generate a template force field XML file for the receptor 
    in order regenerate the reparametrised forcefield XML file.

    This class contains methods to generate a template XML force field through 
    openforcefield. Re-parameterized XML force field files are then 
    generated from the template files. Different energy components such as 
    the bond,angle, torsional and non-bonded energies are computed for the 
    non-reparametrized and the reparameterized force fields. Difference 
    between the non-reparameterized and reparameterized force field energies 
    can then be analyzed. 
    ...

    Attributes
    ----------

    system_pdb: str, optional
        Receptor PDB file with atom numbers beginning from 1.

    system_xml: str, optional
        Serilazed XML force field file of the receptor.

    sim_output: str, optional
        PDB file containing the trajectory coordinates for the OpenMM
        simulation. 

    sim_steps: str, optional
        Number of steps in the OpenMM MD simulation.

    charge_parameter_file: str, optional
        File containing the charges of receptor atoms and their 
        corresponding atoms.

    system_qm_pdb: str, optional
        Receptor QM region&#39;s PDB file with atom numbers beginning from 1.

    bond_parameter_file: str, optional
        Text file containing the bond parameters for the receptor.

    angle_parameter_file: str, optional
        Text file containing the angle parameters of the receptor.

    system_qm_params_file: str, optional
        A text file containing the QM obtained parameters for the 
        receptor. 

    reparameterised_intermediate_system_xml_file: str, optional
        XML foce field file with bond and angle parameter lines replaced by
        corresponding values obtained from the QM calculations.

    system_xml_non_bonded_file: str, optional
        A text file to write the NonBondedForce Charge Parameters from
        the non-parametrised system XML file.

    system_xml_non_bonded_reparams_file: str, optional
        Text file containing the non-bonded parameters parsed from the 
        XML force field file.

    reparameterised_system_xml_file: str, optional
        Reparameterized force field XML file obtained using 
        openforcefield.

    non_reparameterised_system_xml_file: str, optional
        Non-reparameterized force field XML file obtained using 
        openforcefield.

    prmtop_system_non_params: str, optional
        Amber generated topology file saved from the non-reparameterized 
        force field XML file for the receptor.

    inpcrd_system_non_params: str, optional
        Amber generated coordinate file saved from the non-reparameterized 
        force field XML file for the receptor.

    prmtop_system_params: str, optional
        Amber generated topology file saved from the reparameterized 
        force field XML file for the receptor.

    inpcrd_system_params: str, optional
        Amber generated coordinate file saved from the reparameterized 
        force field XML file for the receptor.

    load_topology: str, optional
        Argument to specify how to load the topology. Can either be &#34;openmm&#34;
        or &#34;parmed&#34;.

    &#34;&#34;&#34;

    def __init__(
        self,
        system_pdb=&#34;host.pdb&#34;,
        system_xml=&#34;host.xml&#34;,
        sim_output=&#34;sim_output.pdb&#34;,
        sim_steps=1000,
        charge_parameter_file=&#34;host_qm_surround_charges.txt&#34;,
        system_qm_pdb=&#34;host_qm.pdb&#34;,
        bond_parameter_file=&#34;host_qm_bonds.txt&#34;,
        angle_parameter_file=&#34;host_qm_angles.txt&#34;,
        system_qm_params_file=&#34;host_qm_params.txt&#34;,
        reparameterised_intermediate_system_xml_file=&#34;host_intermediate_reparameterised.xml&#34;,
        system_xml_non_bonded_file=&#34;host_xml_non_bonded.txt&#34;,
        system_xml_non_bonded_reparams_file=&#34;host_xml_non_bonded_reparams.txt&#34;,
        reparameterised_system_xml_file=&#34;host_reparameterised.xml&#34;,
        non_reparameterised_system_xml_file=&#34;host.xml&#34;,
        prmtop_system_non_params=&#34;host_non_params.prmtop&#34;,
        inpcrd_system_non_params=&#34;host_non_params.inpcrd&#34;,
        prmtop_system_params=&#34;host_params.prmtop&#34;,
        inpcrd_system_params=&#34;host_params.inpcrd&#34;,
        load_topology=&#34;openmm&#34;,
    ):
        self.system_pdb = system_pdb
        self.system_xml = system_xml
        self.sim_output = sim_output
        self.sim_steps = sim_steps
        self.charge_parameter_file = charge_parameter_file
        self.system_qm_pdb = system_qm_pdb
        self.bond_parameter_file = bond_parameter_file
        self.angle_parameter_file = angle_parameter_file
        self.system_qm_params_file = system_qm_params_file
        self.reparameterised_intermediate_system_xml_file = reparameterised_intermediate_system_xml_file
        self.system_xml_non_bonded_file = system_xml_non_bonded_file
        self.system_xml_non_bonded_reparams_file = system_xml_non_bonded_reparams_file
        self.reparameterised_system_xml_file = reparameterised_system_xml_file
        self.non_reparameterised_system_xml_file = non_reparameterised_system_xml_file
        self.prmtop_system_non_params = prmtop_system_non_params
        self.inpcrd_system_non_params = inpcrd_system_non_params
        self.prmtop_system_params = prmtop_system_params
        self.inpcrd_system_params = inpcrd_system_params
        self.load_topology = load_topology

    def serialize_system(self):
        pdb = simtk.openmm.app.PDBFile(self.system_pdb)
        forcefield = simtk.openmm.app.ForceField(&#34;amber14-all.xml&#34;)
        system = forcefield.createSystem(pdb.topology)
        integrator = simtk.openmm.LangevinIntegrator(
            300 * simtk.unit.kelvin,
            1 / simtk.unit.picosecond,
            0.002 * simtk.unit.picoseconds,
        )
        simulation = simtk.openmm.app.Simulation(
            pdb.topology, system, integrator
        )
        simulation.context.setPositions(pdb.positions)
        simulation.minimizeEnergy()
        state = simulation.context.getState(getEnergy=True)
        energy = state.getPotentialEnergy()
        print(energy)
        simulation.reporters.append(
            simtk.openmm.app.PDBReporter(self.sim_output, self.sim_steps / 10)
        )
        simulation.reporters.append(
            simtk.openmm.app.StateDataReporter(
                stdout,
                reportInterval=int(self.sim_steps / 10),
                step=True,
                potentialEnergy=True,
                temperature=True,
            )
        )
        simulation.step(self.sim_steps)
        command = &#34;rm -rf &#34; + self.sim_output
        os.system(command)
        with open(self.system_xml, &#34;w&#34;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))

    def write_system_params(self):
        &#34;&#34;&#34;
        Saves the parameters obtained from the QM log files in a text file.
        &#34;&#34;&#34;
        # Charges from QM files
        df_charges = pd.read_csv(
            self.charge_parameter_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df_charges.columns = [&#34;atom&#34;, &#34;charges&#34;]
        qm_charges = df_charges[&#34;charges&#34;].values.tolist()
        qm_charges = [round(num, 6) for num in qm_charges]
        # print(qm_charges)
        # Bond Parameters from QM files
        ppdb = PandasPdb()
        ppdb.read_pdb(self.system_qm_pdb)
        atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
        atom_name_list = [i - 1 for i in atom_name_list]
        # print(atom_name_list)
        df = pd.read_csv(
            self.bond_parameter_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df.columns = [&#34;bond&#34;, &#34;k_bond&#34;, &#34;bond_length&#34;, &#34;bond_1&#34;, &#34;bond_2&#34;]
        # print(df.head())
        bond_1_list = df[&#34;bond_1&#34;].values.tolist()
        bond_1_list = [x - 1 + min(atom_name_list) for x in bond_1_list]
        bond_2_list = df[&#34;bond_2&#34;].values.tolist()
        bond_2_list = [x - 1 + min(atom_name_list) for x in bond_2_list]
        # print(bond_1_list)
        # print(bond_2_list)
        k_bond_list = df[&#34;k_bond&#34;].values.tolist()
        k_bond_list = [i * 1000.00 for i in k_bond_list]
        k_bond_list = [round(num, 10) for num in k_bond_list]
        # print(k_bond_list)
        bond_length_list = df[&#34;bond_length&#34;].values.tolist()
        bond_length_list = [i / 10.00 for i in bond_length_list]
        bond_length_list = [round(num, 6) for num in bond_length_list]
        # print(bond_length_list)
        # Angle Parameters from QM files
        ppdb = PandasPdb()
        ppdb.read_pdb(self.system_qm_pdb)
        atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
        atom_name_list = [i - 1 for i in atom_name_list]
        # print(atom_name_list)
        df = pd.read_csv(
            self.angle_parameter_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df.columns = [
            &#34;angle&#34;,
            &#34;k_angle&#34;,
            &#34;angle_degrees&#34;,
            &#34;angle_1&#34;,
            &#34;angle_2&#34;,
            &#34;angle_3&#34;,
        ]
        # print(df.head())
        angle_1_list = df[&#34;angle_1&#34;].values.tolist()
        angle_1_list = [x - 1 + min(atom_name_list) for x in angle_1_list]
        # print(angle_1_list)
        angle_2_list = df[&#34;angle_2&#34;].values.tolist()
        angle_2_list = [x - 1 + min(atom_name_list) for x in angle_2_list]
        # print(angle_2_list)
        angle_3_list = df[&#34;angle_3&#34;].values.tolist()
        angle_3_list = [x - 1 + min(atom_name_list) for x in angle_3_list]
        # print(angle_3_list)
        k_angle_list = df[&#34;k_angle&#34;].values.tolist()
        k_angle_list = [round(num, 6) for num in k_angle_list]
        # print(k_angle_list)
        angle_list = df[&#34;angle_degrees&#34;].values.tolist()
        angle_list = [(i * math.pi) / 180.00 for i in angle_list]
        angle_list = [round(num, 6) for num in angle_list]
        # print(angle_list)
        xml = open(self.system_qm_params_file, &#34;w&#34;)
        xml.write(&#34;Begin writing the Bond Parameters&#34; + &#34;\n&#34;)
        for i in range(len(k_bond_list)):
            xml.write(
                &#34;                                &#34;
                + &#34;&lt;Bond&#34;
                + &#34; &#34;
                + &#34;d=&#34;
                + &#39;&#34;&#39;
                + str(bond_length_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;k=&#34;
                + &#39;&#34;&#39;
                + str(k_bond_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p1=&#34;
                + &#39;&#34;&#39;
                + str(bond_1_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + str(bond_2_list[i])
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
                + &#34;\n&#34;
            )
        xml.write(&#34;Finish writing the Bond Parameters&#34; + &#34;\n&#34;)
        xml.write(&#34;Begin writing the Angle Parameters&#34; + &#34;\n&#34;)
        for i in range(len(k_angle_list)):
            xml.write(
                &#34;                                &#34;
                + &#34;&lt;Angle&#34;
                + &#34; &#34;
                + &#34;a=&#34;
                + &#39;&#34;&#39;
                + str(angle_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;k=&#34;
                + &#39;&#34;&#39;
                + str(k_angle_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p1=&#34;
                + &#39;&#34;&#39;
                + str(angle_1_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + str(angle_2_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + str(angle_3_list[i])
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
                + &#34;\n&#34;
            )
        xml.write(&#34;Finish writing the Angle Parameters&#34; + &#34;\n&#34;)
        xml.write(&#34;Begin writing the Charge Parameters&#34; + &#34;\n&#34;)
        for i in range(len(qm_charges)):
            xml.write(
                &#34;&lt;Particle&#34;
                + &#34; &#34;
                + &#34;q=&#34;
                + &#39;&#34;&#39;
                + str(qm_charges[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;eps=&#34;
                + &#39;&#34;&#39;
                + str(0.00)
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;sig=&#34;
                + &#39;&#34;&#39;
                + str(0.00)
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;atom=&#34;
                + &#39;&#34;&#39;
                + str(atom_name_list[i])
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
                + &#34;\n&#34;
            )
        xml.write(&#34;Finish writing the Charge Parameters&#34; + &#34;\n&#34;)
        xml.close()

    def write_reparameterised_system_xml(self):
        &#34;&#34;&#34;
        Writes a reparameterised XML force field file for the ligand.
        &#34;&#34;&#34;
        # Bond Parameters
        f_params = open(self.system_qm_params_file, &#34;r&#34;)
        lines_params = f_params.readlines()
        # Bond Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Bond Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Bond Parameters&#34; in lines_params[i]:
                to_end = int(i)
        bond_params = lines_params[to_begin + 1 : to_end]
        index_search_replace_bond = []
        for i in bond_params:
            bond_line_to_replace = i
            # print(bond_line_to_replace)
            atom_number_list = [
                re.findall(&#34;\d*\.?\d+&#34;, i)[3],
                re.findall(&#34;\d*\.?\d+&#34;, i)[5],
            ]
            # print(atom_number_list)
            comb_1 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_2 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_list_bond = [comb_1, comb_2]
            # print(comb_list_bond)
            list_search_bond = [
                search_in_file(file=self.system_xml, word=comb_1),
                search_in_file(file=self.system_xml, word=comb_2),
            ]
            # print(list_search_bond)
            for j in range(len(list_search_bond)):
                if list_search_bond[j] != []:
                    to_add = (list_search_bond[j], i)
                    # print(to_add)
                    index_search_replace_bond.append(to_add)
        # Angle Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Angle Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Angle Parameters&#34; in lines_params[i]:
                to_end = int(i)
        angle_params = lines_params[to_begin + 1 : to_end]
        index_search_replace_angle = []
        for i in angle_params:
            angle_line_to_replace = i
            # print(angle_line_to_replace)
        index_search_replace_angle = []
        for i in angle_params:
            angle_line_to_replace = i
            # print(angle_line_to_replace)
            atom_number_list = [
                re.findall(&#34;\d*\.?\d+&#34;, i)[3],
                re.findall(&#34;\d*\.?\d+&#34;, i)[5],
                re.findall(&#34;\d*\.?\d+&#34;, i)[7],
            ]
            # print(atom_number_list)
            comb_1 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_2 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_3 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_4 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_5 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_6 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_list_angle = [comb_1, comb_2, comb_3, comb_4, comb_5, comb_6]
            # print(comb_list_angle)
            list_search_angle = [
                search_in_file(file=self.system_xml, word=comb_1),
                search_in_file(file=self.system_xml, word=comb_2),
                search_in_file(file=self.system_xml, word=comb_3),
                search_in_file(file=self.system_xml, word=comb_4),
                search_in_file(file=self.system_xml, word=comb_5),
                search_in_file(file=self.system_xml, word=comb_6),
            ]
            # print(list_search_angle)
            for j in range(len(list_search_angle)):
                if list_search_angle[j] != []:
                    to_add = (list_search_angle[j], i)
                    # print(to_add)
                    index_search_replace_angle.append(to_add)
        f_org = open(self.system_xml)
        lines = f_org.readlines()
        for i in range(len(index_search_replace_bond)):
            line_number = index_search_replace_bond[i][0][0][0] - 1
            line_to_replace = index_search_replace_bond[i][0][0][1]
            line_to_replace_with = index_search_replace_bond[i][1]
            lines[line_number] = line_to_replace_with
        for i in range(len(index_search_replace_angle)):
            line_number = index_search_replace_angle[i][0][0][0] - 1
            line_to_replace = index_search_replace_angle[i][0][0][1]
            line_to_replace_with = index_search_replace_angle[i][1]
            lines[line_number] = line_to_replace_with
        f_cop = open(self.reparameterised_intermediate_system_xml_file, &#34;w&#34;)
        for i in lines:
            f_cop.write(i)
        f_cop.close()

        f_params = open(self.system_qm_params_file)
        lines_params = f_params.readlines()
        # Charge Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Charge Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Charge Parameters&#34; in lines_params[i]:
                to_end = int(i)
        charge_params = lines_params[to_begin + 1 : to_end]
        non_bonded_index = []
        for k in charge_params:
            non_bonded_index.append(int(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, k)[3]))
        charge_for_index = []
        for k in charge_params:
            charge_for_index.append(
                float(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, k)[0])
            )

        xml_off = open(self.system_xml)
        xml_off_lines = xml_off.readlines()
        for i in range(len(xml_off_lines)):
            if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
                to_begin = int(i)
            if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
                to_end = int(i)
        nonbond_params = xml_off_lines[to_begin + 4 : to_end - 1]
        # print(len(nonbond_params))
        f_non_bonded = open(self.system_xml_non_bonded_file, &#34;w&#34;)
        for x in nonbond_params:
            f_non_bonded.write(x)

        f_non_bonded = open(self.system_xml_non_bonded_file)
        lines_non_bonded = f_non_bonded.readlines()
        # print(len(lines_non_bonded))
        lines_non_bonded_to_write = []
        for i in range(len(non_bonded_index)):
            line_ = lines_non_bonded[non_bonded_index[i]]
            # print(line_)
            eps = float(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, line_)[0])
            sig = float(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, line_)[2])
            line_to_replace = (
                &#34;                                &#34;
                + &#34;&lt;Particle &#34;
                + &#34;eps=&#34;
                + &#39;&#34;&#39;
                + str(eps)
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;q=&#34;
                + &#39;&#34;&#39;
                + str(charge_for_index[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;sig=&#34;
                + &#39;&#34;&#39;
                + str(sig)
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            lines_non_bonded_to_write.append(line_to_replace)
        data_ = list(zip(non_bonded_index, lines_non_bonded_to_write))

        df_non_bonded_params = pd.DataFrame(
            data_, columns=[&#34;line_index&#34;, &#34;line&#34;]
        )
        # print(df_non_bonded_params.head())
        f_non_bonded_ = open(self.system_xml_non_bonded_file)
        lines_non_bonded_ = f_non_bonded_.readlines()
        for i in range(len(lines_non_bonded_)):
            if i in non_bonded_index:
                lines_non_bonded_[i] = (
                    df_non_bonded_params.loc[
                        df_non_bonded_params.line_index == i, &#34;line&#34;
                    ].values[0]
                ) + &#34;\n&#34;
        # print(len(lines_non_bonded_))
        f_write_non_bonded_reparams = open(
            self.system_xml_non_bonded_reparams_file, &#34;w&#34;
        )
        for p in range(len(lines_non_bonded_)):
            f_write_non_bonded_reparams.write(lines_non_bonded_[p])
        f_write_non_bonded_reparams.close()
        f_ = open(self.system_xml_non_bonded_reparams_file)
        lines_ = f_.readlines()
        print(len(lines_) == len(lines_non_bonded))

        xml_off = open(self.reparameterised_intermediate_system_xml_file)
        xml_off_lines = xml_off.readlines()
        for i in range(len(xml_off_lines)):
            if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
                to_begin = int(i)
            if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
                to_end = int(i)

        lines_before_params = xml_off_lines[: to_begin + 4]
        f__ = open(self.system_xml_non_bonded_reparams_file)
        lines_params_non_bonded = f__.readlines()
        lines_after_params = xml_off_lines[to_end - 1 :]
        f_reparams_xml = open(self.reparameterised_system_xml_file, &#34;w&#34;)
        for x in lines_before_params:
            f_reparams_xml.write(x)
        for x in lines_params_non_bonded:
            f_reparams_xml.write(x)
        for x in lines_after_params:
            f_reparams_xml.write(x)
        f_reparams_xml.close()

    def save_amber_params(self):
        &#34;&#34;&#34;
        Saves amber generated topology files for the ligand.
        &#34;&#34;&#34;
        if self.load_topology == &#34;parmed&#34;:
            openmm_system = parmed.openmm.load_topology(
                parmed.load_file(self.system_pdb, structure=True).topology,
                parmed.load_file(self.non_reparameterised_system_xml_file),
            )
        if self.load_topology == &#34;openmm&#34;:
            openmm_system = parmed.openmm.load_topology(
                simtk.openmm.app.PDBFile(self.system_pdb).topology,
                parmed.load_file(self.non_reparameterised_system_xml_file),
            )
        openmm_system.save(self.prmtop_system_non_params, overwrite=True)
        openmm_system.coordinates = parmed.load_file(
            self.system_pdb, structure=True
        ).coordinates
        openmm_system.save(self.inpcrd_system_non_params, overwrite=True)
        parm = parmed.load_file(
            self.prmtop_system_non_params, self.inpcrd_system_non_params
        )

        xml_energy_decomposition = parmed.openmm.energy_decomposition_system(
            openmm_system,
            parmed.load_file(self.non_reparameterised_system_xml_file),
        )
        xml_energy_decomposition_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        xml_energy_decomposition_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_xml = pd.DataFrame(
            list(
                zip(
                    xml_energy_decomposition_list,
                    xml_energy_decomposition_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_xml_non_params&#34;],
        )
        df_energy_xml = df_energy_xml.set_index(&#34;Energy_term&#34;)

        prmtop_energy_decomposition = (
            parmed.openmm.energy_decomposition_system(
                parm, parm.createSystem()
            )
        )
        prmtop_energy_decomposition_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        prmtop_energy_decomposition_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_prmtop = pd.DataFrame(
            list(
                zip(
                    prmtop_energy_decomposition_list,
                    prmtop_energy_decomposition_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_prmtop_non_params&#34;],
        )
        df_energy_prmtop = df_energy_prmtop.set_index(&#34;Energy_term&#34;)

        df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
        print(df_compare)

        if self.load_topology == &#34;parmed&#34;:
            openmm_system = parmed.openmm.load_topology(
                parmed.load_file(self.system_pdb, structure=True).topology,
                parmed.load_file(self.reparameterised_system_xml_file),
            )
        if self.load_topology == &#34;openmm&#34;:
            openmm_system = parmed.openmm.load_topology(
                simtk.openmm.app.PDBFile(self.system_pdb).topology,
                parmed.load_file(self.reparameterised_system_xml_file),
            )
        openmm_system.save(self.prmtop_system_params, overwrite=True)
        openmm_system.coordinates = parmed.load_file(
            self.system_pdb, structure=True
        ).coordinates
        openmm_system.save(self.inpcrd_system_params, overwrite=True)
        parm = parmed.load_file(
            self.prmtop_system_params, self.inpcrd_system_params
        )

        xml_energy_decomposition = parmed.openmm.energy_decomposition_system(
            openmm_system,
            parmed.load_file(self.reparameterised_system_xml_file),
        )
        xml_energy_decomposition_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        xml_energy_decomposition_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_xml = pd.DataFrame(
            list(
                zip(
                    xml_energy_decomposition_list,
                    xml_energy_decomposition_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_xml_params&#34;],
        )
        df_energy_xml = df_energy_xml.set_index(&#34;Energy_term&#34;)

        prmtop_energy_decomposition = (
            parmed.openmm.energy_decomposition_system(
                parm, parm.createSystem()
            )
        )
        prmtop_energy_decomposition_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        prmtop_energy_decomposition_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_prmtop = pd.DataFrame(
            list(
                zip(
                    prmtop_energy_decomposition_list,
                    prmtop_energy_decomposition_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_prmtop_params&#34;],
        )
        df_energy_prmtop = df_energy_prmtop.set_index(&#34;Energy_term&#34;)

        df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
        print(df_compare)

    def analyze_diff_energies(self):
        &#34;&#34;&#34;
        Compares the energies of the ligand obtained from the non-parameterized 
        and the parameterized force field files. 
        &#34;&#34;&#34;
        parm_non_params = parmed.load_file(
            self.prmtop_system_non_params, self.inpcrd_system_non_params
        )
        prmtop_energy_decomposition_non_params = (
            parmed.openmm.energy_decomposition_system(
                parm_non_params, parm_non_params.createSystem()
            )
        )
        prmtop_energy_decomposition_non_params_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_non_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_non_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_non_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_non_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        prmtop_energy_decomposition_non_params_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_non_params = pd.DataFrame(
            list(
                zip(
                    prmtop_energy_decomposition_non_params_list,
                    prmtop_energy_decomposition_non_params_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_parm_non_params&#34;],
        )
        df_energy_non_params = df_energy_non_params.set_index(&#34;Energy_term&#34;)
        # print(df_energy_non_params)
        parm_params = parmed.load_file(
            self.prmtop_system_params, self.inpcrd_system_params
        )
        prmtop_energy_decomposition_params = (
            parmed.openmm.energy_decomposition_system(
                parm_params, parm_params.createSystem()
            )
        )
        prmtop_energy_decomposition_params_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        prmtop_energy_decomposition_params_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_params = pd.DataFrame(
            list(
                zip(
                    prmtop_energy_decomposition_params_list,
                    prmtop_energy_decomposition_params_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_parm_params&#34;],
        )
        df_energy_params = df_energy_params.set_index(&#34;Energy_term&#34;)
        # print(df_energy_params)
        df_compare = pd.concat(
            [df_energy_non_params, df_energy_params], axis=1
        )
        df_compare[&#34;Energy_difference&#34;] = df_compare[
            &#34;Energy_parm_non_params&#34;
        ].sub(df_compare[&#34;Energy_parm_params&#34;], axis=0)
        print(df_compare)


class RunOpenMMSims:
    &#34;&#34;&#34;
    A class used to run the OpenMM simulation on any specified system.

    This class contains methods to run a MD simulation to confirm the 
    proper structure of the reparameterized forcefield files. 


    ...

    Attributes
    ----------
    system_prmtop : str
        Topology file of the system (receptor, ligand or 
        receptor - ligand complex)

    system_inpcrd : str
        Coordinate file of the system (receptor, ligand or 
        receptor - ligand complex)

    system_pdb: str
        PDB file of the system to run MD simulation (receptor, 
        ligand or receptor - ligand complex).

    sim_output: str, optional
        PDB file containing the trajectory coordinates for the OpenMM
        simulation. 

    sim_steps: str, optional
        Number of steps in the OpenMM MD simulation.

    &#34;&#34;&#34;

    def __init__(
        self,
        system_prmtop,
        system_inpcrd,
        system_pdb,
        system_output=&#34;sim_output.pdb&#34;,
        sim_steps=1000,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        system_prmtop : str
            Topology file of the system (receptor, ligand or 
            receptor - ligand complex)

        system_inpcrd : str
            Coordinate file of the system (receptor, ligand or 
            receptor - ligand complex)

        system_pdb: str
            PDB file of the system to run MD simulation (receptor, 
            ligand or receptor - ligand complex).

        sim_output: str, optional
            PDB file containing the trajectory coordinates for the OpenMM
            simulation. 

        sim_steps: str, optional
            Number of steps in the OpenMM MD simulation.
        &#34;&#34;&#34;
        self.system_prmtop = system_prmtop
        self.system_inpcrd = system_inpcrd
        self.system_pdb = system_pdb
        self.system_output = system_output
        self.sim_steps = sim_steps

    def run_openmm_prmtop_inpcrd(self):
        &#34;&#34;&#34;
        Run a OpenMM MD simulation with prmtop and inpcrd file&#34;
        &#34;&#34;&#34;
        print(
            &#34;Running OpenMM simulation for &#34;
            + self.system_prmtop
            + &#34; and &#34;
            + self.system_inpcrd
        )
        prmtop = simtk.openmm.app.AmberPrmtopFile(self.system_prmtop)
        inpcrd = simtk.openmm.app.AmberInpcrdFile(self.system_inpcrd)
        system = prmtop.createSystem()
        integrator = simtk.openmm.LangevinIntegrator(
            300 * simtk.unit.kelvin,
            1 / simtk.unit.picosecond,
            0.002 * simtk.unit.picoseconds,
        )
        simulation = simtk.openmm.app.Simulation(
            prmtop.topology, system, integrator
        )
        simulation.context.setPositions(inpcrd.positions)
        if inpcrd.boxVectors is not None:
            simulation.context.setPeriodicBoxVectors(*inpcrd.boxVectors)
        simulation.minimizeEnergy()
        simulation.reporters.append(
            simtk.openmm.app.PDBReporter(
                self.system_output, self.sim_steps / 10
            )
        )
        simulation.reporters.append(
            simtk.openmm.app.StateDataReporter(
                stdout,
                reportInterval=int(self.sim_steps / 10),
                step=True,
                potentialEnergy=True,
                temperature=True,
            )
        )
        simulation.step(self.sim_steps)
        command = &#34;rm -rf &#34; + self.system_output
        os.system(command)

    def run_openmm_prmtop_pdb(self):
        &#34;&#34;&#34;
        Run a OpenMM MD simulation with prmtop and PDB file&#34;
        &#34;&#34;&#34;
        print(
            &#34;Running OpenMM simulation for &#34;
            + self.system_prmtop
            + &#34; and &#34;
            + self.system_pdb
        )
        pdb = simtk.openmm.app.PDBFile(self.system_pdb)
        prmtop = simtk.openmm.app.AmberPrmtopFile(self.system_prmtop)
        system = prmtop.createSystem()
        integrator = simtk.openmm.LangevinIntegrator(
            300 * simtk.unit.kelvin,
            1 / simtk.unit.picosecond,
            0.002 * simtk.unit.picoseconds,
        )
        simulation = simtk.openmm.app.Simulation(
            prmtop.topology, system, integrator
        )
        simulation.context.setPositions(pdb.positions)
        simulation.minimizeEnergy()
        simulation.reporters.append(
            simtk.openmm.app.PDBReporter(
                self.system_output, self.sim_steps / 10
            )
        )
        simulation.reporters.append(
            simtk.openmm.app.StateDataReporter(
                stdout,
                reportInterval=int(self.sim_steps / 10),
                step=True,
                potentialEnergy=True,
                temperature=True,
            )
        )
        simulation.step(self.sim_steps)
        command = &#34;rm -rf &#34; + self.system_output
        os.system(command)


class MergeHostGuestTopology:
    &#34;&#34;&#34;
    This class is used to merge the host and guest topology and coordinate
    files.

    ...

    Attributes
    ----------
    host_prmtop : str
        Topology file of the receptor.

    guest_prmtop : str
        Topology file of the ligand.

    host_inpcrd : str
        Coordinate file of the receptor. 

    guest_inpcrd : str
        Coordinate file of the ligand. 

    system_prmtop : str
        Topology file of the receptor - ligand complex. 

    system_inpcrd : str
        Coordinate file of the receptor - ligand complex. 

    &#34;&#34;&#34;
    def __init__(
        self,
        host_prmtop,
        guest_prmtop,
        host_inpcrd,
        guest_inpcrd,
        system_prmtop,
        system_inpcrd,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        host_prmtop : str
            Topology file of the receptor.

        guest_prmtop : str
            Topology file of the ligand.

        host_inpcrd : str
            Coordinate file of the receptor. 

        guest_inpcrd : str
            Coordinate file of the ligand. 

        system_prmtop : str
            Topology file of the receptor - ligand complex. 

        system_inpcrd : str
            Coordinate file of the receptor - ligand complex. 

        &#34;&#34;&#34;
        self.host_prmtop = host_prmtop
        self.guest_prmtop = guest_prmtop
        self.host_inpcrd = host_inpcrd
        self.guest_inpcrd = guest_inpcrd
        self.system_prmtop = system_prmtop
        self.system_inpcrd = system_inpcrd

    def merge_topology_files(self):
        &#34;&#34;&#34;
        Merge the host and guest topology and coordinate files.
        &#34;&#34;&#34;
        print(
            &#34;Merging the &#34;
            + self.host_prmtop
            + &#34; &#34;
            + self.guest_prmtop
            + &#34; files&#34;
        )
        print(
            &#34;Merging the &#34;
            + self.host_inpcrd
            + &#34; &#34;
            + self.guest_inpcrd
            + &#34; files&#34;
        )
        host_system = parmed.load_file(self.host_prmtop, xyz=self.host_inpcrd)
        guest_system = parmed.load_file(
            self.guest_prmtop, xyz=self.guest_inpcrd
        )
        system = host_system + guest_system
        system.save(self.system_prmtop, overwrite=True)
        system.save(self.system_inpcrd, overwrite=True)


class TorsionDriveSims:
    &#34;&#34;&#34;
    This class is used to create a filetree for torsion scan 
    using torsionsdrive for the dihedral angles of the ligand.

    This class creates a directory for carrying out torsiondrive 
    calculations followed by fitting of torsional parameters. Methods 
    in this class are used to run torsiondrive calculations either for
    all of the torsional angles, or for non-hydrogen / heavy atoms 
    contributing to the torsional angle.
    
    ...

    Attributes
    ----------
    charge : int
        Charge of the ligand. 

    multiplicity: int
        Spin Multiplicity (2S+1) of the ligand where S represents 
        the total spin of the ligand. 

    reparameterised_system_xml_file : str, optional
        Reparamaterixed XML force field for the ligand.

    torsion_xml_file : str, optional
        A text file containing torsional parameters from
        reparametrised XML file.

    xyz_file : str, optional
        XYZ file containing the coordinates of the guest molecule.

    psi_input_file : str, optional
        Input file for psi4 QM engine. 

    memory : int, optional
        Memory (in GB) to be used.

    basis_set: str, optional
        Basis set to use for the QM engine.

    functional: str, optional
        Exchange/Correlation or hybrid Functional for the QM engine. 

    iterations : int, optional
        Maximum number of geometry optimization steps.

    method_torsion_drive : str, optional
        The algorithm/package to use while running the torsiondrive
        scan. Using --native_opt uses QM program native constrained
        optimization algorithm and turns off geomeTRIC package.

    system_bonds_file : str, optional
        Text file containing bond parameters for the ligand.

    tor_dir : str, optional
        Torsiondrive directory containing separate torsiondrive
        folders, each containing files for a separate torsiondrive 
        calculation for a particular dihedral angle. 

    dihedral_text_file : str, optional
       Dihedral information file for torsiondrive.

    template_pdb : str, optional
        Guest PDB with atoms beginning from 1 to be used as a
        template PDB to retrieve atom indices and symbols.

    torsion_drive_run_file : str, optional
        bash file for torsiondrive calculations. 

    dihedral_interval : int, optional
        Grid spacing for dihedral scan, i.e. every n degrees 
        (where n is an integer), multiple values will be mapped 
        to each dihedral angle.

    engine : str, optional
        Engine for running torsiondrive scan. 

    energy_threshold : float, optional
        Only activate grid points if the new optimization is lower than
        the previous lowest energy (in a.u.).

    &#34;&#34;&#34;
    def __init__(
        self,
        charge,
        multiplicity,
        reparameterised_system_xml_file=&#34;guest_reparameterised.xml&#34;,
        torsion_xml_file=&#34;guest_torsion_xml.txt&#34;,
        xyz_file=&#34;guest_coords.xyz&#34;,
        psi_input_file=&#34;torsion_drive_input.dat&#34;,
        memory=50,
        basis_set=&#34;STO-3G&#34;,
        functional=&#34;BLYP&#34;,
        iterations=2000,
        method_torsion_drive=&#34;native_opt&#34;,
        system_bonds_file=&#34;guest_bonds.txt&#34;,
        tor_dir=&#34;torsion_dir&#34;,
        dihedral_text_file=&#34;dihedrals.txt&#34;,
        template_pdb=&#34;guest_init_II.pdb&#34;,
        torsion_drive_run_file=&#34;run_command&#34;,
        dihedral_interval=15,
        engine=&#34;psi4&#34;,
        energy_threshold=0.001,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------

        charge : int
            Charge of the ligand. 

        multiplicity: int
            Spin Multiplicity (2S+1) of the ligand where S represents 
            the total spin of the ligand. 

        reparameterised_system_xml_file : str, optional
            Reparamaterixed XML force field for the ligand.

        torsion_xml_file : str, optional
            A text file containing torsional parameters from
            reparametrised XML file.

        xyz_file : str, optional
            XYZ file containing the coordinates of the guest molecule.

        psi_input_file : str, optional
            Input file for psi4 QM engine. 

        memory : int, optional
            Memory (in GB) to be used.

        basis_set: str, optional
            Basis set to use for the QM engine.

        functional: str, optional
            Exchange/Correlation or hybrid Functional for the QM engine. 

        iterations : int, optional
            Maximum number of geometry optimization steps.

        method_torsion_drive : str, optional
            The algorithm/package to use while running the torsiondrive
            scan. Using --native_opt uses QM program native constrained
            optimization algorithm and turns off geomeTRIC package.

        system_bonds_file : str, optional
            Text file containing bond parameters for the ligand.

        tor_dir : str, optional
            Torsiondrive directory containing separate torsiondrive
            folders, each containing files for a separate torsiondrive 
            calculation for a particular dihedral angle. 

        dihedral_text_file : str, optional
           Dihedral information file for torsiondrive.

        template_pdb : str, optional
            Guest PDB with atoms beginning from 1 to be used as a
            template PDB to retrieve atom indices and symbols.

        torsion_drive_run_file : str, optional
            bash file for torsiondrive calculations. 

        dihedral_interval : int, optional
            Grid spacing for dihedral scan, i.e. every n degrees 
            (where n is an integer), multiple values will be mapped 
            to each dihedral angle.

        engine : str, optional
            Engine for running torsiondrive scan. 

        energy_threshold : float, optional
            Only activate grid points if the new optimization is lower than
            the previous lowest energy (in a.u.).
        &#34;&#34;&#34;
        self.charge = charge
        self.multiplicity = multiplicity
        self.reparameterised_system_xml_file = reparameterised_system_xml_file
        self.torsion_xml_file = torsion_xml_file
        self.xyz_file = xyz_file
        self.psi_input_file = psi_input_file
        self.memory = memory
        self.basis_set = basis_set
        self.functional = functional
        self.iterations = iterations
        self.method_torsion_drive = method_torsion_drive
        self.system_bonds_file = system_bonds_file
        self.tor_dir = tor_dir
        self.dihedral_text_file = dihedral_text_file
        self.template_pdb = template_pdb
        self.torsion_drive_run_file = torsion_drive_run_file
        self.dihedral_interval = dihedral_interval
        self.engine = engine
        self.energy_threshold = energy_threshold

    def write_torsion_drive_run_file(self):
        &#34;&#34;&#34;
        Saves a bash file for running torsion scans for torsiondrive. 
        &#34;&#34;&#34;
        if self.method_torsion_drive == &#34;geometric&#34;:
            torsion_command = (
                &#34;torsiondrive-launch&#34;
                + &#34; &#34;
                + self.psi_input_file
                + &#34; &#34;
                + self.dihedral_text_file
                + &#34; &#34;
                + &#34;-g&#34;
                + &#34; &#34;
                + str(self.dihedral_interval)
                + &#34; &#34;
                + &#34;-e&#34;
                + &#34; &#34;
                + self.engine
                + &#34; &#34;
                + &#34;--energy_thresh&#34;
                + &#34; &#34;
                + str(self.energy_threshold)
                + &#34; &#34;
                + &#34;-v&#34;
            )
        if self.method_torsion_drive == &#34;native_opt&#34;:
            torsion_command = (
                &#34;torsiondrive-launch&#34;
                + &#34; &#34;
                + self.psi_input_file
                + &#34; &#34;
                + self.dihedral_text_file
                + &#34; &#34;
                + &#34;-g&#34;
                + &#34; &#34;
                + str(self.dihedral_interval)
                + &#34; &#34;
                + &#34;-e&#34;
                + &#34; &#34;
                + self.engine
                + &#34; &#34;
                + &#34;--energy_thresh&#34;
                + &#34; &#34;
                + str(self.energy_threshold)
                + &#34; &#34;
                + &#34;--&#34;
                + self.method_torsion_drive
                + &#34; &#34;
                + &#34;-v&#34;
            )
        print(torsion_command)
        with open(self.torsion_drive_run_file, &#34;w&#34;) as f:
            f.write(torsion_command)

    def write_tor_params_txt(self):
        &#34;&#34;&#34;
        Saves a text file containing torsional parameters from the reparameterized XML 
        force field file.
        &#34;&#34;&#34;
        xml_off = open(self.reparameterised_system_xml_file, &#34;r&#34;)
        xml_off_lines = xml_off.readlines()
        for i in range(len(xml_off_lines)):
            if &#34;&lt;Torsions&gt;&#34; in xml_off_lines[i]:
                to_begin = int(i)
            if &#34;&lt;/Torsions&gt;&#34; in xml_off_lines[i]:
                to_end = int(i)
        torsion_params = xml_off_lines[to_begin + 1 : to_end]

        k_list_off = []
        for i in range(len(torsion_params)):
            k_list_off.append(
                float(re.findall(&#34;\d*\.?\d+&#34;, torsion_params[i])[0])
            )
        k_list_off = [round(num, 10) for num in k_list_off]
        # print(k_list_off)
        p1 = []
        for i in range(len(torsion_params)):
            p1.append(int(re.findall(&#34;\d*\.?\d+&#34;, torsion_params[i])[2]))
        p1 = [i + 1 for i in p1]
        # print(p1)
        p2 = []
        for i in range(len(torsion_params)):
            p2.append(int(re.findall(&#34;\d*\.?\d+&#34;, torsion_params[i])[4]))
        p2 = [i + 1 for i in p2]
        # print(p2)
        p3 = []
        for i in range(len(torsion_params)):
            p3.append(int(re.findall(&#34;\d*\.?\d+&#34;, torsion_params[i])[6]))
        p3 = [i + 1 for i in p3]
        # print(p3)
        p4 = []
        for i in range(len(torsion_params)):
            p4.append(int(re.findall(&#34;\d*\.?\d+&#34;, torsion_params[i])[8]))
        p4 = [i + 1 for i in p4]
        # print(p4)
        periodicity = []
        for i in range(len(torsion_params)):
            periodicity.append(
                int(re.findall(&#34;\d*\.?\d+&#34;, torsion_params[i])[9])
            )
        # print(periodicity)
        phase = []
        for i in range(len(torsion_params)):
            phase.append(float(re.findall(&#34;\d*\.?\d+&#34;, torsion_params[i])[10]))
        phase = [round(num, 8) for num in phase]
        # print(phase)
        data_tuples = list(zip(k_list_off, p1, p2, p3, p4, periodicity, phase))
        df_tor = pd.DataFrame(
            data_tuples,
            columns=[&#34;k&#34;, &#34;p1&#34;, &#34;p2&#34;, &#34;p3&#34;, &#34;p4&#34;, &#34;periodicity&#34;, &#34;phase&#34;],
        )
        # print(df_tor.head())
        df_tor.to_csv(
            self.torsion_xml_file, index=False, header=False, sep=&#34; &#34;
        )

    def write_psi4_input(self):
        &#34;&#34;&#34; 
        Writes a psi4 input QM file.
        &#34;&#34;&#34;
        xyz_lines = open(self.xyz_file, &#34;r&#34;).readlines()[2:]
        with open(self.psi_input_file, &#34;w&#34;) as f:
            f.write(&#34;memory&#34; + &#34; &#34; + str(self.memory) + &#34; &#34; + &#34;GB&#34; + &#34;\n&#34;)
            f.write(&#34;molecule&#34; + &#34; &#34; + &#34;{&#34; + &#34;\n&#34;)
            f.write(str(self.charge) + &#34; &#34; + str(self.multiplicity) + &#34;\n&#34;)
            for line in xyz_lines:
                f.write(line)
            f.write(&#34;}&#34; + &#34;\n&#34;)
            f.write(&#34;set&#34; + &#34; &#34; + &#34;{&#34; + &#34;\n&#34;)
            f.write(&#34;basis&#34; + &#34; &#34; + self.basis_set + &#34;\n&#34;)
            if self.method_torsion_drive == &#34;native_opt&#34;:
                f.write(&#34;GEOM_MAXITER&#34; + &#34; &#34; + str(self.iterations) + &#34;\n&#34;)
            f.write(&#34;}&#34; + &#34;\n&#34;)
            if self.method_torsion_drive == &#34;native_opt&#34;:
                f.write(
                    &#34;optimize&#34; + &#34;(&#34; + &#34;&#39;&#34; + self.functional + &#34;&#39;&#34; &#34;)&#34; + &#34;\n&#34;
                )
            if self.method_torsion_drive == &#34;geometric&#34;:
                f.write(
                    &#34;gradient&#34; + &#34;(&#34; + &#34;&#39;&#34; + self.functional + &#34;&#39;&#34; &#34;)&#34; + &#34;\n&#34;
                )

    def create_torsion_drive_dir(self):
        &#34;&#34;&#34;
        Creates a directory for carrying out torsiondrive 
        calculations for all the proper dihedral angles. 
        &#34;&#34;&#34;
        df_tor = pd.read_csv(
            self.torsion_xml_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df_tor.columns = [&#34;k&#34;, &#34;p1&#34;, &#34;p2&#34;, &#34;p3&#34;, &#34;p4&#34;, &#34;periodicity&#34;, &#34;phase&#34;]
        # print(df_tor.head())
        df_dihedrals = df_tor[[&#34;p1&#34;, &#34;p2&#34;, &#34;p3&#34;, &#34;p4&#34;]]
        # print(df_dihedrals.head())
        dihedrals_list_list = []
        for i in range(len(df_dihedrals)):
            dihedrals_list_list.append(df_dihedrals.iloc[i].values.tolist())
        set_list = set()
        unique_dihedrals_list_list = []
        for x in dihedrals_list_list:
            srtd = tuple(sorted(x))
            if srtd not in set_list:
                unique_dihedrals_list_list.append(x)
                set_list.add(srtd)
        # print(unique_dihedrals_list_list)
        os.system(&#34;rm -rf &#34; + self.tor_dir)
        os.system(&#34;mkdir &#34; + self.tor_dir)
        parent_cwd = os.getcwd()
        shutil.copy(
            parent_cwd + &#34;/&#34; + self.psi_input_file,
            parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.psi_input_file,
        )
        shutil.copy(
            parent_cwd + &#34;/&#34; + self.template_pdb,
            parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.template_pdb,
        )
        shutil.copy(
            parent_cwd + &#34;/&#34; + self.torsion_drive_run_file,
            parent_cwd
            + &#34;/&#34;
            + self.tor_dir
            + &#34;/&#34;
            + self.torsion_drive_run_file,
        )
        os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir)
        torsion_drive_dir = os.getcwd()
        for i in range(len(unique_dihedrals_list_list)):
            dir_name = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
            os.system(&#34;rm -rf &#34; + dir_name)
            os.system(&#34;mkdir &#34; + dir_name)
            os.chdir(torsion_drive_dir + &#34;/&#34; + dir_name)
            with open(self.dihedral_text_file, &#34;w&#34;) as f:
                f.write(
                    &#34;# dihedral definition by atom indices starting from 1&#34;
                    + &#34;\n&#34;
                )
                f.write(&#34;# i     j     k     l&#34; + &#34;\n&#34;)
                i_ = unique_dihedrals_list_list[i][0]
                j_ = unique_dihedrals_list_list[i][1]
                k_ = unique_dihedrals_list_list[i][2]
                l_ = unique_dihedrals_list_list[i][3]
                f.write(
                    &#34; &#34;
                    + &#34;{:&lt; 6d}&#34;.format(i_)
                    + &#34;{:&lt; 6d}&#34;.format(j_)
                    + &#34;{:&lt; 6d}&#34;.format(k_)
                    + &#34;{:&lt; 6d}&#34;.format(l_)
                    + &#34;\n&#34;
                )
                shutil.copy(
                    torsion_drive_dir + &#34;/&#34; + self.psi_input_file,
                    torsion_drive_dir
                    + &#34;/&#34;
                    + dir_name
                    + &#34;/&#34;
                    + self.psi_input_file,
                )
                shutil.copy(
                    torsion_drive_dir + &#34;/&#34; + self.template_pdb,
                    torsion_drive_dir
                    + &#34;/&#34;
                    + dir_name
                    + &#34;/&#34;
                    + self.template_pdb,
                )
                shutil.copy(
                    torsion_drive_dir + &#34;/&#34; + self.torsion_drive_run_file,
                    torsion_drive_dir
                    + &#34;/&#34;
                    + dir_name
                    + &#34;/&#34;
                    + self.torsion_drive_run_file,
                )
                os.chdir(torsion_drive_dir)
        os.system(&#34;rm -rf &#34; + self.psi_input_file)
        os.system(&#34;rm -rf &#34; + self.template_pdb)
        os.system(&#34;rm -rf &#34; + self.torsion_drive_run_file)
        os.chdir(parent_cwd)

    def create_non_H_torsion_drive_dir(self):
        &#34;&#34;&#34;
        Creates a directory for carrying out torsiondrive 
        calculations for all non-hydrogen torsional angles. 
        &#34;&#34;&#34;
        df_tor = pd.read_csv(
            self.torsion_xml_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df_tor.columns = [&#34;k&#34;, &#34;p1&#34;, &#34;p2&#34;, &#34;p3&#34;, &#34;p4&#34;, &#34;periodicity&#34;, &#34;phase&#34;]
        # print(df_tor.head())
        ppdb = PandasPdb()
        ppdb.read_pdb(self.template_pdb)
        df_index_symbol = ppdb.df[&#34;ATOM&#34;][[&#34;atom_number&#34;, &#34;element_symbol&#34;]]
        # print(df_index_symbol.head())
        df_dihedrals = df_tor[[&#34;p1&#34;, &#34;p2&#34;, &#34;p3&#34;, &#34;p4&#34;]]
        # print(df_dihedrals.head())
        dihedrals_list_list = []
        for i in range(len(df_dihedrals)):
            dihedrals_list_list.append(df_dihedrals.iloc[i].values.tolist())
        set_list = set()
        unique_dihedrals_list_list = []
        for x in dihedrals_list_list:
            srtd = tuple(sorted(x))
            if srtd not in set_list:
                unique_dihedrals_list_list.append(x)
                set_list.add(srtd)
        # print(unique_dihedrals_list_list)
        atom_dihedral_list = []
        for sub_list in unique_dihedrals_list_list:
            atom_dihedral_list.append(
                [
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[0]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[1]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[2]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[3]
                    ][&#34;element_symbol&#34;].to_list()[0],
                ]
            )
        # print(atom_dihedral_list)
        index_to_include = []
        for i in range(len(atom_dihedral_list)):
            if &#34;H&#34; not in atom_dihedral_list[i]:
                index_to_include.append(i)
        non_H_dihedrals = []
        for i in index_to_include:
            non_H_dihedrals.append(unique_dihedrals_list_list[i])
        # print(non_H_dihedrals)
        non_H_atom_dihedral_list = []
        for sub_list in non_H_dihedrals:
            non_H_atom_dihedral_list.append(
                [
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[0]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[1]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[2]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[3]
                    ][&#34;element_symbol&#34;].to_list()[0],
                ]
            )
        print(non_H_atom_dihedral_list)
        os.system(&#34;rm -rf &#34; + self.tor_dir)
        os.system(&#34;mkdir &#34; + self.tor_dir)
        parent_cwd = os.getcwd()
        shutil.copy(
            parent_cwd + &#34;/&#34; + self.psi_input_file,
            parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.psi_input_file,
        )
        shutil.copy(
            parent_cwd + &#34;/&#34; + self.template_pdb,
            parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.template_pdb,
        )
        shutil.copy(
            parent_cwd + &#34;/&#34; + self.torsion_drive_run_file,
            parent_cwd
            + &#34;/&#34;
            + self.tor_dir
            + &#34;/&#34;
            + self.torsion_drive_run_file,
        )
        os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir)
        torsion_drive_dir = os.getcwd()
        for i in range(len(non_H_dihedrals)):
            dir_name = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
            os.system(&#34;rm -rf &#34; + dir_name)
            os.system(&#34;mkdir &#34; + dir_name)
            os.chdir(torsion_drive_dir + &#34;/&#34; + dir_name)
            with open(self.dihedral_text_file, &#34;w&#34;) as f:
                f.write(
                    &#34;# dihedral definition by atom indices starting from 1&#34;
                    + &#34;\n&#34;
                )
                f.write(&#34;# i     j     k     l&#34; + &#34;\n&#34;)
                i_ = non_H_dihedrals[i][0]
                j_ = non_H_dihedrals[i][1]
                k_ = non_H_dihedrals[i][2]
                l_ = non_H_dihedrals[i][3]
                f.write(
                    &#34; &#34;
                    + &#34;{:&lt; 6d}&#34;.format(i_)
                    + &#34;{:&lt; 6d}&#34;.format(j_)
                    + &#34;{:&lt; 6d}&#34;.format(k_)
                    + &#34;{:&lt; 6d}&#34;.format(l_)
                    + &#34;\n&#34;
                )
                shutil.copy(
                    torsion_drive_dir + &#34;/&#34; + self.psi_input_file,
                    torsion_drive_dir
                    + &#34;/&#34;
                    + dir_name
                    + &#34;/&#34;
                    + self.psi_input_file,
                )
                shutil.copy(
                    torsion_drive_dir + &#34;/&#34; + self.template_pdb,
                    torsion_drive_dir
                    + &#34;/&#34;
                    + dir_name
                    + &#34;/&#34;
                    + self.template_pdb,
                )
                shutil.copy(
                    torsion_drive_dir + &#34;/&#34; + self.torsion_drive_run_file,
                    torsion_drive_dir
                    + &#34;/&#34;
                    + dir_name
                    + &#34;/&#34;
                    + self.torsion_drive_run_file,
                )
                os.chdir(torsion_drive_dir)
        os.system(&#34;rm -rf &#34; + self.psi_input_file)
        os.system(&#34;rm -rf &#34; + self.template_pdb)
        os.system(&#34;rm -rf &#34; + self.torsion_drive_run_file)
        os.chdir(parent_cwd)

    def create_non_H_bonded_torsion_drive_dir(self):
        &#34;&#34;&#34;
        Creates a directory for carrying out torsiondrive 
        calculations for all non-hydrogen bonded torsional angles. 
        &#34;&#34;&#34;
        df_tor = pd.read_csv(
            self.torsion_xml_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df_tor.columns = [&#34;k&#34;, &#34;p1&#34;, &#34;p2&#34;, &#34;p3&#34;, &#34;p4&#34;, &#34;periodicity&#34;, &#34;phase&#34;]
        # print(df_tor.head())
        ppdb = PandasPdb()
        ppdb.read_pdb(self.template_pdb)
        df_index_symbol = ppdb.df[&#34;ATOM&#34;][[&#34;atom_number&#34;, &#34;element_symbol&#34;]]
        # print(df_index_symbol.head())
        df_dihedrals = df_tor[[&#34;p1&#34;, &#34;p2&#34;, &#34;p3&#34;, &#34;p4&#34;]]
        # print(df_dihedrals.head())
        dihedrals_list_list = []
        for i in range(len(df_dihedrals)):
            dihedrals_list_list.append(df_dihedrals.iloc[i].values.tolist())
        set_list = set()
        unique_dihedrals_list_list = []
        for x in dihedrals_list_list:
            srtd = tuple(sorted(x))
            if srtd not in set_list:
                unique_dihedrals_list_list.append(x)
                set_list.add(srtd)
        # print(unique_dihedrals_list_list)
        atom_dihedral_list = []
        for sub_list in unique_dihedrals_list_list:
            atom_dihedral_list.append(
                [
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[0]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[1]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[2]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[3]
                    ][&#34;element_symbol&#34;].to_list()[0],
                ]
            )
        # print(atom_dihedral_list)
        index_to_include = []
        for i in range(len(atom_dihedral_list)):
            if &#34;H&#34; not in atom_dihedral_list[i]:
                index_to_include.append(i)
        non_H_dihedrals = []
        for i in index_to_include:
            non_H_dihedrals.append(unique_dihedrals_list_list[i])
        # print(non_H_dihedrals)
        non_H_atom_dihedral_list = []
        for sub_list in non_H_dihedrals:
            non_H_atom_dihedral_list.append(
                [
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[0]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[1]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[2]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[3]
                    ][&#34;element_symbol&#34;].to_list()[0],
                ]
            )
        # print(non_H_atom_dihedral_list)
        df_bonds_all = pd.read_csv(
            self.system_bonds_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df_bonds_all.columns = [&#34;bond_names&#34;, &#34;k&#34;, &#34;angle&#34;, &#34;b1&#34;, &#34;b2&#34;]
        df_bonds = df_bonds_all[[&#34;b1&#34;, &#34;b2&#34;]]
        bonds_list_list = []
        for i in range(len(df_bonds)):
            bonds_list_list.append(df_bonds.iloc[i].values.tolist())
        # print(bonds_list_list)
        reverse_bond_list_list = []
        for i in bonds_list_list:
            reverse_bond_list_list.append(reverse_list(i))
        # print(reverse_bond_list_list)
        bond_list = bonds_list_list + reverse_bond_list_list
        # print(bond_list)
        non_H_dihedral_bonds_list = []
        for i in non_H_dihedrals:
            non_H_dihedral_bonds_list.append(
                [[i[0], i[1]], [i[1], i[2]], [i[2], i[3]]]
            )
        # print(non_H_dihedral_bonds_list)
        bonded_index_to_include = []
        for i in range(len(non_H_dihedral_bonds_list)):
            if [
                non_H_dihedral_bonds_list[i][0] in bond_list,
                non_H_dihedral_bonds_list[i][1] in bond_list,
                non_H_dihedral_bonds_list[i][2] in bond_list,
            ] == [True, True, True]:
                bonded_index_to_include.append(i)
        # print(bonded_index_to_include)
        non_H_bonded_dihedrals = []
        for i in bonded_index_to_include:
            non_H_bonded_dihedrals.append(non_H_dihedrals[i])
        # print(non_H_bonded_dihedrals)
        non_H_bonded_atom_dihedral_list = []
        for sub_list in non_H_bonded_dihedrals:
            non_H_bonded_atom_dihedral_list.append(
                [
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[0]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[1]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[2]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[3]
                    ][&#34;element_symbol&#34;].to_list()[0],
                ]
            )
        print(non_H_bonded_atom_dihedral_list)
        os.system(&#34;rm -rf &#34; + self.tor_dir)
        os.system(&#34;mkdir &#34; + self.tor_dir)
        parent_cwd = os.getcwd()
        shutil.copy(
            parent_cwd + &#34;/&#34; + self.psi_input_file,
            parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.psi_input_file,
        )
        shutil.copy(
            parent_cwd + &#34;/&#34; + self.template_pdb,
            parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.template_pdb,
        )
        shutil.copy(
            parent_cwd + &#34;/&#34; + self.torsion_drive_run_file,
            parent_cwd
            + &#34;/&#34;
            + self.tor_dir
            + &#34;/&#34;
            + self.torsion_drive_run_file,
        )
        os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir)
        torsion_drive_dir = os.getcwd()
        for i in range(len(non_H_bonded_dihedrals)):
            dir_name = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
            os.system(&#34;rm -rf &#34; + dir_name)
            os.system(&#34;mkdir &#34; + dir_name)
            os.chdir(torsion_drive_dir + &#34;/&#34; + dir_name)
            with open(self.dihedral_text_file, &#34;w&#34;) as f:
                f.write(
                    &#34;# dihedral definition by atom indices starting from 1&#34;
                    + &#34;\n&#34;
                )
                f.write(&#34;# i     j     k     l&#34; + &#34;\n&#34;)
                i_ = non_H_bonded_dihedrals[i][0]
                j_ = non_H_bonded_dihedrals[i][1]
                k_ = non_H_bonded_dihedrals[i][2]
                l_ = non_H_bonded_dihedrals[i][3]
                f.write(
                    &#34; &#34;
                    + &#34;{:&lt; 6d}&#34;.format(i_)
                    + &#34;{:&lt; 6d}&#34;.format(j_)
                    + &#34;{:&lt; 6d}&#34;.format(k_)
                    + &#34;{:&lt; 6d}&#34;.format(l_)
                    + &#34;\n&#34;
                )
                shutil.copy(
                    torsion_drive_dir + &#34;/&#34; + self.psi_input_file,
                    torsion_drive_dir
                    + &#34;/&#34;
                    + dir_name
                    + &#34;/&#34;
                    + self.psi_input_file,
                )
                shutil.copy(
                    torsion_drive_dir + &#34;/&#34; + self.template_pdb,
                    torsion_drive_dir
                    + &#34;/&#34;
                    + dir_name
                    + &#34;/&#34;
                    + self.template_pdb,
                )
                shutil.copy(
                    torsion_drive_dir + &#34;/&#34; + self.torsion_drive_run_file,
                    torsion_drive_dir
                    + &#34;/&#34;
                    + dir_name
                    + &#34;/&#34;
                    + self.torsion_drive_run_file,
                )
                os.chdir(torsion_drive_dir)
        os.system(&#34;rm -rf &#34; + self.psi_input_file)
        os.system(&#34;rm -rf &#34; + self.template_pdb)
        os.system(&#34;rm -rf &#34; + self.torsion_drive_run_file)
        os.chdir(parent_cwd)

    def run_torsion_sim(self):
        &#34;&#34;&#34;
        Run torsion scans using torsiondrive locally. \
        &#34;&#34;&#34;
        parent_cwd = os.getcwd()
        target_dir = parent_cwd + &#34;/&#34; + self.tor_dir
        num_folders = 0
        for _, dirnames, filenames in os.walk(target_dir):
            num_folders += len(dirnames)
        for i in range(num_folders):
            dir_ = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
            os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + dir_)
            run_command = &#34;bash&#34; + &#34; &#34; + self.torsion_drive_run_file
            # os.system(run_command)
            print(run_command)
            os.chdir(parent_cwd)


class TorsionDriveParams:
    &#34;&#34;&#34;
    This class is used to parameterize the torsional parameters 
    of the ligand by fitting the torsional parameters obtained 
    from torsiondrive calculations. 

    ...
    Attributes
    ----------
    num_charge_atoms : int
        Number of charged atoms in the molecule.

    index_charge_atom_1 : int
        Index of the first charged atom.

    charge_atom_1 : int
        Charge on the first charged atom.

    tor_dir : str, optional
        Torsiondrive directory containing separate torsiondrive folders, 
        each containing files for a separate torsiondrive calculation 
        for a particular dihedral angle.

    reparameterized_torsional_params_file : str, optional
        Text file containing the forcefield parameters for the 
        ligand previously obtained without torsional reparameterization. 

    psi_input_file : str, optional
        Input file for psi4 QM engine. 

    xyz_file : str, optional
        XYZ file for ligand coordinates.

    coords_file : str, optional
        Text file containing the XYZ coordinates of the ligand.

    template_pdb : str, optional
        Guest PDB with atoms beginning from 1 to be used as a template PDB 
        to retrieve atom indices and symbols.

    system_pdb : str, optional
        PDB file for the torsiondrive torsion scans.

    system_sdf : str, optional
        SDF file for the ligand.

    system_xml : str, optional
        XML force field file for the ligand.

    qm_scan_file : str, optional
        Output scan file for the torsiondrive scans.

    load_topology : str, optional
        Argument to specify how to load the topology. Can either 
        be &#34;openmm&#34; or &#34;parmed&#34;.

    method : str, optional
        Minimization method for fitting of torsional 
        parameters. 

    dihedral_text_file : str, optional
        Dihedral information file for torsiondrive.
 
    system_init_sdf : str, optional
        Ligand SDF (structure-data) format file. This file will be generated 
        only if the ligand is charged.

    reparameterised_system_xml_file : str, optional
        Reparameterized force field XML file obtained using 
        openforcefield without torsional reparamaterization.

    reparameterised_torsional_system_xml_file : str, optional
        XML force field file for the ligand obtained with 
        torsional reparamaterization. 

    &#34;&#34;&#34;

    def __init__(
        self,
        num_charge_atoms,
        index_charge_atom_1,
        charge_atom_1,
        tor_dir=&#34;torsion_dir&#34;,
        reparameterized_torsional_params_file=&#34;reparameterized_torsional_params.txt&#34;,
        psi_input_file=&#34;torsion_drive_input.dat&#34;,
        xyz_file=&#34;torsion_drive_input.xyz&#34;,
        coords_file=&#34;torsion_drive_input.txt&#34;,
        template_pdb=&#34;guest_init_II.pdb&#34;,
        system_pdb=&#34;torsion_drive_input.pdb&#34;,
        system_sdf=&#34;torsion_drive_input.sdf&#34;,
        system_xml=&#34;torsion_drive_input.xml&#34;,
        qm_scan_file=&#34;scan.xyz&#34;,
        load_topology=&#34;openmm&#34;,
        method=&#34;L-BFGS-B&#34;,
        dihedral_text_file=&#34;dihedrals.txt&#34;,
        system_init_sdf=&#34;torsion_drive_input_init.sdf&#34;,
        reparameterised_system_xml_file=&#34;guest_reparameterised.xml&#34;,
        reparameterised_torsional_system_xml_file=&#34;guest_torsional_reparameterized.xml&#34;,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        num_charge_atoms : int
            Number of charged atoms in the molecule.

        index_charge_atom_1 : int
            Index of the first charged atom.

        charge_atom_1 : int
            Charge on the first charged atom.

        tor_dir : str, optional
            Torsiondrive directory containing separate torsiondrive folders, 
            each containing files for a separate torsiondrive calculation 
            for a particular dihedral angle.

        reparameterized_torsional_params_file : str, optional
            Text file containing the forcefield parameters for the 
            ligand previously obtained without torsional reparameterization. 

        psi_input_file : str, optional
            Input file for psi4 QM engine. 
    
        xyz_file : str, optional
            XYZ file for ligand coordinates.

        coords_file : str, optional
            Text file containing the XYZ coordinates of the ligand.

        template_pdb : str, optional
            Guest PDB with atoms beginning from 1 to be used as a template PDB 
            to retrieve atom indices and symbols.

        system_pdb : str, optional
            PDB file for the torsiondrive torsion scans.

        system_sdf : str, optional
            SDF file for the ligand.

        system_xml : str, optional
            XML force field file for the ligand.

        qm_scan_file : str, optional
            Output scan file for the torsiondrive scans.

        load_topology : str, optional
            Argument to specify how to load the topology. Can either 
            be &#34;openmm&#34; or &#34;parmed&#34;.

        method : str, optional
           Minimization method for fitting of torsional 
            parameters. 

        dihedral_text_file : str, optional
            Dihedral information file for torsiondrive.
 
        system_init_sdf : str, optional
            Ligand SDF (structure-data) format file. This file will be generated 
            only if the ligand is charged.

        reparameterised_system_xml_file : str, optional
            Reparameterized force field XML file obtained using 
            openforcefield without torsional reparamaterization.

        reparameterised_torsional_system_xml_file : str, optional
            XML force field file for the ligand obtained with 
            torsional reparamaterization. 
        &#34;&#34;&#34;
        self.num_charge_atoms = num_charge_atoms
        self.index_charge_atom_1 = index_charge_atom_1
        self.charge_atom_1 = charge_atom_1
        self.tor_dir = tor_dir
        self.reparameterized_torsional_params_file = reparameterized_torsional_params_file
        self.psi_input_file = psi_input_file
        self.xyz_file = xyz_file
        self.coords_file = coords_file
        self.template_pdb = template_pdb
        self.system_pdb = system_pdb
        self.system_sdf = system_sdf
        self.system_xml = system_xml
        self.qm_scan_file = qm_scan_file
        self.method = method
        self.dihedral_text_file = dihedral_text_file
        self.system_init_sdf = system_init_sdf
        self.load_topology = load_topology
        self.reparameterised_system_xml_file = reparameterised_system_xml_file
        self.reparameterised_torsional_system_xml_file = reparameterised_torsional_system_xml_file

    def write_reparams_torsion_lines(self):
        &#34;&#34;&#34;
        Saves a text file containing torsional parameters for the ligand
        obtained through openforcefield.
        &#34;&#34;&#34;
        torsional_parameters_list = []
        parent_cwd = os.getcwd()
        target_dir = parent_cwd + &#34;/&#34; + self.tor_dir
        for i in os.listdir(target_dir):
            os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + i)
            print(&#34;Entering directory&#34; + &#34; : &#34; + os.getcwd())
            torsiondrive_input_to_xyz(
                psi_input_file=self.psi_input_file, xyz_file=self.xyz_file
            )
            xyz_to_pdb(
                xyz_file=self.xyz_file,
                coords_file=self.coords_file,
                template_pdb=self.template_pdb,
                system_pdb=self.system_pdb,
            )
            generate_xml_from_charged_pdb_sdf(
                system_pdb=self.system_pdb,
                system_init_sdf=system_init_sdf,
                system_sdf=self.system_sdf,
                num_charge_atoms=num_charge_atoms,
                index_charge_atom_1=index_charge_atom_1,
                charge_atom_1=charge_atom_1,
                system_xml=self.system_xml,
            )
            torsional_lines = get_torsional_lines(
                template_pdb=self.template_pdb,
                system_xml=self.system_xml,
                qm_scan_file=self.qm_scan_file,
                load_topology=self.load_topology,
                method=self.method,
                dihedral_text_file=self.dihedral_text_file,
            )
            # print(torsional_lines)
            torsional_parameters_list.append(torsional_lines)
            remove_mm_files(qm_scan_file=self.qm_scan_file)
            os.chdir(parent_cwd)
        torsional_parameters = [
            item for sublist in torsional_parameters_list for item in sublist
        ]
        with open(self.reparameterized_torsional_params_file, &#34;w&#34;) as f:
            for i in torsional_parameters:
                f.write(i + &#34;\n&#34;)

    def write_reparams_torsion_lines_charged(self):
        &#34;&#34;&#34;
        Saves a text file containing torsional parameters for a charged ligand
        obtained through openforcefield.
        &#34;&#34;&#34;
        torsional_parameters_list = []
        parent_cwd = os.getcwd()
        target_dir = parent_cwd + &#34;/&#34; + self.tor_dir
        for i in os.listdir(target_dir):
            os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + i)
            print(&#34;Entering directory&#34; + &#34; : &#34; + os.getcwd())
            torsiondrive_input_to_xyz(
                psi_input_file=self.psi_input_file, xyz_file=self.xyz_file
            )
            xyz_to_pdb(
                xyz_file=self.xyz_file,
                coords_file=self.coords_file,
                template_pdb=self.template_pdb,
                system_pdb=self.system_pdb,
            )
            generate_xml_from_charged_pdb_sdf(
                system_pdb=self.system_pdb,
                system_init_sdf=self.system_init_sdf,
                system_sdf=self.system_sdf,
                num_charge_atoms=self.num_charge_atoms,
                index_charge_atom_1=self.index_charge_atom_1,
                charge_atom_1=self.charge_atom_1,
                system_xml=self.system_xml,
            )
            torsional_lines = get_torsional_lines(
                template_pdb=self.template_pdb,
                system_xml=self.system_xml,
                qm_scan_file=self.qm_scan_file,
                load_topology=self.load_topology,
                method=self.method,
                dihedral_text_file=self.dihedral_text_file,
            )
            # print(torsional_lines)
            torsional_parameters_list.append(torsional_lines)
            remove_mm_files(qm_scan_file=self.qm_scan_file)
            os.chdir(parent_cwd)
        torsional_parameters = [
            item for sublist in torsional_parameters_list for item in sublist
        ]
        with open(self.reparameterized_torsional_params_file, &#34;w&#34;) as f:
            for i in torsional_parameters:
                f.write(i + &#34;\n&#34;)

    def write_torsional_reparams(self):
        &#34;&#34;&#34;
        Generates a XML force field file for the ligand with reparameterized 
        torsional parameters.
        &#34;&#34;&#34;
        xml_tor = open(self.reparameterized_torsional_params_file, &#34;r&#34;)
        xml_tor_lines = xml_tor.readlines()
        non_zero_k_tor = []
        for i in xml_tor_lines:
            to_find = &#34;k=&#34; + &#39;&#34;&#39; + &#34;0.0&#34; + &#39;&#34;&#39;
            if to_find not in i:
                non_zero_k_tor.append(i)
        # print(non_zero_k_tor)
        p1 = []
        for i in range(len(non_zero_k_tor)):
            p1.append(int(re.findall(&#34;\d*\.?\d+&#34;, non_zero_k_tor[i])[2]))
        # print(p1)
        p2 = []
        for i in range(len(non_zero_k_tor)):
            p2.append(int(re.findall(&#34;\d*\.?\d+&#34;, non_zero_k_tor[i])[4]))
        # print(p2)
        p3 = []
        for i in range(len(non_zero_k_tor)):
            p3.append(int(re.findall(&#34;\d*\.?\d+&#34;, non_zero_k_tor[i])[6]))
        # print(p3)
        p4 = []
        for i in range(len(non_zero_k_tor)):
            p4.append(int(re.findall(&#34;\d*\.?\d+&#34;, non_zero_k_tor[i])[8]))
        # print(p4)
        periodicity = []
        for i in range(len(non_zero_k_tor)):
            periodicity.append(
                int(re.findall(&#34;\d*\.?\d+&#34;, non_zero_k_tor[i])[9])
            )
        # print(periodicity)
        xml_tor_reparams = open(self.reparameterised_system_xml_file, &#34;r&#34;)
        xml_tor_reparams_lines = xml_tor_reparams.readlines()
        for j in range(len(xml_tor_reparams_lines)):
            for i in range(len(non_zero_k_tor)):
                to_find_tor = (
                    &#34;p1=&#34;
                    + &#39;&#34;&#39;
                    + str(p1[i])
                    + &#39;&#34;&#39;
                    + &#34; &#34;
                    + &#34;p2=&#34;
                    + &#39;&#34;&#39;
                    + str(p2[i])
                    + &#39;&#34;&#39;
                    + &#34; &#34;
                    + &#34;p3=&#34;
                    + &#39;&#34;&#39;
                    + str(p3[i])
                    + &#39;&#34;&#39;
                    + &#34; &#34;
                    + &#34;p4=&#34;
                    + &#39;&#34;&#39;
                    + str(p4[i])
                    + &#39;&#34;&#39;
                    + &#34; &#34;
                    + &#34;periodicity=&#34;
                    + &#39;&#34;&#39;
                    + str(periodicity[i])
                    + &#39;&#34;&#39;
                )
                if to_find_tor in xml_tor_reparams_lines[j]:
                    # print(xml_tor_reparams_lines[j])
                    xml_tor_reparams_lines[j] = non_zero_k_tor[i]
        with open(self.reparameterised_torsional_system_xml_file, &#34;w&#34;) as f:
            for i in xml_tor_reparams_lines:
                f.write(i)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="parameterize.OPLS_LJ"><code class="name flex">
<span>def <span class="ident">OPLS_LJ</span></span>(<span>system)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OPLS_LJ(system):
    forces = {
        system.getForce(index).__class__.__name__: system.getForce(index)
        for index in range(system.getNumForces())
    }
    nonbonded_force = forces[&#34;NonbondedForce&#34;]
    lorentz = simtk.openmm.openmm.CustomNonbondedForce(
        &#34;4*epsilon*((sigma/r)^12-(sigma/r)^6); sigma=sqrt(sigma1*sigma2); epsilon=sqrt(epsilon1*epsilon2)&#34;
    )
    lorentz.setNonbondedMethod(nonbonded_force.getNonbondedMethod())
    lorentz.addPerParticleParameter(&#34;sigma&#34;)
    lorentz.addPerParticleParameter(&#34;epsilon&#34;)
    lorentz.setCutoffDistance(nonbonded_force.getCutoffDistance())
    system.addForce(lorentz)
    LJset = {}
    for index in range(nonbonded_force.getNumParticles()):
        charge, sigma, epsilon = nonbonded_force.getParticleParameters(index)
        LJset[index] = (sigma, epsilon)
        lorentz.addParticle([sigma, epsilon])
        nonbonded_force.setParticleParameters(
            index, charge, sigma, epsilon * 0
        )
    for i in range(nonbonded_force.getNumExceptions()):
        (p1, p2, q, sig, eps) = nonbonded_force.getExceptionParameters(i)
        lorentz.addExclusion(p1, p2)
        if eps._value != 0.0:
            # print (p1,p2,sig,eps)
            sig14 = math.sqrt(
                LJset[p1][0].value_in_unit(simtk.unit.nanometer)
                * LJset[p2][0].value_in_unit(simtk.unit.nanometer)
            )
            eps14 = math.sqrt(
                LJset[p1][1].value_in_unit(
                    simtk.unit.kilojoule / simtk.unit.mole
                )
                * LJset[p2][1].value_in_unit(
                    simtk.unit.kilojoule / simtk.unit.mole
                )
            )
            nonbonded_force.setExceptionParameters(i, p1, p2, q, sig14, eps)
    return system</code></pre>
</details>
</dd>
<dt id="parameterize.copy_file"><code class="name flex">
<span>def <span class="ident">copy_file</span></span>(<span>source, destination)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_file(source, destination):
    shutil.copy(source, destination)</code></pre>
</details>
</dd>
<dt id="parameterize.dihedral_energy"><code class="name flex">
<span>def <span class="ident">dihedral_energy</span></span>(<span>x, k1, k2, k3, k4=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dihedral_energy(x, k1, k2, k3, k4=0):
    energy_1 = k1 * (1 + np.cos(1 * x * 0.01745))
    energy_2 = k2 * (1 - np.cos(2 * x * 0.01745))
    energy_3 = k3 * (1 + np.cos(3 * x * 0.01745))
    energy_4 = k4 * (1 - np.cos(4 * x * 0.01745))
    dihedral_energy = energy_1 + energy_2 + energy_3 + energy_4
    return dihedral_energy</code></pre>
</details>
</dd>
<dt id="parameterize.dot_product"><code class="name flex">
<span>def <span class="ident">dot_product</span></span>(<span>u_PA, eig_AB)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dot_product(u_PA, eig_AB):
    x = 0
    for i in range(0, 3):
        x = x + u_PA[i] * eig_AB[i].conjugate()
    return x</code></pre>
</details>
</dd>
<dt id="parameterize.error_function"><code class="name flex">
<span>def <span class="ident">error_function</span></span>(<span>delta_qm, delta_mm)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error_function(delta_qm, delta_mm):
    squared_error = np.square(np.subtract(delta_qm, delta_mm))
    mean_squared_error = squared_error.mean()
    root_mean_squared_error = math.sqrt(mean_squared_error)
    return root_mean_squared_error</code></pre>
</details>
</dd>
<dt id="parameterize.error_function_boltzmann"><code class="name flex">
<span>def <span class="ident">error_function_boltzmann</span></span>(<span>delta_qm, delta_mm, T)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error_function_boltzmann(delta_qm, delta_mm, T):
    kb = 3.297623483 * 10 ** (-24)  # in cal/K
    delta_qm_boltzmann_weighted = [np.exp(-i / (kb * T)) for i in delta_qm]
    squared_error = (
        np.square(np.subtract(delta_qm, delta_mm))
        * delta_qm_boltzmann_weighted
    )
    mean_squared_error = squared_error.mean()
    root_mean_squared_error = math.sqrt(mean_squared_error)
    return root_mean_squared_error</code></pre>
</details>
</dd>
<dt id="parameterize.fit_params"><code class="name flex">
<span>def <span class="ident">fit_params</span></span>(<span>qm_scan_file, load_topology, system_xml, method)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_params(qm_scan_file, load_topology, system_xml, method):
    k_guess = gen_init_guess(
        qm_scan_file=qm_scan_file,
        load_topology=load_topology,
        system_xml=system_xml,
    )
    x_data = np.array(get_dihedrals(qm_scan_file))
    delta_qm = np.array(
        scale_list(list_hartree_kcal(list_=get_qm_energies(qm_scan_file)))
    )
    optimise = scipy.optimize.minimize(
        objective_function,
        k_guess,
        args=(x_data, delta_qm),
        method=method,
        bounds=[(0.00, None), (0.00, None), (0.00, None), (0.00, None)],
    )
    return optimise.x</code></pre>
</details>
</dd>
<dt id="parameterize.force_angle_constant"><code class="name flex">
<span>def <span class="ident">force_angle_constant</span></span>(<span>atom_A, atom_B, atom_C, bond_lengths, eigenvalues, eigenvectors, coords, scaling_1, scaling_2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def force_angle_constant(
    atom_A,
    atom_B,
    atom_C,
    bond_lengths,
    eigenvalues,
    eigenvectors,
    coords,
    scaling_1,
    scaling_2,
):
    # Force Constant- Equation 14 of seminario calculation paper - gives force constant for angle 
    # (in kcal/mol/rad^2) and equilibrium angle in degrees
    # Vectors along bonds calculated
    diff_AB = coords[atom_B, :] - coords[atom_A, :]
    norm_diff_AB = np.linalg.norm(diff_AB)
    u_AB = diff_AB / norm_diff_AB
    diff_CB = coords[atom_B, :] - coords[atom_C, :]
    norm_diff_CB = np.linalg.norm(diff_CB)
    u_CB = diff_CB / norm_diff_CB
    # Bond lengths and eigenvalues found
    bond_length_AB = bond_lengths[atom_A, atom_B]
    eigenvalues_AB = eigenvalues[atom_A, atom_B, :]
    eigenvectors_AB = eigenvectors[0:3, 0:3, atom_A, atom_B]
    bond_length_BC = bond_lengths[atom_B, atom_C]
    eigenvalues_CB = eigenvalues[atom_C, atom_B, :]
    eigenvectors_CB = eigenvectors[0:3, 0:3, atom_C, atom_B]
    # Normal vector to angle plane found
    u_N = unit_vector_N(u_CB, u_AB)
    u_PA = np.cross(u_N, u_AB)
    norm_u_PA = np.linalg.norm(u_PA)
    u_PA = u_PA / norm_u_PA
    u_PC = np.cross(u_CB, u_N)
    norm_u_PC = np.linalg.norm(u_PC)
    u_PC = u_PC / norm_u_PC
    sum_first = 0
    sum_second = 0
    # Projections of eigenvalues
    for i in range(0, 3):
        eig_AB_i = eigenvectors_AB[:, i]
        eig_BC_i = eigenvectors_CB[:, i]
        sum_first = sum_first + (
            eigenvalues_AB[i] * abs(dot_product(u_PA, eig_AB_i))
        )
        sum_second = sum_second + (
            eigenvalues_CB[i] * abs(dot_product(u_PC, eig_BC_i))
        )
    # Scaling due to additional angles - Modified Seminario Part
    sum_first = sum_first / scaling_1
    sum_second = sum_second / scaling_2
    # Added as two springs in series
    k_theta = (1 / ((bond_length_AB ** 2) * sum_first)) + (
        1 / ((bond_length_BC ** 2) * sum_second)
    )
    k_theta = 1 / k_theta
    k_theta = -k_theta  # Change to OPLS form
    k_theta = abs(k_theta * 0.5)  # Change to OPLS form
    # Equilibrium Angle
    theta_0 = math.degrees(math.acos(np.dot(u_AB, u_CB)))
    # If the vectors u_CB and u_AB are linearly dependent u_N cannot be defined
    # This case is dealt with here
    if abs(sum((u_CB) - (u_AB))) &lt; 0.01 or (
        abs(sum((u_CB) - (u_AB))) &gt; 1.99 and abs(sum((u_CB) - (u_AB))) &lt; 2.01
    ):
        scaling_1 = 1
        scaling_2 = 1
        [k_theta, theta_0] = force_angle_constant_special_case(
            atom_A,
            atom_B,
            atom_C,
            bond_lengths,
            eigenvalues,
            eigenvectors,
            coords,
            scaling_1,
            scaling_2,
        )
    return k_theta, theta_0</code></pre>
</details>
</dd>
<dt id="parameterize.force_angle_constant_special_case"><code class="name flex">
<span>def <span class="ident">force_angle_constant_special_case</span></span>(<span>atom_A, atom_B, atom_C, bond_lengths, eigenvalues, eigenvectors, coords, scaling_1, scaling_2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def force_angle_constant_special_case(
    atom_A,
    atom_B,
    atom_C,
    bond_lengths,
    eigenvalues,
    eigenvectors,
    coords,
    scaling_1,
    scaling_2,
):
    # Force Constant- Equation 14 of seminario calculation paper - gives force constant for angle 
    # (in kcal/mol/rad^2) and equilibrium angle in degrees
    # Deals with cases when u_N cannot be defined and instead takes samples of u_N across a unit sphere.
    # Vectors along bonds calculated
    diff_AB = coords[atom_B, :] - coords[atom_A, :]
    norm_diff_AB = np.linalg.norm(diff_AB)
    u_AB = diff_AB / norm_diff_AB
    diff_CB = coords[atom_B, :] - coords[atom_C, :]
    norm_diff_CB = np.linalg.norm(diff_CB)
    u_CB = diff_CB / norm_diff_CB
    # Bond lengths and eigenvalues found
    bond_length_AB = bond_lengths[atom_A, atom_B]
    eigenvalues_AB = eigenvalues[atom_A, atom_B, :]
    eigenvectors_AB = eigenvectors[0:3, 0:3, atom_A, atom_B]
    bond_length_BC = bond_lengths[atom_B, atom_C]
    eigenvalues_CB = eigenvalues[atom_C, atom_B, :]
    eigenvectors_CB = eigenvectors[0:3, 0:3, atom_C, atom_B]
    k_theta_array = np.zeros((180, 360))
    # Find force constant with varying u_N (with vector uniformly sampled across a sphere)
    for theta in range(0, 180):
        for phi in range(0, 360):
            r = 1
            u_N = [
                r
                * math.sin(math.radians(theta))
                * math.cos(math.radians(theta)),
                r
                * math.sin(math.radians(theta))
                * math.sin(math.radians(theta)),
                r * math.cos(math.radians(theta)),
            ]
            u_PA = np.cross(u_N, u_AB)
            u_PA = u_PA / np.linalg.norm(u_PA)
            u_PC = np.cross(u_CB, u_N)
            u_PC = u_PC / np.linalg.norm(u_PC)
            sum_first = 0
            sum_second = 0
            # Projections of eigenvalues
            for i in range(0, 3):
                eig_AB_i = eigenvectors_AB[:, i]
                eig_BC_i = eigenvectors_CB[:, i]
                sum_first = sum_first + (
                    eigenvalues_AB[i] * abs(dot_product(u_PA, eig_AB_i))
                )
                sum_second = sum_second + (
                    eigenvalues_CB[i] * abs(dot_product(u_PC, eig_BC_i))
                )
            # Added as two springs in series
            k_theta_ij = (1 / ((bond_length_AB ** 2) * sum_first)) + (
                1 / ((bond_length_BC ** 2) * sum_second)
            )
            k_theta_ij = 1 / k_theta_ij
            k_theta_ij = -k_theta_ij  # Change to OPLS form
            k_theta_ij = abs(k_theta_ij * 0.5)  # Change to OPLS form
            k_theta_array[theta, phi] = k_theta_ij
    # Removes cases where u_N was linearly dependent of u_CB or u_AB
    # Force constant used is taken as the mean
    k_theta = np.mean(np.mean(k_theta_array))
    # Equilibrium Angle independent of u_N
    theta_0 = math.degrees(math.cos(np.dot(u_AB, u_CB)))
    return k_theta, theta_0</code></pre>
</details>
</dd>
<dt id="parameterize.force_constant_bond"><code class="name flex">
<span>def <span class="ident">force_constant_bond</span></span>(<span>atom_A, atom_B, eigenvalues, eigenvectors, coords)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def force_constant_bond(atom_A, atom_B, eigenvalues, eigenvectors, coords):
    # Force Constant - Equation 10 of Seminario paper - gives force 
    # constant for bond
    # Eigenvalues and eigenvectors calculated
    eigenvalues_AB = eigenvalues[atom_A, atom_B, :]
    eigenvectors_AB = eigenvectors[:, :, atom_A, atom_B]
    # Vector along bond
    diff_AB = np.array(coords[atom_B, :]) - np.array(coords[atom_A, :])
    norm_diff_AB = np.linalg.norm(diff_AB)
    unit_vectors_AB = diff_AB / norm_diff_AB
    k_AB = 0
    # Projections of eigenvalues
    for i in range(0, 3):
        dot_product = abs(np.dot(unit_vectors_AB, eigenvectors_AB[:, i]))
        k_AB = k_AB + (eigenvalues_AB[i] * dot_product)
    k_AB = -k_AB * 0.5  # Convert to OPLS form
    return k_AB</code></pre>
</details>
</dd>
<dt id="parameterize.gen_init_guess"><code class="name flex">
<span>def <span class="ident">gen_init_guess</span></span>(<span>qm_scan_file, load_topology, system_xml)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_init_guess(qm_scan_file, load_topology, system_xml):
    x = get_dihedrals(qm_scan_file)
    y = scale_list(
        list_=get_mm_potential_energies(
            qm_scan_file=qm_scan_file,
            load_topology=load_topology,
            system_xml=system_xml,
        )
    )
    init_vals = [0.0, 0.0, 0.0, 0.0]
    k_init_guess, covar = scipy.optimize.curve_fit(
        dihedral_energy, x, y, p0=init_vals
    )
    for i in range(len(k_init_guess)):
        if k_init_guess[i] &lt; 0:
            k_init_guess[i] = 0
    return k_init_guess</code></pre>
</details>
</dd>
<dt id="parameterize.generate_mm_pdbs"><code class="name flex">
<span>def <span class="ident">generate_mm_pdbs</span></span>(<span>qm_scan_file, template_pdb)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_mm_pdbs(qm_scan_file, template_pdb):
    with open(qm_scan_file, &#34;r&#34;) as f:
        lines = f.readlines()
    energy_dihedral_lines = []
    for i in range(len(lines)):
        if &#34;Dihedral&#34; in lines[i]:
            energy_dihedral_lines.append(lines[i])
    dihedrals = []
    for i in energy_dihedral_lines:
        energy_dihedral = i
        energy_dihedral = re.findall(r&#34;[-+]?\d+[.]?\d*&#34;, energy_dihedral)
        dihedral = float(energy_dihedral[0])
        dihedrals.append(dihedral)
    lines_markers = []
    for i in range(len(lines)):
        if &#34;Dihedral&#34; in lines[i]:
            lines_markers.append(i)
    lines_markers.append(len(lines) + 1)
    for i in range(len(lines_markers) - 1):
        # pdb_file_to_write = str(dihedrals[i]) + &#34;.pdb&#34;
        if dihedrals[i] &gt; 0:
            pdb_file_to_write = &#34;plus_&#34; + str(abs(dihedrals[i])) + &#34;.pdb&#34;
        if dihedrals[i] &lt; 0:
            pdb_file_to_write = &#34;minus_&#34; + str(abs(dihedrals[i])) + &#34;.pdb&#34;
        to_begin = lines_markers[i]
        to_end = lines_markers[i + 1]
        lines_to_write = lines[to_begin + 1 : to_end - 1]
        x_coords = []
        y_coords = []
        z_coords = []
        for i in lines_to_write:
            coordinates = i
            coordinates = re.findall(r&#34;[-+]?\d+[.]?\d*&#34;, coordinates)
            x = float(coordinates[0])
            y = float(coordinates[1])
            z = float(coordinates[2])
            x_coords.append(x)
            y_coords.append(y)
            z_coords.append(z)
        ppdb = PandasPdb()
        ppdb.read_pdb(template_pdb)
        ppdb.df[&#34;ATOM&#34;][&#34;x_coord&#34;] = x_coords
        ppdb.df[&#34;ATOM&#34;][&#34;y_coord&#34;] = y_coords
        ppdb.df[&#34;ATOM&#34;][&#34;z_coord&#34;] = z_coords
        ppdb.to_pdb(pdb_file_to_write)</code></pre>
</details>
</dd>
<dt id="parameterize.generate_xml_from_charged_pdb_sdf"><code class="name flex">
<span>def <span class="ident">generate_xml_from_charged_pdb_sdf</span></span>(<span>system_pdb, system_init_sdf, system_sdf, num_charge_atoms, index_charge_atom_1, charge_atom_1, system_xml)</span>
</code></dt>
<dd>
<div class="desc"><p>This function generates an openforcefield xml file from the pdb
file via SDF file and openforcefield.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_xml_from_charged_pdb_sdf(
    system_pdb,
    system_init_sdf,
    system_sdf,
    num_charge_atoms,
    index_charge_atom_1,
    charge_atom_1,
    system_xml,
):
    &#34;&#34;&#34;
    This function generates an openforcefield xml file from the pdb 
    file via SDF file and openforcefield.
    &#34;&#34;&#34;
    command = &#34;babel -ipdb &#34; + system_pdb + &#34; -osdf &#34; + system_init_sdf
    os.system(command)
    with open(system_init_sdf, &#34;r&#34;) as f1:
        filedata = f1.readlines()
        filedata = filedata[:-2]
    with open(system_sdf, &#34;w+&#34;) as out:
        for i in filedata:
            out.write(i)
        line_1 = (
            &#34;M  CHG  &#34;
            + str(num_charge_atoms)
            + &#34;   &#34;
            + str(index_charge_atom_1)
            + &#34;   &#34;
            + str(charge_atom_1)
            + &#34;\n&#34;
        )
        line_2 = &#34;M  END&#34; + &#34;\n&#34;
        line_3 = &#34;$$$$&#34;
        out.write(line_1)
        out.write(line_2)
        out.write(line_3)
    off_molecule = openforcefield.topology.Molecule(system_sdf)
    force_field = openforcefield.typing.engines.smirnoff.ForceField(
        &#34;openff_unconstrained-1.0.0.offxml&#34;
    )
    system = force_field.create_openmm_system(off_molecule.to_topology())
    pdbfile = simtk.openmm.app.PDBFile(system_pdb)
    structure = parmed.openmm.load_topology(
        pdbfile.topology, system, xyz=pdbfile.positions
    )
    with open(system_xml, &#34;w&#34;) as f:
        f.write(simtk.openmm.XmlSerializer.serialize(system))</code></pre>
</details>
</dd>
<dt id="parameterize.generate_xml_from_pdb_sdf"><code class="name flex">
<span>def <span class="ident">generate_xml_from_pdb_sdf</span></span>(<span>system_pdb, system_sdf, system_xml)</span>
</code></dt>
<dd>
<div class="desc"><p>This function generates an openforcefield xml file from the pdb file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_xml_from_pdb_sdf(system_pdb, system_sdf, system_xml):
    &#34;&#34;&#34;
    This function generates an openforcefield xml file from the pdb file
    &#34;&#34;&#34;
    command = &#34;babel -ipdb &#34; + system_pdb + &#34; -osdf &#34; + system_sdf
    os.system(command)
    off_molecule = openforcefield.topology.Molecule(system_sdf)
    force_field = openforcefield.typing.engines.smirnoff.ForceField(
        &#34;openff_unconstrained-1.0.0.offxml&#34;
    )
    system = force_field.create_openmm_system(off_molecule.to_topology())
    pdbfile = simtk.openmm.app.PDBFile(system_pdb)
    structure = parmed.openmm.load_topology(
        pdbfile.topology, system, xyz=pdbfile.positions
    )
    with open(system_xml, &#34;w&#34;) as f:
        f.write(simtk.openmm.XmlSerializer.serialize(system))</code></pre>
</details>
</dd>
<dt id="parameterize.get_dihedrals"><code class="name flex">
<span>def <span class="ident">get_dihedrals</span></span>(<span>qm_scan_file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dihedrals(qm_scan_file):
    with open(qm_scan_file, &#34;r&#34;) as f:
        lines = f.readlines()
    energy_dihedral_lines = []
    for i in range(len(lines)):
        if &#34;Dihedral&#34; in lines[i]:
            energy_dihedral_lines.append(lines[i])
    dihedrals = []
    for i in energy_dihedral_lines:
        energy_dihedral = i
        energy_dihedral = re.findall(r&#34;[-+]?\d+[.]?\d*&#34;, energy_dihedral)
        dihedral = float(energy_dihedral[0])
        dihedrals.append(dihedral)
    return dihedrals</code></pre>
</details>
</dd>
<dt id="parameterize.get_mm_potential_energies"><code class="name flex">
<span>def <span class="ident">get_mm_potential_energies</span></span>(<span>qm_scan_file, load_topology, system_xml)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mm_potential_energies(qm_scan_file, load_topology, system_xml):
    mm_pdb_list = []
    for i in get_dihedrals(qm_scan_file):
        if i &gt; 0:
            pdb_file = &#34;plus_&#34; + str(abs(i)) + &#34;.pdb&#34;
        if i &lt; 0:
            pdb_file = &#34;minus_&#34; + str(abs(i)) + &#34;.pdb&#34;
        mm_pdb_list.append(pdb_file)
    for i in mm_pdb_list:
        mm_pdb_file = i
    mm_potential_energies = []
    for i in mm_pdb_list:
        mm_pdb_file = i
        mm_energy = get_non_torsion_mm_energy(
            system_pdb=i, load_topology=load_topology, system_xml=system_xml
        )
        mm_potential_energies.append(mm_energy)
    return mm_potential_energies</code></pre>
</details>
</dd>
<dt id="parameterize.get_non_torsion_mm_energy"><code class="name flex">
<span>def <span class="ident">get_non_torsion_mm_energy</span></span>(<span>system_pdb, load_topology, system_xml)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_non_torsion_mm_energy(system_pdb, load_topology, system_xml):
    system_prmtop = system_pdb[:-4] + &#34;.prmtop&#34;
    system_inpcrd = system_pdb[:-4] + &#34;.inpcrd&#34;
    if load_topology == &#34;parmed&#34;:
        openmm_system = parmed.openmm.load_topology(
            parmed.load_file(system_pdb, structure=True).topology,
            parmed.load_file(system_xml),
        )
    if load_topology == &#34;openmm&#34;:
        openmm_system = parmed.openmm.load_topology(
            simtk.openmm.app.PDBFile(system_pdb).topology,
            parmed.load_file(system_xml),
        )
    openmm_system.save(system_prmtop, overwrite=True)
    openmm_system.coordinates = parmed.load_file(
        system_pdb, structure=True
    ).coordinates
    openmm_system.save(system_inpcrd, overwrite=True)
    parm = parmed.load_file(system_prmtop, system_inpcrd)
    prmtop_energy_decomposition = parmed.openmm.energy_decomposition_system(
        parm, parm.createSystem()
    )
    # print(prmtop_energy_decomposition)
    prmtop_energy_decomposition_value_no_torsion = [
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicBondForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicAngleForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;NonbondedForce&#34;),
    ]
    return sum(prmtop_energy_decomposition_value_no_torsion)</code></pre>
</details>
</dd>
<dt id="parameterize.get_qm_energies"><code class="name flex">
<span>def <span class="ident">get_qm_energies</span></span>(<span>qm_scan_file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_qm_energies(qm_scan_file):
    with open(qm_scan_file, &#34;r&#34;) as f:
        lines = f.readlines()
    energy_dihedral_lines = []
    for i in range(len(lines)):
        if &#34;Dihedral&#34; in lines[i]:
            energy_dihedral_lines.append(lines[i])
    qm_energies = []
    for i in energy_dihedral_lines:
        energy_dihedral = i
        energy_dihedral = re.findall(r&#34;[-+]?\d+[.]?\d*&#34;, energy_dihedral)
        energy = float(energy_dihedral[1])
        qm_energies.append(energy)
    return qm_energies</code></pre>
</details>
</dd>
<dt id="parameterize.get_tor_params"><code class="name flex">
<span>def <span class="ident">get_tor_params</span></span>(<span>qm_scan_file, template_pdb, load_topology, system_xml, method)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tor_params(
    qm_scan_file, template_pdb, load_topology, system_xml, method
):
    qm_e = get_qm_energies(qm_scan_file=qm_scan_file)
    qm_e_kcal = list_hartree_kcal(qm_e)
    delta_qm = scale_list(qm_e_kcal)
    generate_mm_pdbs(qm_scan_file=qm_scan_file, template_pdb=template_pdb)
    mm_pe_no_torsion_kcal = get_mm_potential_energies(
        qm_scan_file=qm_scan_file,
        load_topology=load_topology,
        system_xml=system_xml,
    )
    delta_mm = scale_list(mm_pe_no_torsion_kcal)
    opt_param = fit_params(
        qm_scan_file=qm_scan_file,
        load_topology=load_topology,
        system_xml=system_xml,
        method=method,
    )
    return opt_param</code></pre>
</details>
</dd>
<dt id="parameterize.get_torsional_lines"><code class="name flex">
<span>def <span class="ident">get_torsional_lines</span></span>(<span>template_pdb, system_xml, qm_scan_file, load_topology, method, dihedral_text_file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_torsional_lines(
    template_pdb,
    system_xml,
    qm_scan_file,
    load_topology,
    method,
    dihedral_text_file,
):
    opt_param = get_tor_params(
        qm_scan_file=qm_scan_file,
        template_pdb=template_pdb,
        load_topology=load_topology,
        system_xml=system_xml,
        method=method,
    )
    dihedral_text = open(dihedral_text_file, &#34;r&#34;)
    dihedral_text_lines = dihedral_text.readlines()
    atom_numbers = dihedral_text_lines[-1]
    atom_index_from_1 = [
        int(re.findall(r&#34;\d+&#34;, atom_numbers)[0]),
        int(re.findall(r&#34;\d+&#34;, atom_numbers)[1]),
        int(re.findall(r&#34;\d+&#34;, atom_numbers)[2]),
        int(re.findall(r&#34;\d+&#34;, atom_numbers)[3]),
    ]
    atom_index = [i - 1 for i in atom_index_from_1]
    atom_index_lines = (
        &#34; &#34;
        + &#34;p1=&#34;
        + &#39;&#34;&#39;
        + str(atom_index[0])
        + &#39;&#34;&#39;
        + &#34; &#34;
        + &#34;p2=&#34;
        + &#39;&#34;&#39;
        + str(atom_index[1])
        + &#39;&#34;&#39;
        + &#34; &#34;
        + &#34;p3=&#34;
        + &#39;&#34;&#39;
        + str(atom_index[2])
        + &#39;&#34;&#39;
        + &#34; &#34;
        + &#34;p4=&#34;
        + &#39;&#34;&#39;
        + str(atom_index[3])
        + &#39;&#34;&#39;
        + &#34; &#34;
    )
    tor_lines = []
    for i in range(len(opt_param)):
        line_to_append = (
            &#34;                &#34;
            + &#34;&lt;Torsion &#34;
            + &#34;k=&#34;
            + &#39;&#34;&#39;
            + str(round(opt_param[i], 8))
            + &#39;&#34;&#39;
            + atom_index_lines
            + &#34;periodicity=&#34;
            + &#39;&#34;&#39;
            + str(i + 1)
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;phase=&#34;
            + &#39;&#34;&#39;
            + &#34;0&#34;
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
        )
        # print(line_to_append)
        tor_lines.append(line_to_append)
    return tor_lines</code></pre>
</details>
</dd>
<dt id="parameterize.list_diff"><code class="name flex">
<span>def <span class="ident">list_diff</span></span>(<span>list_1, list_2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_diff(list_1, list_2):
    diff_list = []
    zipped_list = zip(list_1, list_2)
    for list1_i, list2_i in zipped_list:
        diff_list.append(list1_i - list2_i)
    return diff_list</code></pre>
</details>
</dd>
<dt id="parameterize.list_hartree_kcal"><code class="name flex">
<span>def <span class="ident">list_hartree_kcal</span></span>(<span>list_)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_hartree_kcal(list_):
    converted_list = [i * 627.5094 for i in list_]
    return converted_list</code></pre>
</details>
</dd>
<dt id="parameterize.list_kJ_kcal"><code class="name flex">
<span>def <span class="ident">list_kJ_kcal</span></span>(<span>list_)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_kJ_kcal(list_):
    converted_list = [i / 4.184 for i in list_]
    return converted_list</code></pre>
</details>
</dd>
<dt id="parameterize.list_to_dict"><code class="name flex">
<span>def <span class="ident">list_to_dict</span></span>(<span>lst)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_to_dict(lst):
    res_dct = {lst[i]: lst[i + 1] for i in range(0, len(lst), 2)}
    return res_dct</code></pre>
</details>
</dd>
<dt id="parameterize.objective_function"><code class="name flex">
<span>def <span class="ident">objective_function</span></span>(<span>k_array, x, delta_qm)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def objective_function(k_array, x, delta_qm):
    delta_mm = dihedral_energy(
        x, k1=k_array[0], k2=k_array[1], k3=k_array[2], k4=k_array[3]
    )
    loss_function = error_function(delta_qm, delta_mm)
    return loss_function</code></pre>
</details>
</dd>
<dt id="parameterize.remove_mm_files"><code class="name flex">
<span>def <span class="ident">remove_mm_files</span></span>(<span>qm_scan_file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_mm_files(qm_scan_file):
    mm_pdb_list = []
    for i in get_dihedrals(qm_scan_file):
        if i &gt; 0:
            pdb_file = &#34;plus_&#34; + str(abs(i)) + &#34;.pdb&#34;
        if i &lt; 0:
            pdb_file = &#34;minus_&#34; + str(abs(i)) + &#34;.pdb&#34;
        mm_pdb_list.append(pdb_file)
    for i in mm_pdb_list:
        command = &#34;rm -rf  &#34; + i
        os.system(command)
        command = &#34;rm -rf  &#34; + i[:-4] + &#34;.inpcrd&#34;
        os.system(command)
        command = &#34;rm -rf  &#34; + i[:-4] + &#34;.prmtop&#34;
        os.system(command)</code></pre>
</details>
</dd>
<dt id="parameterize.reverse_list"><code class="name flex">
<span>def <span class="ident">reverse_list</span></span>(<span>lst)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverse_list(lst):
    reversed_list = lst[::-1]
    return reversed_list</code></pre>
</details>
</dd>
<dt id="parameterize.scale_list"><code class="name flex">
<span>def <span class="ident">scale_list</span></span>(<span>list_)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale_list(list_):
    scaled_list = [i - min(list_) for i in list_]
    return scaled_list</code></pre>
</details>
</dd>
<dt id="parameterize.search_in_file"><code class="name flex">
<span>def <span class="ident">search_in_file</span></span>(<span>file: str, word: str) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Search for the given string in file and return lines containing
that string along with line numbers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_in_file(file: str, word: str) -&gt; list:
    &#34;&#34;&#34;
    Search for the given string in file and return lines containing 
    that string along with line numbers
    &#34;&#34;&#34;
    line_number = 0
    list_of_results = []
    with open(file, &#34;r&#34;) as f:
        for line in f:
            line_number += 1
            if word in line:
                list_of_results.append((line_number, line.rstrip()))
    return list_of_results</code></pre>
</details>
</dd>
<dt id="parameterize.torsiondrive_input_to_xyz"><code class="name flex">
<span>def <span class="ident">torsiondrive_input_to_xyz</span></span>(<span>psi_input_file, xyz_file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def torsiondrive_input_to_xyz(psi_input_file, xyz_file):
    with open(psi_input_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;molecule {&#34; in lines[i]:
            to_begin = int(i)
        if &#34;set {&#34; in lines[i]:
            to_end = int(i)
    xyz_lines = lines[to_begin + 2 : to_end - 1]
    with open(xyz_file, &#34;w&#34;) as f:
        f.write(str(len(xyz_lines)) + &#34;\n&#34;)
        f.write(xyz_file + &#34;\n&#34;)
        for i in xyz_lines:
            f.write(i)</code></pre>
</details>
</dd>
<dt id="parameterize.u_PA_from_angles"><code class="name flex">
<span>def <span class="ident">u_PA_from_angles</span></span>(<span>atom_A, atom_B, atom_C, coords)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def u_PA_from_angles(atom_A, atom_B, atom_C, coords):
    # Gives the vector in the plane A,B,C and perpendicular to A to B
    diff_AB = coords[atom_B, :] - coords[atom_A, :]
    norm_diff_AB = np.linalg.norm(diff_AB)
    u_AB = diff_AB / norm_diff_AB
    diff_CB = coords[atom_B, :] - coords[atom_C, :]
    norm_diff_CB = np.linalg.norm(diff_CB)
    u_CB = diff_CB / norm_diff_CB
    u_N = unit_vector_N(u_CB, u_AB)
    u_PA = np.cross(u_N, u_AB)
    norm_PA = np.linalg.norm(u_PA)
    u_PA = u_PA / norm_PA
    return u_PA</code></pre>
</details>
</dd>
<dt id="parameterize.uniq"><code class="name flex">
<span>def <span class="ident">uniq</span></span>(<span>input_)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uniq(input_):
    output = []
    for x in input_:
        if x not in output:
            output.append(x)
    return output</code></pre>
</details>
</dd>
<dt id="parameterize.unit_vector_N"><code class="name flex">
<span>def <span class="ident">unit_vector_N</span></span>(<span>u_BC, u_AB)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unit_vector_N(u_BC, u_AB):
    # Calculates unit normal vector which is perpendicular to plane ABC
    cross_product = np.cross(u_BC, u_AB)
    norm_u_N = np.linalg.norm(cross_product)
    u_N = cross_product / norm_u_N
    return u_N</code></pre>
</details>
</dd>
<dt id="parameterize.xyz_to_pdb"><code class="name flex">
<span>def <span class="ident">xyz_to_pdb</span></span>(<span>xyz_file, coords_file, template_pdb, system_pdb)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xyz_to_pdb(xyz_file, coords_file, template_pdb, system_pdb):
    with open(xyz_file, &#34;r&#34;) as f:
        lines = f.readlines()
    needed_lines = lines[2:]
    with open(coords_file, &#34;w&#34;) as f:
        for i in needed_lines:
            f.write(i)
    df = pd.read_csv(coords_file, header=None, delimiter=r&#34;\s+&#34;)
    df.columns = [&#34;atom&#34;, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;]
    ppdb = PandasPdb()
    ppdb.read_pdb(template_pdb)
    ppdb.df[&#34;ATOM&#34;][&#34;x_coord&#34;] = df[&#34;x&#34;]
    ppdb.df[&#34;ATOM&#34;][&#34;y_coord&#34;] = df[&#34;y&#34;]
    ppdb.df[&#34;ATOM&#34;][&#34;z_coord&#34;] = df[&#34;z&#34;]
    ppdb.to_pdb(system_pdb)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="parameterize.GuestAmberXMLAmber"><code class="flex name class">
<span>class <span class="ident">GuestAmberXMLAmber</span></span>
<span>(</span><span>charge, num_charge_atoms, charge_atom_1, index_charge_atom_1, system_pdb='guest_init_II.pdb', system_mol2='guest.mol2', system_in='guest.in', system_frcmod='guest.frcmod', prmtop_system='guest.prmtop', inpcrd_system='guest.inpcrd', system_leap='guest.leap', system_xml='guest_init.xml', system_smi='guest.smi', system_sdf='guest.sdf', system_init_sdf='guest_init.sdf', index_charge_atom_2=' ', charge_atom_2=' ', charge_parameter_file='guest_charges.txt', system_qm_pdb='guest_init_II.pdb', bond_parameter_file='guest_bonds.txt', angle_parameter_file='guest_angles.txt', system_qm_params_file='guest_qm_params.txt', reparameterised_intermediate_system_xml_file='guest_intermediate_reparameterised.xml', system_xml_non_bonded_file='guest_xml_non_bonded.txt', system_xml_non_bonded_reparams_file='guest_xml_non_bonded_reparams.txt', reparameterised_system_xml_file='guest_reparameterised.xml', non_reparameterised_system_xml_file='guest_init.xml', prmtop_system_non_params='guest_non_params.prmtop', inpcrd_system_non_params='guest_non_params.inpcrd', prmtop_system_params='guest_params.prmtop', inpcrd_system_params='guest_params.inpcrd', load_topology='openmm')</span>
</code></dt>
<dd>
<div class="desc"><p>A class used to generate a template force field XML file for the ligand
in order regenerate the reparametrised forcefield XML file.</p>
<p>This class contains methods to generate a template XML force field through
openforcefield. XML template generation can be obtained through different
file formats such as PDB, SDF, and SMI. Methods support charged ligands as
well. Re-parameterized XML force field files are then generated from the
template files. Different energy components such as the bond, angle,
torsional and non-bonded energies are computed for the non-reparametrized
and the reparameterized force fields. Difference between the
non-reparameterized and reparameterized force field energies can then be
analyzed.
&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>charge</code></strong> :&ensp;<code>int</code></dt>
<dd>Charge of the ligand.</dd>
<dt><strong><code>num_charge_atoms</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of charged atoms in the molecule.</dd>
<dt><strong><code>charge_atom_1</code></strong> :&ensp;<code>int</code></dt>
<dd>Charge on the first charged atom.</dd>
<dt><strong><code>index_charge_atom_1</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the first charged atom.</dd>
<dt><strong><code>system_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ligand PDB file with atom numbers beginning from 1.</dd>
<dt><strong><code>system_mol2</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ligand Mol2 file obtained from PDB file.</dd>
<dt><strong><code>system_in</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Prepi file as required by antechamber.</dd>
<dt><strong><code>system_frcmod</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>FRCMOD file as required by antechamber.</dd>
<dt><strong><code>prmtop_system</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Topology file obtained from the ligand PDB.</dd>
<dt><strong><code>inpcrd_system</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Coordinate file obtained from the Ligand PDB using the
command saveamberparm.</dd>
<dt><strong><code>system_leap</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Amber generated leap file for generating and saving topology
and coordinate files.</dd>
<dt><strong><code>system_xml</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Serialized XML force field file of the ligand.</dd>
<dt><strong><code>system_smi</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ligand SMILES format file.</dd>
<dt><strong><code>system_sdf</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ligand SDF (structure-data) format file.</dd>
<dt><strong><code>system_init_sdf</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ligand SDF (structure-data) format file. This file will be
generated only if the ligand is charged.</dd>
<dt><strong><code>index_charge_atom_2</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Index of the second charged atom of the ligand.</dd>
<dt><strong><code>charge_atom_2</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Charge on the second charged atom of the ligand.</dd>
<dt><strong><code>charge_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>File containing the charges of ligand atoms and their corresponding
atoms.</dd>
<dt><strong><code>system_qm_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ligand PDB file with atom numbers beginning from 1.</dd>
<dt><strong><code>bond_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the bond parameters for the ligand.</dd>
<dt><strong><code>angle_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the angle parameters of the ligand.</dd>
<dt><strong><code>system_qm_params_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A text file containing the QM obtained parameters for the
ligand.</dd>
<dt><strong><code>reparameterised_intermediate_system_xml_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>XML foce field file with bond and angle parameter lines replaced by
corresponding values obtained from the QM calculations.</dd>
<dt><strong><code>system_xml_non_bonded_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A text file to write the NonBondedForce Charge Parameters from
the non-parametrised system XML file.</dd>
<dt><strong><code>system_xml_non_bonded_reparams_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the non-bonded parameters parsed from the
XML force field file.</dd>
<dt><strong><code>reparameterised_system_xml_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Reparameterized force field XML file obtained using
openforcefield.</dd>
<dt><strong><code>non_reparameterised_system_xml_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Non-reparameterized force field XML file obtained using
openforcefield.</dd>
<dt><strong><code>prmtop_system_non_params</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Amber generated topology file saved from the non-reparameterized
force field XML file for the ligand.</dd>
<dt><strong><code>inpcrd_system_non_params</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Amber generated coordinate file saved from the non-reparameterized
force field XML file for the ligand.</dd>
<dt><strong><code>prmtop_system_params</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Amber generated topology file saved from the reparameterized
force field XML file for the ligand.</dd>
<dt><strong><code>inpcrd_system_params</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Amber generated coordinate file saved from the reparameterized
force field XML file for the ligand.</dd>
<dt><strong><code>load_topology</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Argument to specify how to load the topology. Can either be "openmm"
or "parmed".</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>charge</code></strong> :&ensp;<code>int</code></dt>
<dd>Charge of the ligand.</dd>
<dt><strong><code>num_charge_atoms</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of charged atoms in the molecule.</dd>
<dt><strong><code>charge_atom_1</code></strong> :&ensp;<code>int</code></dt>
<dd>Charge on the first charged atom.</dd>
<dt><strong><code>index_charge_atom_1</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of the first charged atom.</dd>
<dt><strong><code>system_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ligand PDB file with atom numbers beginning from 1.</dd>
<dt><strong><code>system_mol2</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ligand Mol2 file obtained from PDB file.</dd>
<dt><strong><code>system_in</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Prepi file as required by antechamber.</dd>
<dt><strong><code>system_frcmod</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>FRCMOD file as required by antechamber.</dd>
<dt><strong><code>prmtop_system</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Topology file obtained from the ligand PDB.</dd>
<dt><strong><code>inpcrd_system</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Coordinate file obtained from the Ligand PDB using the
command saveamberparm.</dd>
<dt><strong><code>system_leap</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Amber generated leap file for generating and saving topology
and coordinate files.</dd>
<dt><strong><code>system_xml</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Serilazed XML force field file of the ligand.</dd>
<dt><strong><code>system_smi</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ligand SMILES format file.</dd>
<dt><strong><code>system_sdf</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ligand SDF (structure-data) format file.</dd>
<dt><strong><code>system_init_sdf</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ligand SDF (structure-data) format file. This file will be
generated only if the ligand is charged.</dd>
<dt><strong><code>index_charge_atom_2</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Index of the second charged atom of the ligand.</dd>
<dt><strong><code>charge_atom_2</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Charge on the second charged atom of the ligand.</dd>
<dt><strong><code>charge_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>File containing the charges of ligand atoms and their corresponding
atoms.</dd>
<dt><strong><code>system_qm_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ligand PDB file with atom numbers beginning from 1.</dd>
<dt><strong><code>bond_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the bond parameters for the ligand.</dd>
<dt><strong><code>angle_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the angle parameters of the ligand.</dd>
<dt><strong><code>system_qm_params_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A text file containing the QM obtained parameters for the
ligand.</dd>
<dt><strong><code>reparameterised_intermediate_system_xml_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>XML foce field file with bond and angle parameter lines replaced by
corresponding values obtained from the QM calculations.</dd>
<dt><strong><code>system_xml_non_bonded_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A text file to write the NonBondedForce Charge Parameters from
the non-parametrised system XML file.</dd>
<dt><strong><code>system_xml_non_bonded_reparams_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the non-bonded parameters parsed from the
XML force field file.</dd>
<dt><strong><code>reparameterised_system_xml_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Reparameterized force field XML file obtained using
openforcefield.</dd>
<dt><strong><code>non_reparameterised_system_xml_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Non-reparameterized force field XML file obtained using
openforcefield.</dd>
<dt><strong><code>prmtop_system_non_params</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Amber generated topology file saved from the non-reparameterized
force field XML file for the ligand.</dd>
<dt><strong><code>inpcrd_system_non_params</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Amber generated coordinate file saved from the non-reparameterized
force field XML file for the ligand.</dd>
<dt><strong><code>prmtop_system_params</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Amber generated topology file saved from the reparameterized
force field XML file for the ligand.</dd>
<dt><strong><code>inpcrd_system_params</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Amber generated coordinate file saved from the reparameterized
force field XML file for the ligand.</dd>
<dt><strong><code>load_topology</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Argument to specify how to load the topology. Can either be "openmm"
or "parmed".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GuestAmberXMLAmber:
    &#34;&#34;&#34;
    A class used to generate a template force field XML file for the ligand 
    in order regenerate the reparametrised forcefield XML file.

    This class contains methods to generate a template XML force field through 
    openforcefield. XML template generation can be obtained through different
    file formats such as PDB, SDF, and SMI. Methods support charged ligands as 
    well. Re-parameterized XML force field files are then generated from the 
    template files. Different energy components such as the bond, angle, 
    torsional and non-bonded energies are computed for the non-reparametrized 
    and the reparameterized force fields. Difference between the 
    non-reparameterized and reparameterized force field energies can then be 
    analyzed. 
    ...

    Attributes
    ----------
    charge : int
        Charge of the ligand. 

    num_charge_atoms: int
        Number of charged atoms in the molecule.

    charge_atom_1: int
        Charge on the first charged atom.

    index_charge_atom_1: int
        Index of the first charged atom.

    system_pdb: str, optional
        Ligand PDB file with atom numbers beginning from 1.

    system_mol2: str, optional
        Ligand Mol2 file obtained from PDB file.

    system_in: str, optional
        Prepi file as required by antechamber.

    system_frcmod: str, optional
        FRCMOD file as required by antechamber.

    prmtop_system : str, optional
        Topology file obtained from the ligand PDB.

    inpcrd_system : str, optional
        Coordinate file obtained from the Ligand PDB using the
        command saveamberparm.

    system_leap : str, optional
        Amber generated leap file for generating and saving topology 
        and coordinate files. 

    system_xml: str, optional
        Serialized XML force field file of the ligand.

    system_smi: str, optional
        Ligand SMILES format file. 

    system_sdf: str, optional
        Ligand SDF (structure-data) format file. 

    system_init_sdf: str, optional
        Ligand SDF (structure-data) format file. This file will be 
        generated only if the ligand is charged.

    index_charge_atom_2: int, optional
        Index of the second charged atom of the ligand.

    charge_atom_2: int, optional
        Charge on the second charged atom of the ligand.

    charge_parameter_file: str, optional
        File containing the charges of ligand atoms and their corresponding
        atoms.

    system_qm_pdb: str, optional
        Ligand PDB file with atom numbers beginning from 1.

    bond_parameter_file: str, optional
        Text file containing the bond parameters for the ligand.

    angle_parameter_file: str, optional
        Text file containing the angle parameters of the ligand.

    system_qm_params_file: str, optional
        A text file containing the QM obtained parameters for the 
        ligand. 

    reparameterised_intermediate_system_xml_file: str, optional
        XML foce field file with bond and angle parameter lines replaced by
        corresponding values obtained from the QM calculations.

    system_xml_non_bonded_file: str, optional
        A text file to write the NonBondedForce Charge Parameters from
        the non-parametrised system XML file.

    system_xml_non_bonded_reparams_file: str, optional
        Text file containing the non-bonded parameters parsed from the 
        XML force field file.

    reparameterised_system_xml_file: str, optional
        Reparameterized force field XML file obtained using 
        openforcefield.

    non_reparameterised_system_xml_file: str, optional
        Non-reparameterized force field XML file obtained using 
        openforcefield.

    prmtop_system_non_params: str, optional
        Amber generated topology file saved from the non-reparameterized 
        force field XML file for the ligand.

    inpcrd_system_non_params: str, optional
        Amber generated coordinate file saved from the non-reparameterized 
        force field XML file for the ligand.

    prmtop_system_params: str, optional
        Amber generated topology file saved from the reparameterized 
        force field XML file for the ligand.

    inpcrd_system_params: str, optional
        Amber generated coordinate file saved from the reparameterized 
        force field XML file for the ligand.

    load_topology: str, optional
        Argument to specify how to load the topology. Can either be &#34;openmm&#34;
        or &#34;parmed&#34;.

    &#34;&#34;&#34;

    def __init__(
        self,
        charge,
        num_charge_atoms,
        charge_atom_1,
        index_charge_atom_1,
        system_pdb=&#34;guest_init_II.pdb&#34;,
        system_mol2=&#34;guest.mol2&#34;,
        system_in=&#34;guest.in&#34;,
        system_frcmod=&#34;guest.frcmod&#34;,
        prmtop_system=&#34;guest.prmtop&#34;,
        inpcrd_system=&#34;guest.inpcrd&#34;,
        system_leap=&#34;guest.leap&#34;,
        system_xml=&#34;guest_init.xml&#34;,
        system_smi=&#34;guest.smi&#34;,
        system_sdf=&#34;guest.sdf&#34;,
        system_init_sdf=&#34;guest_init.sdf&#34;,
        index_charge_atom_2=&#34; &#34;,
        charge_atom_2=&#34; &#34;,
        charge_parameter_file=&#34;guest_charges.txt&#34;,
        system_qm_pdb=&#34;guest_init_II.pdb&#34;,
        bond_parameter_file=&#34;guest_bonds.txt&#34;,
        angle_parameter_file=&#34;guest_angles.txt&#34;,
        system_qm_params_file=&#34;guest_qm_params.txt&#34;,
        reparameterised_intermediate_system_xml_file=&#34;guest_intermediate_reparameterised.xml&#34;,
        system_xml_non_bonded_file=&#34;guest_xml_non_bonded.txt&#34;,
        system_xml_non_bonded_reparams_file=&#34;guest_xml_non_bonded_reparams.txt&#34;,
        reparameterised_system_xml_file=&#34;guest_reparameterised.xml&#34;,
        non_reparameterised_system_xml_file=&#34;guest_init.xml&#34;,
        prmtop_system_non_params=&#34;guest_non_params.prmtop&#34;,
        inpcrd_system_non_params=&#34;guest_non_params.inpcrd&#34;,
        prmtop_system_params=&#34;guest_params.prmtop&#34;,
        inpcrd_system_params=&#34;guest_params.inpcrd&#34;,
        load_topology=&#34;openmm&#34;,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        charge : int
            Charge of the ligand. 

        num_charge_atoms: int
            Number of charged atoms in the molecule.

        charge_atom_1: int
            Charge on the first charged atom.

        index_charge_atom_1: int
            Index of the first charged atom.

        system_pdb: str, optional
            Ligand PDB file with atom numbers beginning from 1.

        system_mol2: str, optional
            Ligand Mol2 file obtained from PDB file.

        system_in: str, optional
            Prepi file as required by antechamber.

        system_frcmod: str, optional
            FRCMOD file as required by antechamber.

        prmtop_system : str, optional
            Topology file obtained from the ligand PDB.

        inpcrd_system : str, optional
            Coordinate file obtained from the Ligand PDB using the
            command saveamberparm.

        system_leap : str, optional
            Amber generated leap file for generating and saving topology 
            and coordinate files. 

        system_xml: str, optional
            Serilazed XML force field file of the ligand.

        system_smi: str, optional
            Ligand SMILES format file. 

        system_sdf: str, optional
            Ligand SDF (structure-data) format file. 

        system_init_sdf: str, optional
            Ligand SDF (structure-data) format file. This file will be 
            generated only if the ligand is charged.

        index_charge_atom_2: int, optional
            Index of the second charged atom of the ligand.

        charge_atom_2: int, optional
            Charge on the second charged atom of the ligand.

        charge_parameter_file: str, optional
            File containing the charges of ligand atoms and their corresponding
            atoms.

        system_qm_pdb: str, optional
            Ligand PDB file with atom numbers beginning from 1.

        bond_parameter_file: str, optional
            Text file containing the bond parameters for the ligand.

        angle_parameter_file: str, optional
            Text file containing the angle parameters of the ligand.

        system_qm_params_file: str, optional
            A text file containing the QM obtained parameters for the 
            ligand. 

        reparameterised_intermediate_system_xml_file: str, optional
            XML foce field file with bond and angle parameter lines replaced by
            corresponding values obtained from the QM calculations.

        system_xml_non_bonded_file: str, optional
            A text file to write the NonBondedForce Charge Parameters from
            the non-parametrised system XML file.

        system_xml_non_bonded_reparams_file: str, optional
            Text file containing the non-bonded parameters parsed from the 
            XML force field file.

        reparameterised_system_xml_file: str, optional
            Reparameterized force field XML file obtained using 
            openforcefield.

        non_reparameterised_system_xml_file: str, optional
            Non-reparameterized force field XML file obtained using 
            openforcefield.

        prmtop_system_non_params: str, optional
            Amber generated topology file saved from the non-reparameterized 
            force field XML file for the ligand.

        inpcrd_system_non_params: str, optional
            Amber generated coordinate file saved from the non-reparameterized 
            force field XML file for the ligand.

        prmtop_system_params: str, optional
            Amber generated topology file saved from the reparameterized 
            force field XML file for the ligand.

        inpcrd_system_params: str, optional
            Amber generated coordinate file saved from the reparameterized 
            force field XML file for the ligand.

        load_topology: str, optional
            Argument to specify how to load the topology. Can either be &#34;openmm&#34;
            or &#34;parmed&#34;.

        &#34;&#34;&#34;
        self.charge = charge
        self.num_charge_atoms = num_charge_atoms
        self.charge_atom_1 = charge_atom_1
        self.index_charge_atom_1 = index_charge_atom_1
        self.system_pdb = system_pdb
        self.system_mol2 = system_mol2
        self.system_in = system_in
        self.system_frcmod = system_frcmod
        self.prmtop_system = prmtop_system
        self.inpcrd_system = inpcrd_system
        self.system_leap = system_leap
        self.system_xml = system_xml
        self.system_smi = system_smi
        self.system_sdf = system_sdf
        self.system_init_sdf = system_init_sdf
        self.index_charge_atom_2 = index_charge_atom_2
        self.charge_atom_2 = charge_atom_2
        self.charge_parameter_file = charge_parameter_file
        self.system_qm_pdb = system_qm_pdb
        self.bond_parameter_file = bond_parameter_file
        self.angle_parameter_file = angle_parameter_file
        self.system_qm_params_file = system_qm_params_file
        self.reparameterised_intermediate_system_xml_file = reparameterised_intermediate_system_xml_file
        self.system_xml_non_bonded_file = system_xml_non_bonded_file
        self.system_xml_non_bonded_reparams_file = system_xml_non_bonded_reparams_file
        self.reparameterised_system_xml_file = reparameterised_system_xml_file
        self.non_reparameterised_system_xml_file = non_reparameterised_system_xml_file
        self.prmtop_system_non_params = prmtop_system_non_params
        self.inpcrd_system_non_params = inpcrd_system_non_params
        self.prmtop_system_params = prmtop_system_params
        self.inpcrd_system_params = inpcrd_system_params
        self.load_topology = load_topology

    def generate_xml_antechamber(self):
        &#34;&#34;&#34;
        Generates an XML forcefield file from the PDB file through antechamber.
        &#34;&#34;&#34;
        command = (
            &#34;babel -ipdb &#34; + self.system_pdb + &#34; -omol2 &#34; + self.system_mol2
        )
        os.system(command)
        command = (
            &#34;antechamber -i &#34;
            + self.system_mol2
            + &#34; -fi mol2 -o &#34;
            + self.system_in
            + &#34; -fo prepi -c bcc -nc &#34;
            + str(self.charge)
        )
        os.system(command)
        command = (
            &#34;parmchk2 -i &#34;
            + self.system_in
            + &#34; -o &#34;
            + self.system_frcmod
            + &#34; -f prepi -a Y&#34;
        )
        os.system(command)
        os.system(
            &#34;rm -rf ANTECHAMBER* leap.log sqm* ATOMTYPE.INF PREP.INF NEWPDB.PDB&#34;
        )
        line_1 = &#34;loadamberprep &#34; + self.system_in
        line_2 = &#34;loadamberparams &#34; + self.system_frcmod
        line_3 = &#34;pdb = loadpdb &#34; + self.system_pdb
        line_4 = (
            &#34;saveamberparm pdb &#34;
            + self.prmtop_system
            + &#34; &#34;
            + self.inpcrd_system
        )
        line_5 = &#34;quit&#34;
        with open(self.system_leap, &#34;w&#34;) as f:
            f.write(&#34;    &#34; + &#34;\n&#34;)
            f.write(line_1 + &#34;\n&#34;)
            f.write(line_2 + &#34;\n&#34;)
            f.write(line_3 + &#34;\n&#34;)
            f.write(line_4 + &#34;\n&#34;)
            f.write(line_5 + &#34;\n&#34;)
        command = &#34;tleap -f &#34; + self.system_leap
        os.system(command)
        parm = parmed.load_file(self.prmtop_system, self.inpcrd_system)
        system = parm.createSystem()
        with open(self.system_xml, &#34;w&#34;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))

    def generate_xml_from_pdb_smi(self):
        &#34;&#34;&#34;
        Generates an XML forcefield file from the SMILES file through 
        openforcefield.
        &#34;&#34;&#34;
        off_molecule = openforcefield.topology.Molecule(self.system_smi)
        force_field = openforcefield.typing.engines.smirnoff.ForceField(
            &#34;openff_unconstrained-1.0.0.offxml&#34;
        )
        system = force_field.create_openmm_system(off_molecule.to_topology())
        pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
        structure = parmed.openmm.load_topology(
            pdbfile.topology, system, xyz=pdbfile.positions
        )
        with open(self.system_xml, &#34;w&#34;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))

    def generate_xml_from_pdb_sdf(self):
        &#34;&#34;&#34;
        Generates an XML forcefield file from the SDF file through 
        openforcefield.
        &#34;&#34;&#34;
        command = (
            &#34;babel -ipdb &#34; + self.system_pdb + &#34; -osdf &#34; + self.system_sdf
        )
        os.system(command)
        off_molecule = openforcefield.topology.Molecule(self.system_sdf)
        force_field = openforcefield.typing.engines.smirnoff.ForceField(
            &#34;openff_unconstrained-1.0.0.offxml&#34;
        )
        system = force_field.create_openmm_system(off_molecule.to_topology())
        pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
        structure = parmed.openmm.load_topology(
            pdbfile.topology, system, xyz=pdbfile.positions
        )
        with open(self.system_xml, &#34;w&#34;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))

    def generate_xml_from_charged_pdb_sdf(self):
        &#34;&#34;&#34;
        Generates an XML forcefield file for a singly charged ligand molecule 
        from the SDF file through openforcefield.
        &#34;&#34;&#34;
        command = (
            &#34;babel -ipdb &#34; + self.system_pdb + &#34; -osdf &#34; + self.system_init_sdf
        )
        os.system(command)
        with open(self.system_init_sdf, &#34;r&#34;) as f1:
            filedata = f1.readlines()
            filedata = filedata[:-2]
        with open(self.system_sdf, &#34;w+&#34;) as out:
            for i in filedata:
                out.write(i)
            line_1 = (
                &#34;M  CHG  &#34;
                + str(self.num_charge_atoms)
                + &#34;   &#34;
                + str(self.index_charge_atom_1)
                + &#34;   &#34;
                + str(self.charge_atom_1)
                + &#34;\n&#34;
            )
            line_2 = &#34;M  END&#34; + &#34;\n&#34;
            line_3 = &#34;$$$$&#34;
            out.write(line_1)
            out.write(line_2)
            out.write(line_3)
        off_molecule = openforcefield.topology.Molecule(self.system_sdf)
        force_field = openforcefield.typing.engines.smirnoff.ForceField(
            &#34;openff_unconstrained-1.0.0.offxml&#34;
        )
        system = force_field.create_openmm_system(off_molecule.to_topology())
        pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
        structure = parmed.openmm.load_topology(
            pdbfile.topology, system, xyz=pdbfile.positions
        )
        with open(self.system_xml, &#34;w&#34;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))

    def generate_xml_from_doubly_charged_pdb_sdf(self):
        &#34;&#34;&#34;
        Generates an XML forcefield file for a singly charged ligand molecule 
        from the SDF file through openforcefield.
        &#34;&#34;&#34;
        command = (
            &#34;babel -ipdb &#34; + self.system_pdb + &#34; -osdf &#34; + self.system_init_sdf
        )
        os.system(command)
        with open(self.system_init_sdf, &#34;r&#34;) as f1:
            filedata = f1.readlines()
            filedata = filedata[:-2]
        with open(self.system_sdf, &#34;w+&#34;) as out:
            for i in filedata:
                out.write(i)
            line_1 = (
                &#34;M  CHG  &#34;
                + str(self.num_charge_atoms)
                + &#34;   &#34;
                + str(self.index_charge_atom_1)
                + &#34;   &#34;
                + str(self.charge_atom_1)
                + &#34;   &#34;
                + str(self.index_charge_atom_2)
                + &#34;   &#34;
                + str(self.charge_atom_2)
                + &#34;\n&#34;
            )
            line_2 = &#34;M  END&#34; + &#34;\n&#34;
            line_3 = &#34;$$$$&#34;
            out.write(line_1)
            out.write(line_2)
            out.write(line_3)
        off_molecule = openforcefield.topology.Molecule(self.system_sdf)
        force_field = openforcefield.typing.engines.smirnoff.ForceField(
            &#34;openff_unconstrained-1.0.0.offxml&#34;
        )
        system = force_field.create_openmm_system(off_molecule.to_topology())
        pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
        structure = parmed.openmm.load_topology(
            pdbfile.topology, system, xyz=pdbfile.positions
        )
        with open(self.system_xml, &#34;w&#34;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))

    def write_system_params(self):
        &#34;&#34;&#34;
        Saves the parameters obtained from the QM log files in a text file.
        &#34;&#34;&#34;
        # Charges from QM files
        df_charges = pd.read_csv(
            self.charge_parameter_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df_charges.columns = [&#34;atom&#34;, &#34;charges&#34;]
        qm_charges = df_charges[&#34;charges&#34;].values.tolist()
        qm_charges = [round(num, 6) for num in qm_charges]
        # print(qm_charges)
        # Bond Parameters from QM files
        ppdb = PandasPdb()
        ppdb.read_pdb(self.system_qm_pdb)
        atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
        atom_name_list = [i - 1 for i in atom_name_list]
        # print(atom_name_list)
        df = pd.read_csv(
            self.bond_parameter_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df.columns = [&#34;bond&#34;, &#34;k_bond&#34;, &#34;bond_length&#34;, &#34;bond_1&#34;, &#34;bond_2&#34;]
        # print(df.head())
        bond_1_list = df[&#34;bond_1&#34;].values.tolist()
        bond_1_list = [x - 1 + min(atom_name_list) for x in bond_1_list]
        bond_2_list = df[&#34;bond_2&#34;].values.tolist()
        bond_2_list = [x - 1 + min(atom_name_list) for x in bond_2_list]
        # print(bond_1_list)
        # print(bond_2_list)
        k_bond_list = df[&#34;k_bond&#34;].values.tolist()
        k_bond_list = [i * 1000.00 for i in k_bond_list]
        k_bond_list = [round(num, 10) for num in k_bond_list]
        # print(k_bond_list)
        bond_length_list = df[&#34;bond_length&#34;].values.tolist()
        bond_length_list = [i / 10.00 for i in bond_length_list]
        bond_length_list = [round(num, 6) for num in bond_length_list]
        # print(bond_length_list)
        # Angle Parameters from QM files
        ppdb = PandasPdb()
        ppdb.read_pdb(self.system_qm_pdb)
        atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
        atom_name_list = [i - 1 for i in atom_name_list]
        # print(atom_name_list)
        df = pd.read_csv(
            self.angle_parameter_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df.columns = [
            &#34;angle&#34;,
            &#34;k_angle&#34;,
            &#34;angle_degrees&#34;,
            &#34;angle_1&#34;,
            &#34;angle_2&#34;,
            &#34;angle_3&#34;,
        ]
        # print(df.head())
        angle_1_list = df[&#34;angle_1&#34;].values.tolist()
        angle_1_list = [x - 1 + min(atom_name_list) for x in angle_1_list]
        # print(angle_1_list)
        angle_2_list = df[&#34;angle_2&#34;].values.tolist()
        angle_2_list = [x - 1 + min(atom_name_list) for x in angle_2_list]
        # print(angle_2_list)
        angle_3_list = df[&#34;angle_3&#34;].values.tolist()
        angle_3_list = [x - 1 + min(atom_name_list) for x in angle_3_list]
        # print(angle_3_list)
        k_angle_list = df[&#34;k_angle&#34;].values.tolist()
        k_angle_list = [round(num, 6) for num in k_angle_list]
        # print(k_angle_list)
        angle_list = df[&#34;angle_degrees&#34;].values.tolist()
        angle_list = [(i * math.pi) / 180.00 for i in angle_list]
        angle_list = [round(num, 6) for num in angle_list]
        # print(angle_list)
        xml = open(self.system_qm_params_file, &#34;w&#34;)
        xml.write(&#34;Begin writing the Bond Parameters&#34; + &#34;\n&#34;)
        for i in range(len(k_bond_list)):
            xml.write(
                &#34;                                &#34;
                + &#34;&lt;Bond&#34;
                + &#34; &#34;
                + &#34;d=&#34;
                + &#39;&#34;&#39;
                + str(bond_length_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;k=&#34;
                + &#39;&#34;&#39;
                + str(k_bond_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p1=&#34;
                + &#39;&#34;&#39;
                + str(bond_1_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + str(bond_2_list[i])
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
                + &#34;\n&#34;
            )
        xml.write(&#34;Finish writing the Bond Parameters&#34; + &#34;\n&#34;)
        xml.write(&#34;Begin writing the Angle Parameters&#34; + &#34;\n&#34;)
        for i in range(len(k_angle_list)):
            xml.write(
                &#34;                                &#34;
                + &#34;&lt;Angle&#34;
                + &#34; &#34;
                + &#34;a=&#34;
                + &#39;&#34;&#39;
                + str(angle_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;k=&#34;
                + &#39;&#34;&#39;
                + str(k_angle_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p1=&#34;
                + &#39;&#34;&#39;
                + str(angle_1_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + str(angle_2_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + str(angle_3_list[i])
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
                + &#34;\n&#34;
            )
        xml.write(&#34;Finish writing the Angle Parameters&#34; + &#34;\n&#34;)
        xml.write(&#34;Begin writing the Charge Parameters&#34; + &#34;\n&#34;)
        for i in range(len(qm_charges)):
            xml.write(
                &#34;&lt;Particle&#34;
                + &#34; &#34;
                + &#34;q=&#34;
                + &#39;&#34;&#39;
                + str(qm_charges[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;eps=&#34;
                + &#39;&#34;&#39;
                + str(0.00)
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;sig=&#34;
                + &#39;&#34;&#39;
                + str(0.00)
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;atom=&#34;
                + &#39;&#34;&#39;
                + str(atom_name_list[i])
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
                + &#34;\n&#34;
            )
        xml.write(&#34;Finish writing the Charge Parameters&#34; + &#34;\n&#34;)
        xml.close()

    def write_reparameterised_system_xml(self):
        &#34;&#34;&#34;
        Writes a reparameterised XML force field file for the ligand.
        &#34;&#34;&#34;
        # Bond Parameters
        f_params = open(self.system_qm_params_file, &#34;r&#34;)
        lines_params = f_params.readlines()
        # Bond Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Bond Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Bond Parameters&#34; in lines_params[i]:
                to_end = int(i)
        bond_params = lines_params[to_begin + 1 : to_end]
        index_search_replace_bond = []
        for i in bond_params:
            bond_line_to_replace = i
            # print(bond_line_to_replace)
            atom_number_list = [
                re.findall(&#34;\d*\.?\d+&#34;, i)[3],
                re.findall(&#34;\d*\.?\d+&#34;, i)[5],
            ]
            # print(atom_number_list)
            comb_1 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_2 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_list_bond = [comb_1, comb_2]
            # print(comb_list_bond)
            list_search_bond = [
                search_in_file(file=self.system_xml, word=comb_1),
                search_in_file(file=self.system_xml, word=comb_2),
            ]
            # print(list_search_bond)
            for j in range(len(list_search_bond)):
                if list_search_bond[j] != []:
                    to_add = (list_search_bond[j], i)
                    # print(to_add)
                    index_search_replace_bond.append(to_add)
        # Angle Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Angle Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Angle Parameters&#34; in lines_params[i]:
                to_end = int(i)
        angle_params = lines_params[to_begin + 1 : to_end]
        index_search_replace_angle = []
        for i in angle_params:
            angle_line_to_replace = i
            # print(angle_line_to_replace)
        index_search_replace_angle = []
        for i in angle_params:
            angle_line_to_replace = i
            # print(angle_line_to_replace)
            atom_number_list = [
                re.findall(&#34;\d*\.?\d+&#34;, i)[3],
                re.findall(&#34;\d*\.?\d+&#34;, i)[5],
                re.findall(&#34;\d*\.?\d+&#34;, i)[7],
            ]
            # print(atom_number_list)
            comb_1 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_2 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_3 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_4 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_5 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_6 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_list_angle = [comb_1, comb_2, comb_3, comb_4, comb_5, comb_6]
            # print(comb_list_angle)
            list_search_angle = [
                search_in_file(file=self.system_xml, word=comb_1),
                search_in_file(file=self.system_xml, word=comb_2),
                search_in_file(file=self.system_xml, word=comb_3),
                search_in_file(file=self.system_xml, word=comb_4),
                search_in_file(file=self.system_xml, word=comb_5),
                search_in_file(file=self.system_xml, word=comb_6),
            ]
            # print(list_search_angle)
            for j in range(len(list_search_angle)):
                if list_search_angle[j] != []:
                    to_add = (list_search_angle[j], i)
                    # print(to_add)
                    index_search_replace_angle.append(to_add)
        f_org = open(self.system_xml)
        lines = f_org.readlines()
        for i in range(len(index_search_replace_bond)):
            line_number = index_search_replace_bond[i][0][0][0] - 1
            line_to_replace = index_search_replace_bond[i][0][0][1]
            line_to_replace_with = index_search_replace_bond[i][1]
            lines[line_number] = line_to_replace_with
        for i in range(len(index_search_replace_angle)):
            line_number = index_search_replace_angle[i][0][0][0] - 1
            line_to_replace = index_search_replace_angle[i][0][0][1]
            line_to_replace_with = index_search_replace_angle[i][1]
            lines[line_number] = line_to_replace_with
        f_cop = open(self.reparameterised_intermediate_system_xml_file, &#34;w&#34;)
        for i in lines:
            f_cop.write(i)
        f_cop.close()

        f_params = open(self.system_qm_params_file)
        lines_params = f_params.readlines()
        # Charge Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Charge Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Charge Parameters&#34; in lines_params[i]:
                to_end = int(i)
        charge_params = lines_params[to_begin + 1 : to_end]
        non_bonded_index = []
        for k in charge_params:
            non_bonded_index.append(int(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, k)[3]))
        charge_for_index = []
        for k in charge_params:
            charge_for_index.append(
                float(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, k)[0])
            )

        xml_off = open(self.system_xml)
        xml_off_lines = xml_off.readlines()
        for i in range(len(xml_off_lines)):
            if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
                to_begin = int(i)
            if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
                to_end = int(i)
        nonbond_params = xml_off_lines[to_begin + 4 : to_end - 1]
        # print(len(nonbond_params))
        f_non_bonded = open(self.system_xml_non_bonded_file, &#34;w&#34;)
        for x in nonbond_params:
            f_non_bonded.write(x)

        f_non_bonded = open(self.system_xml_non_bonded_file)
        lines_non_bonded = f_non_bonded.readlines()
        # print(len(lines_non_bonded))
        lines_non_bonded_to_write = []
        for i in range(len(non_bonded_index)):
            line_ = lines_non_bonded[non_bonded_index[i]]
            # print(line_)
            eps = float(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, line_)[0])
            sig = float(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, line_)[2])
            line_to_replace = (
                &#34;                                &#34;
                + &#34;&lt;Particle &#34;
                + &#34;eps=&#34;
                + &#39;&#34;&#39;
                + str(eps)
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;q=&#34;
                + &#39;&#34;&#39;
                + str(charge_for_index[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;sig=&#34;
                + &#39;&#34;&#39;
                + str(sig)
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            lines_non_bonded_to_write.append(line_to_replace)
        data_ = list(zip(non_bonded_index, lines_non_bonded_to_write))

        df_non_bonded_params = pd.DataFrame(
            data_, columns=[&#34;line_index&#34;, &#34;line&#34;]
        )
        # print(df_non_bonded_params.head())
        f_non_bonded_ = open(self.system_xml_non_bonded_file)
        lines_non_bonded_ = f_non_bonded_.readlines()
        for i in range(len(lines_non_bonded_)):
            if i in non_bonded_index:
                lines_non_bonded_[i] = (
                    df_non_bonded_params.loc[
                        df_non_bonded_params.line_index == i, &#34;line&#34;
                    ].values[0]
                ) + &#34;\n&#34;
        # print(len(lines_non_bonded_))
        f_write_non_bonded_reparams = open(
            self.system_xml_non_bonded_reparams_file, &#34;w&#34;
        )
        for p in range(len(lines_non_bonded_)):
            f_write_non_bonded_reparams.write(lines_non_bonded_[p])
        f_write_non_bonded_reparams.close()
        f_ = open(self.system_xml_non_bonded_reparams_file)
        lines_ = f_.readlines()
        print(len(lines_) == len(lines_non_bonded))

        xml_off = open(self.reparameterised_intermediate_system_xml_file)
        xml_off_lines = xml_off.readlines()
        for i in range(len(xml_off_lines)):
            if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
                to_begin = int(i)
            if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
                to_end = int(i)

        lines_before_params = xml_off_lines[: to_begin + 4]
        f__ = open(self.system_xml_non_bonded_reparams_file)
        lines_params_non_bonded = f__.readlines()
        lines_after_params = xml_off_lines[to_end - 1 :]
        f_reparams_xml = open(self.reparameterised_system_xml_file, &#34;w&#34;)
        for x in lines_before_params:
            f_reparams_xml.write(x)
        for x in lines_params_non_bonded:
            f_reparams_xml.write(x)
        for x in lines_after_params:
            f_reparams_xml.write(x)
        f_reparams_xml.close()

    def save_amber_params(self):
        &#34;&#34;&#34;
        Saves amber generated topology files for the ligand.
        &#34;&#34;&#34;
        if self.load_topology == &#34;parmed&#34;:
            openmm_system = parmed.openmm.load_topology(
                parmed.load_file(self.system_pdb, structure=True).topology,
                parmed.load_file(self.non_reparameterised_system_xml_file),
            )
        if self.load_topology == &#34;openmm&#34;:
            openmm_system = parmed.openmm.load_topology(
                simtk.openmm.app.PDBFile(self.system_pdb).topology,
                parmed.load_file(self.non_reparameterised_system_xml_file),
            )
        openmm_system.save(self.prmtop_system_non_params, overwrite=True)
        openmm_system.coordinates = parmed.load_file(
            self.system_pdb, structure=True
        ).coordinates
        openmm_system.save(self.inpcrd_system_non_params, overwrite=True)
        parm = parmed.load_file(
            self.prmtop_system_non_params, self.inpcrd_system_non_params
        )

        xml_energy_decomposition = parmed.openmm.energy_decomposition_system(
            openmm_system,
            parmed.load_file(self.non_reparameterised_system_xml_file),
        )
        xml_energy_decomposition_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        xml_energy_decomposition_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_xml = pd.DataFrame(
            list(
                zip(
                    xml_energy_decomposition_list,
                    xml_energy_decomposition_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_xml_non_params&#34;],
        )
        df_energy_xml = df_energy_xml.set_index(&#34;Energy_term&#34;)

        prmtop_energy_decomposition = (
            parmed.openmm.energy_decomposition_system(
                parm, parm.createSystem()
            )
        )
        prmtop_energy_decomposition_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        prmtop_energy_decomposition_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_prmtop = pd.DataFrame(
            list(
                zip(
                    prmtop_energy_decomposition_list,
                    prmtop_energy_decomposition_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_prmtop_non_params&#34;],
        )
        df_energy_prmtop = df_energy_prmtop.set_index(&#34;Energy_term&#34;)

        df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
        print(df_compare)

        if self.load_topology == &#34;parmed&#34;:
            openmm_system = parmed.openmm.load_topology(
                parmed.load_file(self.system_pdb, structure=True).topology,
                parmed.load_file(self.reparameterised_system_xml_file),
            )
        if self.load_topology == &#34;openmm&#34;:
            openmm_system = parmed.openmm.load_topology(
                simtk.openmm.app.PDBFile(self.system_pdb).topology,
                parmed.load_file(self.reparameterised_system_xml_file),
            )
        openmm_system.save(self.prmtop_system_params, overwrite=True)
        openmm_system.coordinates = parmed.load_file(
            self.system_pdb, structure=True
        ).coordinates
        openmm_system.save(self.inpcrd_system_params, overwrite=True)
        parm = parmed.load_file(
            self.prmtop_system_params, self.inpcrd_system_params
        )

        xml_energy_decomposition = parmed.openmm.energy_decomposition_system(
            openmm_system,
            parmed.load_file(self.reparameterised_system_xml_file),
        )
        xml_energy_decomposition_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        xml_energy_decomposition_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_xml = pd.DataFrame(
            list(
                zip(
                    xml_energy_decomposition_list,
                    xml_energy_decomposition_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_xml_params&#34;],
        )
        df_energy_xml = df_energy_xml.set_index(&#34;Energy_term&#34;)

        prmtop_energy_decomposition = (
            parmed.openmm.energy_decomposition_system(
                parm, parm.createSystem()
            )
        )
        prmtop_energy_decomposition_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        prmtop_energy_decomposition_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_prmtop = pd.DataFrame(
            list(
                zip(
                    prmtop_energy_decomposition_list,
                    prmtop_energy_decomposition_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_prmtop_params&#34;],
        )
        df_energy_prmtop = df_energy_prmtop.set_index(&#34;Energy_term&#34;)

        df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
        print(df_compare)

    def analyze_diff_energies(self):
        &#34;&#34;&#34;
        Compares the energies of the ligand obtained from the non-parameterized 
        and the parameterized force field files.
        &#34;&#34;&#34;
        parm_non_params = parmed.load_file(
            self.prmtop_system_non_params, self.inpcrd_system_non_params
        )
        prmtop_energy_decomposition_non_params = (
            parmed.openmm.energy_decomposition_system(
                parm_non_params, parm_non_params.createSystem()
            )
        )
        prmtop_energy_decomposition_non_params_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_non_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_non_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_non_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_non_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        prmtop_energy_decomposition_non_params_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_non_params = pd.DataFrame(
            list(
                zip(
                    prmtop_energy_decomposition_non_params_list,
                    prmtop_energy_decomposition_non_params_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_parm_non_params&#34;],
        )
        df_energy_non_params = df_energy_non_params.set_index(&#34;Energy_term&#34;)
        # print(df_energy_non_params)
        parm_params = parmed.load_file(
            self.prmtop_system_params, self.inpcrd_system_params
        )
        prmtop_energy_decomposition_params = (
            parmed.openmm.energy_decomposition_system(
                parm_params, parm_params.createSystem()
            )
        )
        prmtop_energy_decomposition_params_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        prmtop_energy_decomposition_params_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_params = pd.DataFrame(
            list(
                zip(
                    prmtop_energy_decomposition_params_list,
                    prmtop_energy_decomposition_params_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_parm_params&#34;],
        )
        df_energy_params = df_energy_params.set_index(&#34;Energy_term&#34;)
        # print(df_energy_params)
        df_compare = pd.concat(
            [df_energy_non_params, df_energy_params], axis=1
        )
        df_compare[&#34;Energy_difference&#34;] = df_compare[
            &#34;Energy_parm_non_params&#34;
        ].sub(df_compare[&#34;Energy_parm_params&#34;], axis=0)
        print(df_compare)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.GuestAmberXMLAmber.analyze_diff_energies"><code class="name flex">
<span>def <span class="ident">analyze_diff_energies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compares the energies of the ligand obtained from the non-parameterized
and the parameterized force field files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analyze_diff_energies(self):
    &#34;&#34;&#34;
    Compares the energies of the ligand obtained from the non-parameterized 
    and the parameterized force field files.
    &#34;&#34;&#34;
    parm_non_params = parmed.load_file(
        self.prmtop_system_non_params, self.inpcrd_system_non_params
    )
    prmtop_energy_decomposition_non_params = (
        parmed.openmm.energy_decomposition_system(
            parm_non_params, parm_non_params.createSystem()
        )
    )
    prmtop_energy_decomposition_non_params_value = [
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem)
                    for elem in prmtop_energy_decomposition_non_params
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicBondForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem)
                    for elem in prmtop_energy_decomposition_non_params
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicAngleForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem)
                    for elem in prmtop_energy_decomposition_non_params
                ]
                for item in sublist
            ]
        ).get(&#34;PeriodicTorsionForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem)
                    for elem in prmtop_energy_decomposition_non_params
                ]
                for item in sublist
            ]
        ).get(&#34;NonbondedForce&#34;),
    ]
    prmtop_energy_decomposition_non_params_list = [
        &#34;HarmonicBondForce&#34;,
        &#34;HarmonicAngleForce&#34;,
        &#34;PeriodicTorsionForce&#34;,
        &#34;NonbondedForce&#34;,
    ]
    df_energy_non_params = pd.DataFrame(
        list(
            zip(
                prmtop_energy_decomposition_non_params_list,
                prmtop_energy_decomposition_non_params_value,
            )
        ),
        columns=[&#34;Energy_term&#34;, &#34;Energy_parm_non_params&#34;],
    )
    df_energy_non_params = df_energy_non_params.set_index(&#34;Energy_term&#34;)
    # print(df_energy_non_params)
    parm_params = parmed.load_file(
        self.prmtop_system_params, self.inpcrd_system_params
    )
    prmtop_energy_decomposition_params = (
        parmed.openmm.energy_decomposition_system(
            parm_params, parm_params.createSystem()
        )
    )
    prmtop_energy_decomposition_params_value = [
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem)
                    for elem in prmtop_energy_decomposition_params
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicBondForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem)
                    for elem in prmtop_energy_decomposition_params
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicAngleForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem)
                    for elem in prmtop_energy_decomposition_params
                ]
                for item in sublist
            ]
        ).get(&#34;PeriodicTorsionForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem)
                    for elem in prmtop_energy_decomposition_params
                ]
                for item in sublist
            ]
        ).get(&#34;NonbondedForce&#34;),
    ]
    prmtop_energy_decomposition_params_list = [
        &#34;HarmonicBondForce&#34;,
        &#34;HarmonicAngleForce&#34;,
        &#34;PeriodicTorsionForce&#34;,
        &#34;NonbondedForce&#34;,
    ]
    df_energy_params = pd.DataFrame(
        list(
            zip(
                prmtop_energy_decomposition_params_list,
                prmtop_energy_decomposition_params_value,
            )
        ),
        columns=[&#34;Energy_term&#34;, &#34;Energy_parm_params&#34;],
    )
    df_energy_params = df_energy_params.set_index(&#34;Energy_term&#34;)
    # print(df_energy_params)
    df_compare = pd.concat(
        [df_energy_non_params, df_energy_params], axis=1
    )
    df_compare[&#34;Energy_difference&#34;] = df_compare[
        &#34;Energy_parm_non_params&#34;
    ].sub(df_compare[&#34;Energy_parm_params&#34;], axis=0)
    print(df_compare)</code></pre>
</details>
</dd>
<dt id="parameterize.GuestAmberXMLAmber.generate_xml_antechamber"><code class="name flex">
<span>def <span class="ident">generate_xml_antechamber</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates an XML forcefield file from the PDB file through antechamber.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_xml_antechamber(self):
    &#34;&#34;&#34;
    Generates an XML forcefield file from the PDB file through antechamber.
    &#34;&#34;&#34;
    command = (
        &#34;babel -ipdb &#34; + self.system_pdb + &#34; -omol2 &#34; + self.system_mol2
    )
    os.system(command)
    command = (
        &#34;antechamber -i &#34;
        + self.system_mol2
        + &#34; -fi mol2 -o &#34;
        + self.system_in
        + &#34; -fo prepi -c bcc -nc &#34;
        + str(self.charge)
    )
    os.system(command)
    command = (
        &#34;parmchk2 -i &#34;
        + self.system_in
        + &#34; -o &#34;
        + self.system_frcmod
        + &#34; -f prepi -a Y&#34;
    )
    os.system(command)
    os.system(
        &#34;rm -rf ANTECHAMBER* leap.log sqm* ATOMTYPE.INF PREP.INF NEWPDB.PDB&#34;
    )
    line_1 = &#34;loadamberprep &#34; + self.system_in
    line_2 = &#34;loadamberparams &#34; + self.system_frcmod
    line_3 = &#34;pdb = loadpdb &#34; + self.system_pdb
    line_4 = (
        &#34;saveamberparm pdb &#34;
        + self.prmtop_system
        + &#34; &#34;
        + self.inpcrd_system
    )
    line_5 = &#34;quit&#34;
    with open(self.system_leap, &#34;w&#34;) as f:
        f.write(&#34;    &#34; + &#34;\n&#34;)
        f.write(line_1 + &#34;\n&#34;)
        f.write(line_2 + &#34;\n&#34;)
        f.write(line_3 + &#34;\n&#34;)
        f.write(line_4 + &#34;\n&#34;)
        f.write(line_5 + &#34;\n&#34;)
    command = &#34;tleap -f &#34; + self.system_leap
    os.system(command)
    parm = parmed.load_file(self.prmtop_system, self.inpcrd_system)
    system = parm.createSystem()
    with open(self.system_xml, &#34;w&#34;) as f:
        f.write(simtk.openmm.XmlSerializer.serialize(system))</code></pre>
</details>
</dd>
<dt id="parameterize.GuestAmberXMLAmber.generate_xml_from_charged_pdb_sdf"><code class="name flex">
<span>def <span class="ident">generate_xml_from_charged_pdb_sdf</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates an XML forcefield file for a singly charged ligand molecule
from the SDF file through openforcefield.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_xml_from_charged_pdb_sdf(self):
    &#34;&#34;&#34;
    Generates an XML forcefield file for a singly charged ligand molecule 
    from the SDF file through openforcefield.
    &#34;&#34;&#34;
    command = (
        &#34;babel -ipdb &#34; + self.system_pdb + &#34; -osdf &#34; + self.system_init_sdf
    )
    os.system(command)
    with open(self.system_init_sdf, &#34;r&#34;) as f1:
        filedata = f1.readlines()
        filedata = filedata[:-2]
    with open(self.system_sdf, &#34;w+&#34;) as out:
        for i in filedata:
            out.write(i)
        line_1 = (
            &#34;M  CHG  &#34;
            + str(self.num_charge_atoms)
            + &#34;   &#34;
            + str(self.index_charge_atom_1)
            + &#34;   &#34;
            + str(self.charge_atom_1)
            + &#34;\n&#34;
        )
        line_2 = &#34;M  END&#34; + &#34;\n&#34;
        line_3 = &#34;$$$$&#34;
        out.write(line_1)
        out.write(line_2)
        out.write(line_3)
    off_molecule = openforcefield.topology.Molecule(self.system_sdf)
    force_field = openforcefield.typing.engines.smirnoff.ForceField(
        &#34;openff_unconstrained-1.0.0.offxml&#34;
    )
    system = force_field.create_openmm_system(off_molecule.to_topology())
    pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
    structure = parmed.openmm.load_topology(
        pdbfile.topology, system, xyz=pdbfile.positions
    )
    with open(self.system_xml, &#34;w&#34;) as f:
        f.write(simtk.openmm.XmlSerializer.serialize(system))</code></pre>
</details>
</dd>
<dt id="parameterize.GuestAmberXMLAmber.generate_xml_from_doubly_charged_pdb_sdf"><code class="name flex">
<span>def <span class="ident">generate_xml_from_doubly_charged_pdb_sdf</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates an XML forcefield file for a singly charged ligand molecule
from the SDF file through openforcefield.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_xml_from_doubly_charged_pdb_sdf(self):
    &#34;&#34;&#34;
    Generates an XML forcefield file for a singly charged ligand molecule 
    from the SDF file through openforcefield.
    &#34;&#34;&#34;
    command = (
        &#34;babel -ipdb &#34; + self.system_pdb + &#34; -osdf &#34; + self.system_init_sdf
    )
    os.system(command)
    with open(self.system_init_sdf, &#34;r&#34;) as f1:
        filedata = f1.readlines()
        filedata = filedata[:-2]
    with open(self.system_sdf, &#34;w+&#34;) as out:
        for i in filedata:
            out.write(i)
        line_1 = (
            &#34;M  CHG  &#34;
            + str(self.num_charge_atoms)
            + &#34;   &#34;
            + str(self.index_charge_atom_1)
            + &#34;   &#34;
            + str(self.charge_atom_1)
            + &#34;   &#34;
            + str(self.index_charge_atom_2)
            + &#34;   &#34;
            + str(self.charge_atom_2)
            + &#34;\n&#34;
        )
        line_2 = &#34;M  END&#34; + &#34;\n&#34;
        line_3 = &#34;$$$$&#34;
        out.write(line_1)
        out.write(line_2)
        out.write(line_3)
    off_molecule = openforcefield.topology.Molecule(self.system_sdf)
    force_field = openforcefield.typing.engines.smirnoff.ForceField(
        &#34;openff_unconstrained-1.0.0.offxml&#34;
    )
    system = force_field.create_openmm_system(off_molecule.to_topology())
    pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
    structure = parmed.openmm.load_topology(
        pdbfile.topology, system, xyz=pdbfile.positions
    )
    with open(self.system_xml, &#34;w&#34;) as f:
        f.write(simtk.openmm.XmlSerializer.serialize(system))</code></pre>
</details>
</dd>
<dt id="parameterize.GuestAmberXMLAmber.generate_xml_from_pdb_sdf"><code class="name flex">
<span>def <span class="ident">generate_xml_from_pdb_sdf</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates an XML forcefield file from the SDF file through
openforcefield.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_xml_from_pdb_sdf(self):
    &#34;&#34;&#34;
    Generates an XML forcefield file from the SDF file through 
    openforcefield.
    &#34;&#34;&#34;
    command = (
        &#34;babel -ipdb &#34; + self.system_pdb + &#34; -osdf &#34; + self.system_sdf
    )
    os.system(command)
    off_molecule = openforcefield.topology.Molecule(self.system_sdf)
    force_field = openforcefield.typing.engines.smirnoff.ForceField(
        &#34;openff_unconstrained-1.0.0.offxml&#34;
    )
    system = force_field.create_openmm_system(off_molecule.to_topology())
    pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
    structure = parmed.openmm.load_topology(
        pdbfile.topology, system, xyz=pdbfile.positions
    )
    with open(self.system_xml, &#34;w&#34;) as f:
        f.write(simtk.openmm.XmlSerializer.serialize(system))</code></pre>
</details>
</dd>
<dt id="parameterize.GuestAmberXMLAmber.generate_xml_from_pdb_smi"><code class="name flex">
<span>def <span class="ident">generate_xml_from_pdb_smi</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates an XML forcefield file from the SMILES file through
openforcefield.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_xml_from_pdb_smi(self):
    &#34;&#34;&#34;
    Generates an XML forcefield file from the SMILES file through 
    openforcefield.
    &#34;&#34;&#34;
    off_molecule = openforcefield.topology.Molecule(self.system_smi)
    force_field = openforcefield.typing.engines.smirnoff.ForceField(
        &#34;openff_unconstrained-1.0.0.offxml&#34;
    )
    system = force_field.create_openmm_system(off_molecule.to_topology())
    pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
    structure = parmed.openmm.load_topology(
        pdbfile.topology, system, xyz=pdbfile.positions
    )
    with open(self.system_xml, &#34;w&#34;) as f:
        f.write(simtk.openmm.XmlSerializer.serialize(system))</code></pre>
</details>
</dd>
<dt id="parameterize.GuestAmberXMLAmber.save_amber_params"><code class="name flex">
<span>def <span class="ident">save_amber_params</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves amber generated topology files for the ligand.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_amber_params(self):
    &#34;&#34;&#34;
    Saves amber generated topology files for the ligand.
    &#34;&#34;&#34;
    if self.load_topology == &#34;parmed&#34;:
        openmm_system = parmed.openmm.load_topology(
            parmed.load_file(self.system_pdb, structure=True).topology,
            parmed.load_file(self.non_reparameterised_system_xml_file),
        )
    if self.load_topology == &#34;openmm&#34;:
        openmm_system = parmed.openmm.load_topology(
            simtk.openmm.app.PDBFile(self.system_pdb).topology,
            parmed.load_file(self.non_reparameterised_system_xml_file),
        )
    openmm_system.save(self.prmtop_system_non_params, overwrite=True)
    openmm_system.coordinates = parmed.load_file(
        self.system_pdb, structure=True
    ).coordinates
    openmm_system.save(self.inpcrd_system_non_params, overwrite=True)
    parm = parmed.load_file(
        self.prmtop_system_non_params, self.inpcrd_system_non_params
    )

    xml_energy_decomposition = parmed.openmm.energy_decomposition_system(
        openmm_system,
        parmed.load_file(self.non_reparameterised_system_xml_file),
    )
    xml_energy_decomposition_value = [
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in xml_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicBondForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in xml_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicAngleForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in xml_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;PeriodicTorsionForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in xml_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;NonbondedForce&#34;),
    ]
    xml_energy_decomposition_list = [
        &#34;HarmonicBondForce&#34;,
        &#34;HarmonicAngleForce&#34;,
        &#34;PeriodicTorsionForce&#34;,
        &#34;NonbondedForce&#34;,
    ]
    df_energy_xml = pd.DataFrame(
        list(
            zip(
                xml_energy_decomposition_list,
                xml_energy_decomposition_value,
            )
        ),
        columns=[&#34;Energy_term&#34;, &#34;Energy_xml_non_params&#34;],
    )
    df_energy_xml = df_energy_xml.set_index(&#34;Energy_term&#34;)

    prmtop_energy_decomposition = (
        parmed.openmm.energy_decomposition_system(
            parm, parm.createSystem()
        )
    )
    prmtop_energy_decomposition_value = [
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicBondForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicAngleForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;PeriodicTorsionForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;NonbondedForce&#34;),
    ]
    prmtop_energy_decomposition_list = [
        &#34;HarmonicBondForce&#34;,
        &#34;HarmonicAngleForce&#34;,
        &#34;PeriodicTorsionForce&#34;,
        &#34;NonbondedForce&#34;,
    ]
    df_energy_prmtop = pd.DataFrame(
        list(
            zip(
                prmtop_energy_decomposition_list,
                prmtop_energy_decomposition_value,
            )
        ),
        columns=[&#34;Energy_term&#34;, &#34;Energy_prmtop_non_params&#34;],
    )
    df_energy_prmtop = df_energy_prmtop.set_index(&#34;Energy_term&#34;)

    df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
    print(df_compare)

    if self.load_topology == &#34;parmed&#34;:
        openmm_system = parmed.openmm.load_topology(
            parmed.load_file(self.system_pdb, structure=True).topology,
            parmed.load_file(self.reparameterised_system_xml_file),
        )
    if self.load_topology == &#34;openmm&#34;:
        openmm_system = parmed.openmm.load_topology(
            simtk.openmm.app.PDBFile(self.system_pdb).topology,
            parmed.load_file(self.reparameterised_system_xml_file),
        )
    openmm_system.save(self.prmtop_system_params, overwrite=True)
    openmm_system.coordinates = parmed.load_file(
        self.system_pdb, structure=True
    ).coordinates
    openmm_system.save(self.inpcrd_system_params, overwrite=True)
    parm = parmed.load_file(
        self.prmtop_system_params, self.inpcrd_system_params
    )

    xml_energy_decomposition = parmed.openmm.energy_decomposition_system(
        openmm_system,
        parmed.load_file(self.reparameterised_system_xml_file),
    )
    xml_energy_decomposition_value = [
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in xml_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicBondForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in xml_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicAngleForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in xml_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;PeriodicTorsionForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in xml_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;NonbondedForce&#34;),
    ]
    xml_energy_decomposition_list = [
        &#34;HarmonicBondForce&#34;,
        &#34;HarmonicAngleForce&#34;,
        &#34;PeriodicTorsionForce&#34;,
        &#34;NonbondedForce&#34;,
    ]
    df_energy_xml = pd.DataFrame(
        list(
            zip(
                xml_energy_decomposition_list,
                xml_energy_decomposition_value,
            )
        ),
        columns=[&#34;Energy_term&#34;, &#34;Energy_xml_params&#34;],
    )
    df_energy_xml = df_energy_xml.set_index(&#34;Energy_term&#34;)

    prmtop_energy_decomposition = (
        parmed.openmm.energy_decomposition_system(
            parm, parm.createSystem()
        )
    )
    prmtop_energy_decomposition_value = [
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicBondForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicAngleForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;PeriodicTorsionForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;NonbondedForce&#34;),
    ]
    prmtop_energy_decomposition_list = [
        &#34;HarmonicBondForce&#34;,
        &#34;HarmonicAngleForce&#34;,
        &#34;PeriodicTorsionForce&#34;,
        &#34;NonbondedForce&#34;,
    ]
    df_energy_prmtop = pd.DataFrame(
        list(
            zip(
                prmtop_energy_decomposition_list,
                prmtop_energy_decomposition_value,
            )
        ),
        columns=[&#34;Energy_term&#34;, &#34;Energy_prmtop_params&#34;],
    )
    df_energy_prmtop = df_energy_prmtop.set_index(&#34;Energy_term&#34;)

    df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
    print(df_compare)</code></pre>
</details>
</dd>
<dt id="parameterize.GuestAmberXMLAmber.write_reparameterised_system_xml"><code class="name flex">
<span>def <span class="ident">write_reparameterised_system_xml</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes a reparameterised XML force field file for the ligand.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_reparameterised_system_xml(self):
    &#34;&#34;&#34;
    Writes a reparameterised XML force field file for the ligand.
    &#34;&#34;&#34;
    # Bond Parameters
    f_params = open(self.system_qm_params_file, &#34;r&#34;)
    lines_params = f_params.readlines()
    # Bond Parameters
    for i in range(len(lines_params)):
        if &#34;Begin writing the Bond Parameters&#34; in lines_params[i]:
            to_begin = int(i)
        if &#34;Finish writing the Bond Parameters&#34; in lines_params[i]:
            to_end = int(i)
    bond_params = lines_params[to_begin + 1 : to_end]
    index_search_replace_bond = []
    for i in bond_params:
        bond_line_to_replace = i
        # print(bond_line_to_replace)
        atom_number_list = [
            re.findall(&#34;\d*\.?\d+&#34;, i)[3],
            re.findall(&#34;\d*\.?\d+&#34;, i)[5],
        ]
        # print(atom_number_list)
        comb_1 = (
            &#34;p1=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[0]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p2=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[1]
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
        )
        comb_2 = (
            &#34;p1=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[1]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p2=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[0]
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
        )
        comb_list_bond = [comb_1, comb_2]
        # print(comb_list_bond)
        list_search_bond = [
            search_in_file(file=self.system_xml, word=comb_1),
            search_in_file(file=self.system_xml, word=comb_2),
        ]
        # print(list_search_bond)
        for j in range(len(list_search_bond)):
            if list_search_bond[j] != []:
                to_add = (list_search_bond[j], i)
                # print(to_add)
                index_search_replace_bond.append(to_add)
    # Angle Parameters
    for i in range(len(lines_params)):
        if &#34;Begin writing the Angle Parameters&#34; in lines_params[i]:
            to_begin = int(i)
        if &#34;Finish writing the Angle Parameters&#34; in lines_params[i]:
            to_end = int(i)
    angle_params = lines_params[to_begin + 1 : to_end]
    index_search_replace_angle = []
    for i in angle_params:
        angle_line_to_replace = i
        # print(angle_line_to_replace)
    index_search_replace_angle = []
    for i in angle_params:
        angle_line_to_replace = i
        # print(angle_line_to_replace)
        atom_number_list = [
            re.findall(&#34;\d*\.?\d+&#34;, i)[3],
            re.findall(&#34;\d*\.?\d+&#34;, i)[5],
            re.findall(&#34;\d*\.?\d+&#34;, i)[7],
        ]
        # print(atom_number_list)
        comb_1 = (
            &#34;p1=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[0]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p2=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[1]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p3=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[2]
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
        )
        comb_2 = (
            &#34;p1=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[0]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p2=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[2]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p3=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[1]
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
        )
        comb_3 = (
            &#34;p1=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[1]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p2=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[0]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p3=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[2]
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
        )
        comb_4 = (
            &#34;p1=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[1]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p2=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[2]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p3=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[0]
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
        )
        comb_5 = (
            &#34;p1=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[2]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p2=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[0]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p3=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[1]
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
        )
        comb_6 = (
            &#34;p1=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[2]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p2=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[1]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p3=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[0]
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
        )
        comb_list_angle = [comb_1, comb_2, comb_3, comb_4, comb_5, comb_6]
        # print(comb_list_angle)
        list_search_angle = [
            search_in_file(file=self.system_xml, word=comb_1),
            search_in_file(file=self.system_xml, word=comb_2),
            search_in_file(file=self.system_xml, word=comb_3),
            search_in_file(file=self.system_xml, word=comb_4),
            search_in_file(file=self.system_xml, word=comb_5),
            search_in_file(file=self.system_xml, word=comb_6),
        ]
        # print(list_search_angle)
        for j in range(len(list_search_angle)):
            if list_search_angle[j] != []:
                to_add = (list_search_angle[j], i)
                # print(to_add)
                index_search_replace_angle.append(to_add)
    f_org = open(self.system_xml)
    lines = f_org.readlines()
    for i in range(len(index_search_replace_bond)):
        line_number = index_search_replace_bond[i][0][0][0] - 1
        line_to_replace = index_search_replace_bond[i][0][0][1]
        line_to_replace_with = index_search_replace_bond[i][1]
        lines[line_number] = line_to_replace_with
    for i in range(len(index_search_replace_angle)):
        line_number = index_search_replace_angle[i][0][0][0] - 1
        line_to_replace = index_search_replace_angle[i][0][0][1]
        line_to_replace_with = index_search_replace_angle[i][1]
        lines[line_number] = line_to_replace_with
    f_cop = open(self.reparameterised_intermediate_system_xml_file, &#34;w&#34;)
    for i in lines:
        f_cop.write(i)
    f_cop.close()

    f_params = open(self.system_qm_params_file)
    lines_params = f_params.readlines()
    # Charge Parameters
    for i in range(len(lines_params)):
        if &#34;Begin writing the Charge Parameters&#34; in lines_params[i]:
            to_begin = int(i)
        if &#34;Finish writing the Charge Parameters&#34; in lines_params[i]:
            to_end = int(i)
    charge_params = lines_params[to_begin + 1 : to_end]
    non_bonded_index = []
    for k in charge_params:
        non_bonded_index.append(int(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, k)[3]))
    charge_for_index = []
    for k in charge_params:
        charge_for_index.append(
            float(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, k)[0])
        )

    xml_off = open(self.system_xml)
    xml_off_lines = xml_off.readlines()
    for i in range(len(xml_off_lines)):
        if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
            to_begin = int(i)
        if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
            to_end = int(i)
    nonbond_params = xml_off_lines[to_begin + 4 : to_end - 1]
    # print(len(nonbond_params))
    f_non_bonded = open(self.system_xml_non_bonded_file, &#34;w&#34;)
    for x in nonbond_params:
        f_non_bonded.write(x)

    f_non_bonded = open(self.system_xml_non_bonded_file)
    lines_non_bonded = f_non_bonded.readlines()
    # print(len(lines_non_bonded))
    lines_non_bonded_to_write = []
    for i in range(len(non_bonded_index)):
        line_ = lines_non_bonded[non_bonded_index[i]]
        # print(line_)
        eps = float(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, line_)[0])
        sig = float(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, line_)[2])
        line_to_replace = (
            &#34;                                &#34;
            + &#34;&lt;Particle &#34;
            + &#34;eps=&#34;
            + &#39;&#34;&#39;
            + str(eps)
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;q=&#34;
            + &#39;&#34;&#39;
            + str(charge_for_index[i])
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;sig=&#34;
            + &#39;&#34;&#39;
            + str(sig)
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
        )
        lines_non_bonded_to_write.append(line_to_replace)
    data_ = list(zip(non_bonded_index, lines_non_bonded_to_write))

    df_non_bonded_params = pd.DataFrame(
        data_, columns=[&#34;line_index&#34;, &#34;line&#34;]
    )
    # print(df_non_bonded_params.head())
    f_non_bonded_ = open(self.system_xml_non_bonded_file)
    lines_non_bonded_ = f_non_bonded_.readlines()
    for i in range(len(lines_non_bonded_)):
        if i in non_bonded_index:
            lines_non_bonded_[i] = (
                df_non_bonded_params.loc[
                    df_non_bonded_params.line_index == i, &#34;line&#34;
                ].values[0]
            ) + &#34;\n&#34;
    # print(len(lines_non_bonded_))
    f_write_non_bonded_reparams = open(
        self.system_xml_non_bonded_reparams_file, &#34;w&#34;
    )
    for p in range(len(lines_non_bonded_)):
        f_write_non_bonded_reparams.write(lines_non_bonded_[p])
    f_write_non_bonded_reparams.close()
    f_ = open(self.system_xml_non_bonded_reparams_file)
    lines_ = f_.readlines()
    print(len(lines_) == len(lines_non_bonded))

    xml_off = open(self.reparameterised_intermediate_system_xml_file)
    xml_off_lines = xml_off.readlines()
    for i in range(len(xml_off_lines)):
        if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
            to_begin = int(i)
        if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
            to_end = int(i)

    lines_before_params = xml_off_lines[: to_begin + 4]
    f__ = open(self.system_xml_non_bonded_reparams_file)
    lines_params_non_bonded = f__.readlines()
    lines_after_params = xml_off_lines[to_end - 1 :]
    f_reparams_xml = open(self.reparameterised_system_xml_file, &#34;w&#34;)
    for x in lines_before_params:
        f_reparams_xml.write(x)
    for x in lines_params_non_bonded:
        f_reparams_xml.write(x)
    for x in lines_after_params:
        f_reparams_xml.write(x)
    f_reparams_xml.close()</code></pre>
</details>
</dd>
<dt id="parameterize.GuestAmberXMLAmber.write_system_params"><code class="name flex">
<span>def <span class="ident">write_system_params</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the parameters obtained from the QM log files in a text file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_system_params(self):
    &#34;&#34;&#34;
    Saves the parameters obtained from the QM log files in a text file.
    &#34;&#34;&#34;
    # Charges from QM files
    df_charges = pd.read_csv(
        self.charge_parameter_file, header=None, delimiter=r&#34;\s+&#34;
    )
    df_charges.columns = [&#34;atom&#34;, &#34;charges&#34;]
    qm_charges = df_charges[&#34;charges&#34;].values.tolist()
    qm_charges = [round(num, 6) for num in qm_charges]
    # print(qm_charges)
    # Bond Parameters from QM files
    ppdb = PandasPdb()
    ppdb.read_pdb(self.system_qm_pdb)
    atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
    atom_name_list = [i - 1 for i in atom_name_list]
    # print(atom_name_list)
    df = pd.read_csv(
        self.bond_parameter_file, header=None, delimiter=r&#34;\s+&#34;
    )
    df.columns = [&#34;bond&#34;, &#34;k_bond&#34;, &#34;bond_length&#34;, &#34;bond_1&#34;, &#34;bond_2&#34;]
    # print(df.head())
    bond_1_list = df[&#34;bond_1&#34;].values.tolist()
    bond_1_list = [x - 1 + min(atom_name_list) for x in bond_1_list]
    bond_2_list = df[&#34;bond_2&#34;].values.tolist()
    bond_2_list = [x - 1 + min(atom_name_list) for x in bond_2_list]
    # print(bond_1_list)
    # print(bond_2_list)
    k_bond_list = df[&#34;k_bond&#34;].values.tolist()
    k_bond_list = [i * 1000.00 for i in k_bond_list]
    k_bond_list = [round(num, 10) for num in k_bond_list]
    # print(k_bond_list)
    bond_length_list = df[&#34;bond_length&#34;].values.tolist()
    bond_length_list = [i / 10.00 for i in bond_length_list]
    bond_length_list = [round(num, 6) for num in bond_length_list]
    # print(bond_length_list)
    # Angle Parameters from QM files
    ppdb = PandasPdb()
    ppdb.read_pdb(self.system_qm_pdb)
    atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
    atom_name_list = [i - 1 for i in atom_name_list]
    # print(atom_name_list)
    df = pd.read_csv(
        self.angle_parameter_file, header=None, delimiter=r&#34;\s+&#34;
    )
    df.columns = [
        &#34;angle&#34;,
        &#34;k_angle&#34;,
        &#34;angle_degrees&#34;,
        &#34;angle_1&#34;,
        &#34;angle_2&#34;,
        &#34;angle_3&#34;,
    ]
    # print(df.head())
    angle_1_list = df[&#34;angle_1&#34;].values.tolist()
    angle_1_list = [x - 1 + min(atom_name_list) for x in angle_1_list]
    # print(angle_1_list)
    angle_2_list = df[&#34;angle_2&#34;].values.tolist()
    angle_2_list = [x - 1 + min(atom_name_list) for x in angle_2_list]
    # print(angle_2_list)
    angle_3_list = df[&#34;angle_3&#34;].values.tolist()
    angle_3_list = [x - 1 + min(atom_name_list) for x in angle_3_list]
    # print(angle_3_list)
    k_angle_list = df[&#34;k_angle&#34;].values.tolist()
    k_angle_list = [round(num, 6) for num in k_angle_list]
    # print(k_angle_list)
    angle_list = df[&#34;angle_degrees&#34;].values.tolist()
    angle_list = [(i * math.pi) / 180.00 for i in angle_list]
    angle_list = [round(num, 6) for num in angle_list]
    # print(angle_list)
    xml = open(self.system_qm_params_file, &#34;w&#34;)
    xml.write(&#34;Begin writing the Bond Parameters&#34; + &#34;\n&#34;)
    for i in range(len(k_bond_list)):
        xml.write(
            &#34;                                &#34;
            + &#34;&lt;Bond&#34;
            + &#34; &#34;
            + &#34;d=&#34;
            + &#39;&#34;&#39;
            + str(bond_length_list[i])
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;k=&#34;
            + &#39;&#34;&#39;
            + str(k_bond_list[i])
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p1=&#34;
            + &#39;&#34;&#39;
            + str(bond_1_list[i])
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p2=&#34;
            + &#39;&#34;&#39;
            + str(bond_2_list[i])
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
            + &#34;\n&#34;
        )
    xml.write(&#34;Finish writing the Bond Parameters&#34; + &#34;\n&#34;)
    xml.write(&#34;Begin writing the Angle Parameters&#34; + &#34;\n&#34;)
    for i in range(len(k_angle_list)):
        xml.write(
            &#34;                                &#34;
            + &#34;&lt;Angle&#34;
            + &#34; &#34;
            + &#34;a=&#34;
            + &#39;&#34;&#39;
            + str(angle_list[i])
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;k=&#34;
            + &#39;&#34;&#39;
            + str(k_angle_list[i])
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p1=&#34;
            + &#39;&#34;&#39;
            + str(angle_1_list[i])
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p2=&#34;
            + &#39;&#34;&#39;
            + str(angle_2_list[i])
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p3=&#34;
            + &#39;&#34;&#39;
            + str(angle_3_list[i])
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
            + &#34;\n&#34;
        )
    xml.write(&#34;Finish writing the Angle Parameters&#34; + &#34;\n&#34;)
    xml.write(&#34;Begin writing the Charge Parameters&#34; + &#34;\n&#34;)
    for i in range(len(qm_charges)):
        xml.write(
            &#34;&lt;Particle&#34;
            + &#34; &#34;
            + &#34;q=&#34;
            + &#39;&#34;&#39;
            + str(qm_charges[i])
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;eps=&#34;
            + &#39;&#34;&#39;
            + str(0.00)
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;sig=&#34;
            + &#39;&#34;&#39;
            + str(0.00)
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;atom=&#34;
            + &#39;&#34;&#39;
            + str(atom_name_list[i])
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
            + &#34;\n&#34;
        )
    xml.write(&#34;Finish writing the Charge Parameters&#34; + &#34;\n&#34;)
    xml.close()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.HostAmberXMLAmber"><code class="flex name class">
<span>class <span class="ident">HostAmberXMLAmber</span></span>
<span>(</span><span>system_pdb='host.pdb', system_xml='host.xml', sim_output='sim_output.pdb', sim_steps=1000, charge_parameter_file='host_qm_surround_charges.txt', system_qm_pdb='host_qm.pdb', bond_parameter_file='host_qm_bonds.txt', angle_parameter_file='host_qm_angles.txt', system_qm_params_file='host_qm_params.txt', reparameterised_intermediate_system_xml_file='host_intermediate_reparameterised.xml', system_xml_non_bonded_file='host_xml_non_bonded.txt', system_xml_non_bonded_reparams_file='host_xml_non_bonded_reparams.txt', reparameterised_system_xml_file='host_reparameterised.xml', non_reparameterised_system_xml_file='host.xml', prmtop_system_non_params='host_non_params.prmtop', inpcrd_system_non_params='host_non_params.inpcrd', prmtop_system_params='host_params.prmtop', inpcrd_system_params='host_params.inpcrd', load_topology='openmm')</span>
</code></dt>
<dd>
<div class="desc"><p>A class used to generate a template force field XML file for the receptor
in order regenerate the reparametrised forcefield XML file.</p>
<p>This class contains methods to generate a template XML force field through
openforcefield. Re-parameterized XML force field files are then
generated from the template files. Different energy components such as
the bond,angle, torsional and non-bonded energies are computed for the
non-reparametrized and the reparameterized force fields. Difference
between the non-reparameterized and reparameterized force field energies
can then be analyzed.
&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>system_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Receptor PDB file with atom numbers beginning from 1.</dd>
<dt><strong><code>system_xml</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Serilazed XML force field file of the receptor.</dd>
<dt><strong><code>sim_output</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>PDB file containing the trajectory coordinates for the OpenMM
simulation.</dd>
<dt><strong><code>sim_steps</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Number of steps in the OpenMM MD simulation.</dd>
<dt><strong><code>charge_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>File containing the charges of receptor atoms and their
corresponding atoms.</dd>
<dt><strong><code>system_qm_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Receptor QM region's PDB file with atom numbers beginning from 1.</dd>
<dt><strong><code>bond_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the bond parameters for the receptor.</dd>
<dt><strong><code>angle_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the angle parameters of the receptor.</dd>
<dt><strong><code>system_qm_params_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A text file containing the QM obtained parameters for the
receptor.</dd>
<dt><strong><code>reparameterised_intermediate_system_xml_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>XML foce field file with bond and angle parameter lines replaced by
corresponding values obtained from the QM calculations.</dd>
<dt><strong><code>system_xml_non_bonded_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A text file to write the NonBondedForce Charge Parameters from
the non-parametrised system XML file.</dd>
<dt><strong><code>system_xml_non_bonded_reparams_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the non-bonded parameters parsed from the
XML force field file.</dd>
<dt><strong><code>reparameterised_system_xml_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Reparameterized force field XML file obtained using
openforcefield.</dd>
<dt><strong><code>non_reparameterised_system_xml_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Non-reparameterized force field XML file obtained using
openforcefield.</dd>
<dt><strong><code>prmtop_system_non_params</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Amber generated topology file saved from the non-reparameterized
force field XML file for the receptor.</dd>
<dt><strong><code>inpcrd_system_non_params</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Amber generated coordinate file saved from the non-reparameterized
force field XML file for the receptor.</dd>
<dt><strong><code>prmtop_system_params</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Amber generated topology file saved from the reparameterized
force field XML file for the receptor.</dd>
<dt><strong><code>inpcrd_system_params</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Amber generated coordinate file saved from the reparameterized
force field XML file for the receptor.</dd>
<dt><strong><code>load_topology</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Argument to specify how to load the topology. Can either be "openmm"
or "parmed".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HostAmberXMLAmber:
    &#34;&#34;&#34;
    A class used to generate a template force field XML file for the receptor 
    in order regenerate the reparametrised forcefield XML file.

    This class contains methods to generate a template XML force field through 
    openforcefield. Re-parameterized XML force field files are then 
    generated from the template files. Different energy components such as 
    the bond,angle, torsional and non-bonded energies are computed for the 
    non-reparametrized and the reparameterized force fields. Difference 
    between the non-reparameterized and reparameterized force field energies 
    can then be analyzed. 
    ...

    Attributes
    ----------

    system_pdb: str, optional
        Receptor PDB file with atom numbers beginning from 1.

    system_xml: str, optional
        Serilazed XML force field file of the receptor.

    sim_output: str, optional
        PDB file containing the trajectory coordinates for the OpenMM
        simulation. 

    sim_steps: str, optional
        Number of steps in the OpenMM MD simulation.

    charge_parameter_file: str, optional
        File containing the charges of receptor atoms and their 
        corresponding atoms.

    system_qm_pdb: str, optional
        Receptor QM region&#39;s PDB file with atom numbers beginning from 1.

    bond_parameter_file: str, optional
        Text file containing the bond parameters for the receptor.

    angle_parameter_file: str, optional
        Text file containing the angle parameters of the receptor.

    system_qm_params_file: str, optional
        A text file containing the QM obtained parameters for the 
        receptor. 

    reparameterised_intermediate_system_xml_file: str, optional
        XML foce field file with bond and angle parameter lines replaced by
        corresponding values obtained from the QM calculations.

    system_xml_non_bonded_file: str, optional
        A text file to write the NonBondedForce Charge Parameters from
        the non-parametrised system XML file.

    system_xml_non_bonded_reparams_file: str, optional
        Text file containing the non-bonded parameters parsed from the 
        XML force field file.

    reparameterised_system_xml_file: str, optional
        Reparameterized force field XML file obtained using 
        openforcefield.

    non_reparameterised_system_xml_file: str, optional
        Non-reparameterized force field XML file obtained using 
        openforcefield.

    prmtop_system_non_params: str, optional
        Amber generated topology file saved from the non-reparameterized 
        force field XML file for the receptor.

    inpcrd_system_non_params: str, optional
        Amber generated coordinate file saved from the non-reparameterized 
        force field XML file for the receptor.

    prmtop_system_params: str, optional
        Amber generated topology file saved from the reparameterized 
        force field XML file for the receptor.

    inpcrd_system_params: str, optional
        Amber generated coordinate file saved from the reparameterized 
        force field XML file for the receptor.

    load_topology: str, optional
        Argument to specify how to load the topology. Can either be &#34;openmm&#34;
        or &#34;parmed&#34;.

    &#34;&#34;&#34;

    def __init__(
        self,
        system_pdb=&#34;host.pdb&#34;,
        system_xml=&#34;host.xml&#34;,
        sim_output=&#34;sim_output.pdb&#34;,
        sim_steps=1000,
        charge_parameter_file=&#34;host_qm_surround_charges.txt&#34;,
        system_qm_pdb=&#34;host_qm.pdb&#34;,
        bond_parameter_file=&#34;host_qm_bonds.txt&#34;,
        angle_parameter_file=&#34;host_qm_angles.txt&#34;,
        system_qm_params_file=&#34;host_qm_params.txt&#34;,
        reparameterised_intermediate_system_xml_file=&#34;host_intermediate_reparameterised.xml&#34;,
        system_xml_non_bonded_file=&#34;host_xml_non_bonded.txt&#34;,
        system_xml_non_bonded_reparams_file=&#34;host_xml_non_bonded_reparams.txt&#34;,
        reparameterised_system_xml_file=&#34;host_reparameterised.xml&#34;,
        non_reparameterised_system_xml_file=&#34;host.xml&#34;,
        prmtop_system_non_params=&#34;host_non_params.prmtop&#34;,
        inpcrd_system_non_params=&#34;host_non_params.inpcrd&#34;,
        prmtop_system_params=&#34;host_params.prmtop&#34;,
        inpcrd_system_params=&#34;host_params.inpcrd&#34;,
        load_topology=&#34;openmm&#34;,
    ):
        self.system_pdb = system_pdb
        self.system_xml = system_xml
        self.sim_output = sim_output
        self.sim_steps = sim_steps
        self.charge_parameter_file = charge_parameter_file
        self.system_qm_pdb = system_qm_pdb
        self.bond_parameter_file = bond_parameter_file
        self.angle_parameter_file = angle_parameter_file
        self.system_qm_params_file = system_qm_params_file
        self.reparameterised_intermediate_system_xml_file = reparameterised_intermediate_system_xml_file
        self.system_xml_non_bonded_file = system_xml_non_bonded_file
        self.system_xml_non_bonded_reparams_file = system_xml_non_bonded_reparams_file
        self.reparameterised_system_xml_file = reparameterised_system_xml_file
        self.non_reparameterised_system_xml_file = non_reparameterised_system_xml_file
        self.prmtop_system_non_params = prmtop_system_non_params
        self.inpcrd_system_non_params = inpcrd_system_non_params
        self.prmtop_system_params = prmtop_system_params
        self.inpcrd_system_params = inpcrd_system_params
        self.load_topology = load_topology

    def serialize_system(self):
        pdb = simtk.openmm.app.PDBFile(self.system_pdb)
        forcefield = simtk.openmm.app.ForceField(&#34;amber14-all.xml&#34;)
        system = forcefield.createSystem(pdb.topology)
        integrator = simtk.openmm.LangevinIntegrator(
            300 * simtk.unit.kelvin,
            1 / simtk.unit.picosecond,
            0.002 * simtk.unit.picoseconds,
        )
        simulation = simtk.openmm.app.Simulation(
            pdb.topology, system, integrator
        )
        simulation.context.setPositions(pdb.positions)
        simulation.minimizeEnergy()
        state = simulation.context.getState(getEnergy=True)
        energy = state.getPotentialEnergy()
        print(energy)
        simulation.reporters.append(
            simtk.openmm.app.PDBReporter(self.sim_output, self.sim_steps / 10)
        )
        simulation.reporters.append(
            simtk.openmm.app.StateDataReporter(
                stdout,
                reportInterval=int(self.sim_steps / 10),
                step=True,
                potentialEnergy=True,
                temperature=True,
            )
        )
        simulation.step(self.sim_steps)
        command = &#34;rm -rf &#34; + self.sim_output
        os.system(command)
        with open(self.system_xml, &#34;w&#34;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))

    def write_system_params(self):
        &#34;&#34;&#34;
        Saves the parameters obtained from the QM log files in a text file.
        &#34;&#34;&#34;
        # Charges from QM files
        df_charges = pd.read_csv(
            self.charge_parameter_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df_charges.columns = [&#34;atom&#34;, &#34;charges&#34;]
        qm_charges = df_charges[&#34;charges&#34;].values.tolist()
        qm_charges = [round(num, 6) for num in qm_charges]
        # print(qm_charges)
        # Bond Parameters from QM files
        ppdb = PandasPdb()
        ppdb.read_pdb(self.system_qm_pdb)
        atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
        atom_name_list = [i - 1 for i in atom_name_list]
        # print(atom_name_list)
        df = pd.read_csv(
            self.bond_parameter_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df.columns = [&#34;bond&#34;, &#34;k_bond&#34;, &#34;bond_length&#34;, &#34;bond_1&#34;, &#34;bond_2&#34;]
        # print(df.head())
        bond_1_list = df[&#34;bond_1&#34;].values.tolist()
        bond_1_list = [x - 1 + min(atom_name_list) for x in bond_1_list]
        bond_2_list = df[&#34;bond_2&#34;].values.tolist()
        bond_2_list = [x - 1 + min(atom_name_list) for x in bond_2_list]
        # print(bond_1_list)
        # print(bond_2_list)
        k_bond_list = df[&#34;k_bond&#34;].values.tolist()
        k_bond_list = [i * 1000.00 for i in k_bond_list]
        k_bond_list = [round(num, 10) for num in k_bond_list]
        # print(k_bond_list)
        bond_length_list = df[&#34;bond_length&#34;].values.tolist()
        bond_length_list = [i / 10.00 for i in bond_length_list]
        bond_length_list = [round(num, 6) for num in bond_length_list]
        # print(bond_length_list)
        # Angle Parameters from QM files
        ppdb = PandasPdb()
        ppdb.read_pdb(self.system_qm_pdb)
        atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
        atom_name_list = [i - 1 for i in atom_name_list]
        # print(atom_name_list)
        df = pd.read_csv(
            self.angle_parameter_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df.columns = [
            &#34;angle&#34;,
            &#34;k_angle&#34;,
            &#34;angle_degrees&#34;,
            &#34;angle_1&#34;,
            &#34;angle_2&#34;,
            &#34;angle_3&#34;,
        ]
        # print(df.head())
        angle_1_list = df[&#34;angle_1&#34;].values.tolist()
        angle_1_list = [x - 1 + min(atom_name_list) for x in angle_1_list]
        # print(angle_1_list)
        angle_2_list = df[&#34;angle_2&#34;].values.tolist()
        angle_2_list = [x - 1 + min(atom_name_list) for x in angle_2_list]
        # print(angle_2_list)
        angle_3_list = df[&#34;angle_3&#34;].values.tolist()
        angle_3_list = [x - 1 + min(atom_name_list) for x in angle_3_list]
        # print(angle_3_list)
        k_angle_list = df[&#34;k_angle&#34;].values.tolist()
        k_angle_list = [round(num, 6) for num in k_angle_list]
        # print(k_angle_list)
        angle_list = df[&#34;angle_degrees&#34;].values.tolist()
        angle_list = [(i * math.pi) / 180.00 for i in angle_list]
        angle_list = [round(num, 6) for num in angle_list]
        # print(angle_list)
        xml = open(self.system_qm_params_file, &#34;w&#34;)
        xml.write(&#34;Begin writing the Bond Parameters&#34; + &#34;\n&#34;)
        for i in range(len(k_bond_list)):
            xml.write(
                &#34;                                &#34;
                + &#34;&lt;Bond&#34;
                + &#34; &#34;
                + &#34;d=&#34;
                + &#39;&#34;&#39;
                + str(bond_length_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;k=&#34;
                + &#39;&#34;&#39;
                + str(k_bond_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p1=&#34;
                + &#39;&#34;&#39;
                + str(bond_1_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + str(bond_2_list[i])
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
                + &#34;\n&#34;
            )
        xml.write(&#34;Finish writing the Bond Parameters&#34; + &#34;\n&#34;)
        xml.write(&#34;Begin writing the Angle Parameters&#34; + &#34;\n&#34;)
        for i in range(len(k_angle_list)):
            xml.write(
                &#34;                                &#34;
                + &#34;&lt;Angle&#34;
                + &#34; &#34;
                + &#34;a=&#34;
                + &#39;&#34;&#39;
                + str(angle_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;k=&#34;
                + &#39;&#34;&#39;
                + str(k_angle_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p1=&#34;
                + &#39;&#34;&#39;
                + str(angle_1_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + str(angle_2_list[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + str(angle_3_list[i])
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
                + &#34;\n&#34;
            )
        xml.write(&#34;Finish writing the Angle Parameters&#34; + &#34;\n&#34;)
        xml.write(&#34;Begin writing the Charge Parameters&#34; + &#34;\n&#34;)
        for i in range(len(qm_charges)):
            xml.write(
                &#34;&lt;Particle&#34;
                + &#34; &#34;
                + &#34;q=&#34;
                + &#39;&#34;&#39;
                + str(qm_charges[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;eps=&#34;
                + &#39;&#34;&#39;
                + str(0.00)
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;sig=&#34;
                + &#39;&#34;&#39;
                + str(0.00)
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;atom=&#34;
                + &#39;&#34;&#39;
                + str(atom_name_list[i])
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
                + &#34;\n&#34;
            )
        xml.write(&#34;Finish writing the Charge Parameters&#34; + &#34;\n&#34;)
        xml.close()

    def write_reparameterised_system_xml(self):
        &#34;&#34;&#34;
        Writes a reparameterised XML force field file for the ligand.
        &#34;&#34;&#34;
        # Bond Parameters
        f_params = open(self.system_qm_params_file, &#34;r&#34;)
        lines_params = f_params.readlines()
        # Bond Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Bond Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Bond Parameters&#34; in lines_params[i]:
                to_end = int(i)
        bond_params = lines_params[to_begin + 1 : to_end]
        index_search_replace_bond = []
        for i in bond_params:
            bond_line_to_replace = i
            # print(bond_line_to_replace)
            atom_number_list = [
                re.findall(&#34;\d*\.?\d+&#34;, i)[3],
                re.findall(&#34;\d*\.?\d+&#34;, i)[5],
            ]
            # print(atom_number_list)
            comb_1 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_2 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_list_bond = [comb_1, comb_2]
            # print(comb_list_bond)
            list_search_bond = [
                search_in_file(file=self.system_xml, word=comb_1),
                search_in_file(file=self.system_xml, word=comb_2),
            ]
            # print(list_search_bond)
            for j in range(len(list_search_bond)):
                if list_search_bond[j] != []:
                    to_add = (list_search_bond[j], i)
                    # print(to_add)
                    index_search_replace_bond.append(to_add)
        # Angle Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Angle Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Angle Parameters&#34; in lines_params[i]:
                to_end = int(i)
        angle_params = lines_params[to_begin + 1 : to_end]
        index_search_replace_angle = []
        for i in angle_params:
            angle_line_to_replace = i
            # print(angle_line_to_replace)
        index_search_replace_angle = []
        for i in angle_params:
            angle_line_to_replace = i
            # print(angle_line_to_replace)
            atom_number_list = [
                re.findall(&#34;\d*\.?\d+&#34;, i)[3],
                re.findall(&#34;\d*\.?\d+&#34;, i)[5],
                re.findall(&#34;\d*\.?\d+&#34;, i)[7],
            ]
            # print(atom_number_list)
            comb_1 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_2 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_3 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_4 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_5 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_6 = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[2]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[1]
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + atom_number_list[0]
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            comb_list_angle = [comb_1, comb_2, comb_3, comb_4, comb_5, comb_6]
            # print(comb_list_angle)
            list_search_angle = [
                search_in_file(file=self.system_xml, word=comb_1),
                search_in_file(file=self.system_xml, word=comb_2),
                search_in_file(file=self.system_xml, word=comb_3),
                search_in_file(file=self.system_xml, word=comb_4),
                search_in_file(file=self.system_xml, word=comb_5),
                search_in_file(file=self.system_xml, word=comb_6),
            ]
            # print(list_search_angle)
            for j in range(len(list_search_angle)):
                if list_search_angle[j] != []:
                    to_add = (list_search_angle[j], i)
                    # print(to_add)
                    index_search_replace_angle.append(to_add)
        f_org = open(self.system_xml)
        lines = f_org.readlines()
        for i in range(len(index_search_replace_bond)):
            line_number = index_search_replace_bond[i][0][0][0] - 1
            line_to_replace = index_search_replace_bond[i][0][0][1]
            line_to_replace_with = index_search_replace_bond[i][1]
            lines[line_number] = line_to_replace_with
        for i in range(len(index_search_replace_angle)):
            line_number = index_search_replace_angle[i][0][0][0] - 1
            line_to_replace = index_search_replace_angle[i][0][0][1]
            line_to_replace_with = index_search_replace_angle[i][1]
            lines[line_number] = line_to_replace_with
        f_cop = open(self.reparameterised_intermediate_system_xml_file, &#34;w&#34;)
        for i in lines:
            f_cop.write(i)
        f_cop.close()

        f_params = open(self.system_qm_params_file)
        lines_params = f_params.readlines()
        # Charge Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Charge Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Charge Parameters&#34; in lines_params[i]:
                to_end = int(i)
        charge_params = lines_params[to_begin + 1 : to_end]
        non_bonded_index = []
        for k in charge_params:
            non_bonded_index.append(int(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, k)[3]))
        charge_for_index = []
        for k in charge_params:
            charge_for_index.append(
                float(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, k)[0])
            )

        xml_off = open(self.system_xml)
        xml_off_lines = xml_off.readlines()
        for i in range(len(xml_off_lines)):
            if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
                to_begin = int(i)
            if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
                to_end = int(i)
        nonbond_params = xml_off_lines[to_begin + 4 : to_end - 1]
        # print(len(nonbond_params))
        f_non_bonded = open(self.system_xml_non_bonded_file, &#34;w&#34;)
        for x in nonbond_params:
            f_non_bonded.write(x)

        f_non_bonded = open(self.system_xml_non_bonded_file)
        lines_non_bonded = f_non_bonded.readlines()
        # print(len(lines_non_bonded))
        lines_non_bonded_to_write = []
        for i in range(len(non_bonded_index)):
            line_ = lines_non_bonded[non_bonded_index[i]]
            # print(line_)
            eps = float(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, line_)[0])
            sig = float(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, line_)[2])
            line_to_replace = (
                &#34;                                &#34;
                + &#34;&lt;Particle &#34;
                + &#34;eps=&#34;
                + &#39;&#34;&#39;
                + str(eps)
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;q=&#34;
                + &#39;&#34;&#39;
                + str(charge_for_index[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;sig=&#34;
                + &#39;&#34;&#39;
                + str(sig)
                + &#39;&#34;&#39;
                + &#34;/&gt;&#34;
            )
            lines_non_bonded_to_write.append(line_to_replace)
        data_ = list(zip(non_bonded_index, lines_non_bonded_to_write))

        df_non_bonded_params = pd.DataFrame(
            data_, columns=[&#34;line_index&#34;, &#34;line&#34;]
        )
        # print(df_non_bonded_params.head())
        f_non_bonded_ = open(self.system_xml_non_bonded_file)
        lines_non_bonded_ = f_non_bonded_.readlines()
        for i in range(len(lines_non_bonded_)):
            if i in non_bonded_index:
                lines_non_bonded_[i] = (
                    df_non_bonded_params.loc[
                        df_non_bonded_params.line_index == i, &#34;line&#34;
                    ].values[0]
                ) + &#34;\n&#34;
        # print(len(lines_non_bonded_))
        f_write_non_bonded_reparams = open(
            self.system_xml_non_bonded_reparams_file, &#34;w&#34;
        )
        for p in range(len(lines_non_bonded_)):
            f_write_non_bonded_reparams.write(lines_non_bonded_[p])
        f_write_non_bonded_reparams.close()
        f_ = open(self.system_xml_non_bonded_reparams_file)
        lines_ = f_.readlines()
        print(len(lines_) == len(lines_non_bonded))

        xml_off = open(self.reparameterised_intermediate_system_xml_file)
        xml_off_lines = xml_off.readlines()
        for i in range(len(xml_off_lines)):
            if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
                to_begin = int(i)
            if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
                to_end = int(i)

        lines_before_params = xml_off_lines[: to_begin + 4]
        f__ = open(self.system_xml_non_bonded_reparams_file)
        lines_params_non_bonded = f__.readlines()
        lines_after_params = xml_off_lines[to_end - 1 :]
        f_reparams_xml = open(self.reparameterised_system_xml_file, &#34;w&#34;)
        for x in lines_before_params:
            f_reparams_xml.write(x)
        for x in lines_params_non_bonded:
            f_reparams_xml.write(x)
        for x in lines_after_params:
            f_reparams_xml.write(x)
        f_reparams_xml.close()

    def save_amber_params(self):
        &#34;&#34;&#34;
        Saves amber generated topology files for the ligand.
        &#34;&#34;&#34;
        if self.load_topology == &#34;parmed&#34;:
            openmm_system = parmed.openmm.load_topology(
                parmed.load_file(self.system_pdb, structure=True).topology,
                parmed.load_file(self.non_reparameterised_system_xml_file),
            )
        if self.load_topology == &#34;openmm&#34;:
            openmm_system = parmed.openmm.load_topology(
                simtk.openmm.app.PDBFile(self.system_pdb).topology,
                parmed.load_file(self.non_reparameterised_system_xml_file),
            )
        openmm_system.save(self.prmtop_system_non_params, overwrite=True)
        openmm_system.coordinates = parmed.load_file(
            self.system_pdb, structure=True
        ).coordinates
        openmm_system.save(self.inpcrd_system_non_params, overwrite=True)
        parm = parmed.load_file(
            self.prmtop_system_non_params, self.inpcrd_system_non_params
        )

        xml_energy_decomposition = parmed.openmm.energy_decomposition_system(
            openmm_system,
            parmed.load_file(self.non_reparameterised_system_xml_file),
        )
        xml_energy_decomposition_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        xml_energy_decomposition_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_xml = pd.DataFrame(
            list(
                zip(
                    xml_energy_decomposition_list,
                    xml_energy_decomposition_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_xml_non_params&#34;],
        )
        df_energy_xml = df_energy_xml.set_index(&#34;Energy_term&#34;)

        prmtop_energy_decomposition = (
            parmed.openmm.energy_decomposition_system(
                parm, parm.createSystem()
            )
        )
        prmtop_energy_decomposition_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        prmtop_energy_decomposition_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_prmtop = pd.DataFrame(
            list(
                zip(
                    prmtop_energy_decomposition_list,
                    prmtop_energy_decomposition_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_prmtop_non_params&#34;],
        )
        df_energy_prmtop = df_energy_prmtop.set_index(&#34;Energy_term&#34;)

        df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
        print(df_compare)

        if self.load_topology == &#34;parmed&#34;:
            openmm_system = parmed.openmm.load_topology(
                parmed.load_file(self.system_pdb, structure=True).topology,
                parmed.load_file(self.reparameterised_system_xml_file),
            )
        if self.load_topology == &#34;openmm&#34;:
            openmm_system = parmed.openmm.load_topology(
                simtk.openmm.app.PDBFile(self.system_pdb).topology,
                parmed.load_file(self.reparameterised_system_xml_file),
            )
        openmm_system.save(self.prmtop_system_params, overwrite=True)
        openmm_system.coordinates = parmed.load_file(
            self.system_pdb, structure=True
        ).coordinates
        openmm_system.save(self.inpcrd_system_params, overwrite=True)
        parm = parmed.load_file(
            self.prmtop_system_params, self.inpcrd_system_params
        )

        xml_energy_decomposition = parmed.openmm.energy_decomposition_system(
            openmm_system,
            parmed.load_file(self.reparameterised_system_xml_file),
        )
        xml_energy_decomposition_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in xml_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        xml_energy_decomposition_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_xml = pd.DataFrame(
            list(
                zip(
                    xml_energy_decomposition_list,
                    xml_energy_decomposition_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_xml_params&#34;],
        )
        df_energy_xml = df_energy_xml.set_index(&#34;Energy_term&#34;)

        prmtop_energy_decomposition = (
            parmed.openmm.energy_decomposition_system(
                parm, parm.createSystem()
            )
        )
        prmtop_energy_decomposition_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem) for elem in prmtop_energy_decomposition
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        prmtop_energy_decomposition_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_prmtop = pd.DataFrame(
            list(
                zip(
                    prmtop_energy_decomposition_list,
                    prmtop_energy_decomposition_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_prmtop_params&#34;],
        )
        df_energy_prmtop = df_energy_prmtop.set_index(&#34;Energy_term&#34;)

        df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
        print(df_compare)

    def analyze_diff_energies(self):
        &#34;&#34;&#34;
        Compares the energies of the ligand obtained from the non-parameterized 
        and the parameterized force field files. 
        &#34;&#34;&#34;
        parm_non_params = parmed.load_file(
            self.prmtop_system_non_params, self.inpcrd_system_non_params
        )
        prmtop_energy_decomposition_non_params = (
            parmed.openmm.energy_decomposition_system(
                parm_non_params, parm_non_params.createSystem()
            )
        )
        prmtop_energy_decomposition_non_params_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_non_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_non_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_non_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_non_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        prmtop_energy_decomposition_non_params_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_non_params = pd.DataFrame(
            list(
                zip(
                    prmtop_energy_decomposition_non_params_list,
                    prmtop_energy_decomposition_non_params_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_parm_non_params&#34;],
        )
        df_energy_non_params = df_energy_non_params.set_index(&#34;Energy_term&#34;)
        # print(df_energy_non_params)
        parm_params = parmed.load_file(
            self.prmtop_system_params, self.inpcrd_system_params
        )
        prmtop_energy_decomposition_params = (
            parmed.openmm.energy_decomposition_system(
                parm_params, parm_params.createSystem()
            )
        )
        prmtop_energy_decomposition_params_value = [
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicBondForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;HarmonicAngleForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;PeriodicTorsionForce&#34;),
            list_to_dict(
                [
                    item
                    for sublist in [
                        list(elem)
                        for elem in prmtop_energy_decomposition_params
                    ]
                    for item in sublist
                ]
            ).get(&#34;NonbondedForce&#34;),
        ]
        prmtop_energy_decomposition_params_list = [
            &#34;HarmonicBondForce&#34;,
            &#34;HarmonicAngleForce&#34;,
            &#34;PeriodicTorsionForce&#34;,
            &#34;NonbondedForce&#34;,
        ]
        df_energy_params = pd.DataFrame(
            list(
                zip(
                    prmtop_energy_decomposition_params_list,
                    prmtop_energy_decomposition_params_value,
                )
            ),
            columns=[&#34;Energy_term&#34;, &#34;Energy_parm_params&#34;],
        )
        df_energy_params = df_energy_params.set_index(&#34;Energy_term&#34;)
        # print(df_energy_params)
        df_compare = pd.concat(
            [df_energy_non_params, df_energy_params], axis=1
        )
        df_compare[&#34;Energy_difference&#34;] = df_compare[
            &#34;Energy_parm_non_params&#34;
        ].sub(df_compare[&#34;Energy_parm_params&#34;], axis=0)
        print(df_compare)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.HostAmberXMLAmber.analyze_diff_energies"><code class="name flex">
<span>def <span class="ident">analyze_diff_energies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compares the energies of the ligand obtained from the non-parameterized
and the parameterized force field files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analyze_diff_energies(self):
    &#34;&#34;&#34;
    Compares the energies of the ligand obtained from the non-parameterized 
    and the parameterized force field files. 
    &#34;&#34;&#34;
    parm_non_params = parmed.load_file(
        self.prmtop_system_non_params, self.inpcrd_system_non_params
    )
    prmtop_energy_decomposition_non_params = (
        parmed.openmm.energy_decomposition_system(
            parm_non_params, parm_non_params.createSystem()
        )
    )
    prmtop_energy_decomposition_non_params_value = [
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem)
                    for elem in prmtop_energy_decomposition_non_params
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicBondForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem)
                    for elem in prmtop_energy_decomposition_non_params
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicAngleForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem)
                    for elem in prmtop_energy_decomposition_non_params
                ]
                for item in sublist
            ]
        ).get(&#34;PeriodicTorsionForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem)
                    for elem in prmtop_energy_decomposition_non_params
                ]
                for item in sublist
            ]
        ).get(&#34;NonbondedForce&#34;),
    ]
    prmtop_energy_decomposition_non_params_list = [
        &#34;HarmonicBondForce&#34;,
        &#34;HarmonicAngleForce&#34;,
        &#34;PeriodicTorsionForce&#34;,
        &#34;NonbondedForce&#34;,
    ]
    df_energy_non_params = pd.DataFrame(
        list(
            zip(
                prmtop_energy_decomposition_non_params_list,
                prmtop_energy_decomposition_non_params_value,
            )
        ),
        columns=[&#34;Energy_term&#34;, &#34;Energy_parm_non_params&#34;],
    )
    df_energy_non_params = df_energy_non_params.set_index(&#34;Energy_term&#34;)
    # print(df_energy_non_params)
    parm_params = parmed.load_file(
        self.prmtop_system_params, self.inpcrd_system_params
    )
    prmtop_energy_decomposition_params = (
        parmed.openmm.energy_decomposition_system(
            parm_params, parm_params.createSystem()
        )
    )
    prmtop_energy_decomposition_params_value = [
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem)
                    for elem in prmtop_energy_decomposition_params
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicBondForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem)
                    for elem in prmtop_energy_decomposition_params
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicAngleForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem)
                    for elem in prmtop_energy_decomposition_params
                ]
                for item in sublist
            ]
        ).get(&#34;PeriodicTorsionForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem)
                    for elem in prmtop_energy_decomposition_params
                ]
                for item in sublist
            ]
        ).get(&#34;NonbondedForce&#34;),
    ]
    prmtop_energy_decomposition_params_list = [
        &#34;HarmonicBondForce&#34;,
        &#34;HarmonicAngleForce&#34;,
        &#34;PeriodicTorsionForce&#34;,
        &#34;NonbondedForce&#34;,
    ]
    df_energy_params = pd.DataFrame(
        list(
            zip(
                prmtop_energy_decomposition_params_list,
                prmtop_energy_decomposition_params_value,
            )
        ),
        columns=[&#34;Energy_term&#34;, &#34;Energy_parm_params&#34;],
    )
    df_energy_params = df_energy_params.set_index(&#34;Energy_term&#34;)
    # print(df_energy_params)
    df_compare = pd.concat(
        [df_energy_non_params, df_energy_params], axis=1
    )
    df_compare[&#34;Energy_difference&#34;] = df_compare[
        &#34;Energy_parm_non_params&#34;
    ].sub(df_compare[&#34;Energy_parm_params&#34;], axis=0)
    print(df_compare)</code></pre>
</details>
</dd>
<dt id="parameterize.HostAmberXMLAmber.save_amber_params"><code class="name flex">
<span>def <span class="ident">save_amber_params</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves amber generated topology files for the ligand.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_amber_params(self):
    &#34;&#34;&#34;
    Saves amber generated topology files for the ligand.
    &#34;&#34;&#34;
    if self.load_topology == &#34;parmed&#34;:
        openmm_system = parmed.openmm.load_topology(
            parmed.load_file(self.system_pdb, structure=True).topology,
            parmed.load_file(self.non_reparameterised_system_xml_file),
        )
    if self.load_topology == &#34;openmm&#34;:
        openmm_system = parmed.openmm.load_topology(
            simtk.openmm.app.PDBFile(self.system_pdb).topology,
            parmed.load_file(self.non_reparameterised_system_xml_file),
        )
    openmm_system.save(self.prmtop_system_non_params, overwrite=True)
    openmm_system.coordinates = parmed.load_file(
        self.system_pdb, structure=True
    ).coordinates
    openmm_system.save(self.inpcrd_system_non_params, overwrite=True)
    parm = parmed.load_file(
        self.prmtop_system_non_params, self.inpcrd_system_non_params
    )

    xml_energy_decomposition = parmed.openmm.energy_decomposition_system(
        openmm_system,
        parmed.load_file(self.non_reparameterised_system_xml_file),
    )
    xml_energy_decomposition_value = [
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in xml_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicBondForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in xml_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicAngleForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in xml_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;PeriodicTorsionForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in xml_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;NonbondedForce&#34;),
    ]
    xml_energy_decomposition_list = [
        &#34;HarmonicBondForce&#34;,
        &#34;HarmonicAngleForce&#34;,
        &#34;PeriodicTorsionForce&#34;,
        &#34;NonbondedForce&#34;,
    ]
    df_energy_xml = pd.DataFrame(
        list(
            zip(
                xml_energy_decomposition_list,
                xml_energy_decomposition_value,
            )
        ),
        columns=[&#34;Energy_term&#34;, &#34;Energy_xml_non_params&#34;],
    )
    df_energy_xml = df_energy_xml.set_index(&#34;Energy_term&#34;)

    prmtop_energy_decomposition = (
        parmed.openmm.energy_decomposition_system(
            parm, parm.createSystem()
        )
    )
    prmtop_energy_decomposition_value = [
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicBondForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicAngleForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;PeriodicTorsionForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;NonbondedForce&#34;),
    ]
    prmtop_energy_decomposition_list = [
        &#34;HarmonicBondForce&#34;,
        &#34;HarmonicAngleForce&#34;,
        &#34;PeriodicTorsionForce&#34;,
        &#34;NonbondedForce&#34;,
    ]
    df_energy_prmtop = pd.DataFrame(
        list(
            zip(
                prmtop_energy_decomposition_list,
                prmtop_energy_decomposition_value,
            )
        ),
        columns=[&#34;Energy_term&#34;, &#34;Energy_prmtop_non_params&#34;],
    )
    df_energy_prmtop = df_energy_prmtop.set_index(&#34;Energy_term&#34;)

    df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
    print(df_compare)

    if self.load_topology == &#34;parmed&#34;:
        openmm_system = parmed.openmm.load_topology(
            parmed.load_file(self.system_pdb, structure=True).topology,
            parmed.load_file(self.reparameterised_system_xml_file),
        )
    if self.load_topology == &#34;openmm&#34;:
        openmm_system = parmed.openmm.load_topology(
            simtk.openmm.app.PDBFile(self.system_pdb).topology,
            parmed.load_file(self.reparameterised_system_xml_file),
        )
    openmm_system.save(self.prmtop_system_params, overwrite=True)
    openmm_system.coordinates = parmed.load_file(
        self.system_pdb, structure=True
    ).coordinates
    openmm_system.save(self.inpcrd_system_params, overwrite=True)
    parm = parmed.load_file(
        self.prmtop_system_params, self.inpcrd_system_params
    )

    xml_energy_decomposition = parmed.openmm.energy_decomposition_system(
        openmm_system,
        parmed.load_file(self.reparameterised_system_xml_file),
    )
    xml_energy_decomposition_value = [
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in xml_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicBondForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in xml_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicAngleForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in xml_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;PeriodicTorsionForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in xml_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;NonbondedForce&#34;),
    ]
    xml_energy_decomposition_list = [
        &#34;HarmonicBondForce&#34;,
        &#34;HarmonicAngleForce&#34;,
        &#34;PeriodicTorsionForce&#34;,
        &#34;NonbondedForce&#34;,
    ]
    df_energy_xml = pd.DataFrame(
        list(
            zip(
                xml_energy_decomposition_list,
                xml_energy_decomposition_value,
            )
        ),
        columns=[&#34;Energy_term&#34;, &#34;Energy_xml_params&#34;],
    )
    df_energy_xml = df_energy_xml.set_index(&#34;Energy_term&#34;)

    prmtop_energy_decomposition = (
        parmed.openmm.energy_decomposition_system(
            parm, parm.createSystem()
        )
    )
    prmtop_energy_decomposition_value = [
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicBondForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;HarmonicAngleForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;PeriodicTorsionForce&#34;),
        list_to_dict(
            [
                item
                for sublist in [
                    list(elem) for elem in prmtop_energy_decomposition
                ]
                for item in sublist
            ]
        ).get(&#34;NonbondedForce&#34;),
    ]
    prmtop_energy_decomposition_list = [
        &#34;HarmonicBondForce&#34;,
        &#34;HarmonicAngleForce&#34;,
        &#34;PeriodicTorsionForce&#34;,
        &#34;NonbondedForce&#34;,
    ]
    df_energy_prmtop = pd.DataFrame(
        list(
            zip(
                prmtop_energy_decomposition_list,
                prmtop_energy_decomposition_value,
            )
        ),
        columns=[&#34;Energy_term&#34;, &#34;Energy_prmtop_params&#34;],
    )
    df_energy_prmtop = df_energy_prmtop.set_index(&#34;Energy_term&#34;)

    df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
    print(df_compare)</code></pre>
</details>
</dd>
<dt id="parameterize.HostAmberXMLAmber.serialize_system"><code class="name flex">
<span>def <span class="ident">serialize_system</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize_system(self):
    pdb = simtk.openmm.app.PDBFile(self.system_pdb)
    forcefield = simtk.openmm.app.ForceField(&#34;amber14-all.xml&#34;)
    system = forcefield.createSystem(pdb.topology)
    integrator = simtk.openmm.LangevinIntegrator(
        300 * simtk.unit.kelvin,
        1 / simtk.unit.picosecond,
        0.002 * simtk.unit.picoseconds,
    )
    simulation = simtk.openmm.app.Simulation(
        pdb.topology, system, integrator
    )
    simulation.context.setPositions(pdb.positions)
    simulation.minimizeEnergy()
    state = simulation.context.getState(getEnergy=True)
    energy = state.getPotentialEnergy()
    print(energy)
    simulation.reporters.append(
        simtk.openmm.app.PDBReporter(self.sim_output, self.sim_steps / 10)
    )
    simulation.reporters.append(
        simtk.openmm.app.StateDataReporter(
            stdout,
            reportInterval=int(self.sim_steps / 10),
            step=True,
            potentialEnergy=True,
            temperature=True,
        )
    )
    simulation.step(self.sim_steps)
    command = &#34;rm -rf &#34; + self.sim_output
    os.system(command)
    with open(self.system_xml, &#34;w&#34;) as f:
        f.write(simtk.openmm.XmlSerializer.serialize(system))</code></pre>
</details>
</dd>
<dt id="parameterize.HostAmberXMLAmber.write_reparameterised_system_xml"><code class="name flex">
<span>def <span class="ident">write_reparameterised_system_xml</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes a reparameterised XML force field file for the ligand.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_reparameterised_system_xml(self):
    &#34;&#34;&#34;
    Writes a reparameterised XML force field file for the ligand.
    &#34;&#34;&#34;
    # Bond Parameters
    f_params = open(self.system_qm_params_file, &#34;r&#34;)
    lines_params = f_params.readlines()
    # Bond Parameters
    for i in range(len(lines_params)):
        if &#34;Begin writing the Bond Parameters&#34; in lines_params[i]:
            to_begin = int(i)
        if &#34;Finish writing the Bond Parameters&#34; in lines_params[i]:
            to_end = int(i)
    bond_params = lines_params[to_begin + 1 : to_end]
    index_search_replace_bond = []
    for i in bond_params:
        bond_line_to_replace = i
        # print(bond_line_to_replace)
        atom_number_list = [
            re.findall(&#34;\d*\.?\d+&#34;, i)[3],
            re.findall(&#34;\d*\.?\d+&#34;, i)[5],
        ]
        # print(atom_number_list)
        comb_1 = (
            &#34;p1=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[0]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p2=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[1]
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
        )
        comb_2 = (
            &#34;p1=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[1]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p2=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[0]
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
        )
        comb_list_bond = [comb_1, comb_2]
        # print(comb_list_bond)
        list_search_bond = [
            search_in_file(file=self.system_xml, word=comb_1),
            search_in_file(file=self.system_xml, word=comb_2),
        ]
        # print(list_search_bond)
        for j in range(len(list_search_bond)):
            if list_search_bond[j] != []:
                to_add = (list_search_bond[j], i)
                # print(to_add)
                index_search_replace_bond.append(to_add)
    # Angle Parameters
    for i in range(len(lines_params)):
        if &#34;Begin writing the Angle Parameters&#34; in lines_params[i]:
            to_begin = int(i)
        if &#34;Finish writing the Angle Parameters&#34; in lines_params[i]:
            to_end = int(i)
    angle_params = lines_params[to_begin + 1 : to_end]
    index_search_replace_angle = []
    for i in angle_params:
        angle_line_to_replace = i
        # print(angle_line_to_replace)
    index_search_replace_angle = []
    for i in angle_params:
        angle_line_to_replace = i
        # print(angle_line_to_replace)
        atom_number_list = [
            re.findall(&#34;\d*\.?\d+&#34;, i)[3],
            re.findall(&#34;\d*\.?\d+&#34;, i)[5],
            re.findall(&#34;\d*\.?\d+&#34;, i)[7],
        ]
        # print(atom_number_list)
        comb_1 = (
            &#34;p1=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[0]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p2=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[1]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p3=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[2]
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
        )
        comb_2 = (
            &#34;p1=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[0]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p2=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[2]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p3=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[1]
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
        )
        comb_3 = (
            &#34;p1=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[1]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p2=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[0]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p3=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[2]
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
        )
        comb_4 = (
            &#34;p1=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[1]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p2=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[2]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p3=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[0]
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
        )
        comb_5 = (
            &#34;p1=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[2]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p2=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[0]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p3=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[1]
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
        )
        comb_6 = (
            &#34;p1=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[2]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p2=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[1]
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p3=&#34;
            + &#39;&#34;&#39;
            + atom_number_list[0]
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
        )
        comb_list_angle = [comb_1, comb_2, comb_3, comb_4, comb_5, comb_6]
        # print(comb_list_angle)
        list_search_angle = [
            search_in_file(file=self.system_xml, word=comb_1),
            search_in_file(file=self.system_xml, word=comb_2),
            search_in_file(file=self.system_xml, word=comb_3),
            search_in_file(file=self.system_xml, word=comb_4),
            search_in_file(file=self.system_xml, word=comb_5),
            search_in_file(file=self.system_xml, word=comb_6),
        ]
        # print(list_search_angle)
        for j in range(len(list_search_angle)):
            if list_search_angle[j] != []:
                to_add = (list_search_angle[j], i)
                # print(to_add)
                index_search_replace_angle.append(to_add)
    f_org = open(self.system_xml)
    lines = f_org.readlines()
    for i in range(len(index_search_replace_bond)):
        line_number = index_search_replace_bond[i][0][0][0] - 1
        line_to_replace = index_search_replace_bond[i][0][0][1]
        line_to_replace_with = index_search_replace_bond[i][1]
        lines[line_number] = line_to_replace_with
    for i in range(len(index_search_replace_angle)):
        line_number = index_search_replace_angle[i][0][0][0] - 1
        line_to_replace = index_search_replace_angle[i][0][0][1]
        line_to_replace_with = index_search_replace_angle[i][1]
        lines[line_number] = line_to_replace_with
    f_cop = open(self.reparameterised_intermediate_system_xml_file, &#34;w&#34;)
    for i in lines:
        f_cop.write(i)
    f_cop.close()

    f_params = open(self.system_qm_params_file)
    lines_params = f_params.readlines()
    # Charge Parameters
    for i in range(len(lines_params)):
        if &#34;Begin writing the Charge Parameters&#34; in lines_params[i]:
            to_begin = int(i)
        if &#34;Finish writing the Charge Parameters&#34; in lines_params[i]:
            to_end = int(i)
    charge_params = lines_params[to_begin + 1 : to_end]
    non_bonded_index = []
    for k in charge_params:
        non_bonded_index.append(int(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, k)[3]))
    charge_for_index = []
    for k in charge_params:
        charge_for_index.append(
            float(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, k)[0])
        )

    xml_off = open(self.system_xml)
    xml_off_lines = xml_off.readlines()
    for i in range(len(xml_off_lines)):
        if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
            to_begin = int(i)
        if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
            to_end = int(i)
    nonbond_params = xml_off_lines[to_begin + 4 : to_end - 1]
    # print(len(nonbond_params))
    f_non_bonded = open(self.system_xml_non_bonded_file, &#34;w&#34;)
    for x in nonbond_params:
        f_non_bonded.write(x)

    f_non_bonded = open(self.system_xml_non_bonded_file)
    lines_non_bonded = f_non_bonded.readlines()
    # print(len(lines_non_bonded))
    lines_non_bonded_to_write = []
    for i in range(len(non_bonded_index)):
        line_ = lines_non_bonded[non_bonded_index[i]]
        # print(line_)
        eps = float(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, line_)[0])
        sig = float(re.findall(&#34;[-+]?\d*\.\d+|\d+&#34;, line_)[2])
        line_to_replace = (
            &#34;                                &#34;
            + &#34;&lt;Particle &#34;
            + &#34;eps=&#34;
            + &#39;&#34;&#39;
            + str(eps)
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;q=&#34;
            + &#39;&#34;&#39;
            + str(charge_for_index[i])
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;sig=&#34;
            + &#39;&#34;&#39;
            + str(sig)
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
        )
        lines_non_bonded_to_write.append(line_to_replace)
    data_ = list(zip(non_bonded_index, lines_non_bonded_to_write))

    df_non_bonded_params = pd.DataFrame(
        data_, columns=[&#34;line_index&#34;, &#34;line&#34;]
    )
    # print(df_non_bonded_params.head())
    f_non_bonded_ = open(self.system_xml_non_bonded_file)
    lines_non_bonded_ = f_non_bonded_.readlines()
    for i in range(len(lines_non_bonded_)):
        if i in non_bonded_index:
            lines_non_bonded_[i] = (
                df_non_bonded_params.loc[
                    df_non_bonded_params.line_index == i, &#34;line&#34;
                ].values[0]
            ) + &#34;\n&#34;
    # print(len(lines_non_bonded_))
    f_write_non_bonded_reparams = open(
        self.system_xml_non_bonded_reparams_file, &#34;w&#34;
    )
    for p in range(len(lines_non_bonded_)):
        f_write_non_bonded_reparams.write(lines_non_bonded_[p])
    f_write_non_bonded_reparams.close()
    f_ = open(self.system_xml_non_bonded_reparams_file)
    lines_ = f_.readlines()
    print(len(lines_) == len(lines_non_bonded))

    xml_off = open(self.reparameterised_intermediate_system_xml_file)
    xml_off_lines = xml_off.readlines()
    for i in range(len(xml_off_lines)):
        if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
            to_begin = int(i)
        if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
            to_end = int(i)

    lines_before_params = xml_off_lines[: to_begin + 4]
    f__ = open(self.system_xml_non_bonded_reparams_file)
    lines_params_non_bonded = f__.readlines()
    lines_after_params = xml_off_lines[to_end - 1 :]
    f_reparams_xml = open(self.reparameterised_system_xml_file, &#34;w&#34;)
    for x in lines_before_params:
        f_reparams_xml.write(x)
    for x in lines_params_non_bonded:
        f_reparams_xml.write(x)
    for x in lines_after_params:
        f_reparams_xml.write(x)
    f_reparams_xml.close()</code></pre>
</details>
</dd>
<dt id="parameterize.HostAmberXMLAmber.write_system_params"><code class="name flex">
<span>def <span class="ident">write_system_params</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the parameters obtained from the QM log files in a text file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_system_params(self):
    &#34;&#34;&#34;
    Saves the parameters obtained from the QM log files in a text file.
    &#34;&#34;&#34;
    # Charges from QM files
    df_charges = pd.read_csv(
        self.charge_parameter_file, header=None, delimiter=r&#34;\s+&#34;
    )
    df_charges.columns = [&#34;atom&#34;, &#34;charges&#34;]
    qm_charges = df_charges[&#34;charges&#34;].values.tolist()
    qm_charges = [round(num, 6) for num in qm_charges]
    # print(qm_charges)
    # Bond Parameters from QM files
    ppdb = PandasPdb()
    ppdb.read_pdb(self.system_qm_pdb)
    atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
    atom_name_list = [i - 1 for i in atom_name_list]
    # print(atom_name_list)
    df = pd.read_csv(
        self.bond_parameter_file, header=None, delimiter=r&#34;\s+&#34;
    )
    df.columns = [&#34;bond&#34;, &#34;k_bond&#34;, &#34;bond_length&#34;, &#34;bond_1&#34;, &#34;bond_2&#34;]
    # print(df.head())
    bond_1_list = df[&#34;bond_1&#34;].values.tolist()
    bond_1_list = [x - 1 + min(atom_name_list) for x in bond_1_list]
    bond_2_list = df[&#34;bond_2&#34;].values.tolist()
    bond_2_list = [x - 1 + min(atom_name_list) for x in bond_2_list]
    # print(bond_1_list)
    # print(bond_2_list)
    k_bond_list = df[&#34;k_bond&#34;].values.tolist()
    k_bond_list = [i * 1000.00 for i in k_bond_list]
    k_bond_list = [round(num, 10) for num in k_bond_list]
    # print(k_bond_list)
    bond_length_list = df[&#34;bond_length&#34;].values.tolist()
    bond_length_list = [i / 10.00 for i in bond_length_list]
    bond_length_list = [round(num, 6) for num in bond_length_list]
    # print(bond_length_list)
    # Angle Parameters from QM files
    ppdb = PandasPdb()
    ppdb.read_pdb(self.system_qm_pdb)
    atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
    atom_name_list = [i - 1 for i in atom_name_list]
    # print(atom_name_list)
    df = pd.read_csv(
        self.angle_parameter_file, header=None, delimiter=r&#34;\s+&#34;
    )
    df.columns = [
        &#34;angle&#34;,
        &#34;k_angle&#34;,
        &#34;angle_degrees&#34;,
        &#34;angle_1&#34;,
        &#34;angle_2&#34;,
        &#34;angle_3&#34;,
    ]
    # print(df.head())
    angle_1_list = df[&#34;angle_1&#34;].values.tolist()
    angle_1_list = [x - 1 + min(atom_name_list) for x in angle_1_list]
    # print(angle_1_list)
    angle_2_list = df[&#34;angle_2&#34;].values.tolist()
    angle_2_list = [x - 1 + min(atom_name_list) for x in angle_2_list]
    # print(angle_2_list)
    angle_3_list = df[&#34;angle_3&#34;].values.tolist()
    angle_3_list = [x - 1 + min(atom_name_list) for x in angle_3_list]
    # print(angle_3_list)
    k_angle_list = df[&#34;k_angle&#34;].values.tolist()
    k_angle_list = [round(num, 6) for num in k_angle_list]
    # print(k_angle_list)
    angle_list = df[&#34;angle_degrees&#34;].values.tolist()
    angle_list = [(i * math.pi) / 180.00 for i in angle_list]
    angle_list = [round(num, 6) for num in angle_list]
    # print(angle_list)
    xml = open(self.system_qm_params_file, &#34;w&#34;)
    xml.write(&#34;Begin writing the Bond Parameters&#34; + &#34;\n&#34;)
    for i in range(len(k_bond_list)):
        xml.write(
            &#34;                                &#34;
            + &#34;&lt;Bond&#34;
            + &#34; &#34;
            + &#34;d=&#34;
            + &#39;&#34;&#39;
            + str(bond_length_list[i])
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;k=&#34;
            + &#39;&#34;&#39;
            + str(k_bond_list[i])
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p1=&#34;
            + &#39;&#34;&#39;
            + str(bond_1_list[i])
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p2=&#34;
            + &#39;&#34;&#39;
            + str(bond_2_list[i])
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
            + &#34;\n&#34;
        )
    xml.write(&#34;Finish writing the Bond Parameters&#34; + &#34;\n&#34;)
    xml.write(&#34;Begin writing the Angle Parameters&#34; + &#34;\n&#34;)
    for i in range(len(k_angle_list)):
        xml.write(
            &#34;                                &#34;
            + &#34;&lt;Angle&#34;
            + &#34; &#34;
            + &#34;a=&#34;
            + &#39;&#34;&#39;
            + str(angle_list[i])
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;k=&#34;
            + &#39;&#34;&#39;
            + str(k_angle_list[i])
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p1=&#34;
            + &#39;&#34;&#39;
            + str(angle_1_list[i])
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p2=&#34;
            + &#39;&#34;&#39;
            + str(angle_2_list[i])
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;p3=&#34;
            + &#39;&#34;&#39;
            + str(angle_3_list[i])
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
            + &#34;\n&#34;
        )
    xml.write(&#34;Finish writing the Angle Parameters&#34; + &#34;\n&#34;)
    xml.write(&#34;Begin writing the Charge Parameters&#34; + &#34;\n&#34;)
    for i in range(len(qm_charges)):
        xml.write(
            &#34;&lt;Particle&#34;
            + &#34; &#34;
            + &#34;q=&#34;
            + &#39;&#34;&#39;
            + str(qm_charges[i])
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;eps=&#34;
            + &#39;&#34;&#39;
            + str(0.00)
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;sig=&#34;
            + &#39;&#34;&#39;
            + str(0.00)
            + &#39;&#34;&#39;
            + &#34; &#34;
            + &#34;atom=&#34;
            + &#39;&#34;&#39;
            + str(atom_name_list[i])
            + &#39;&#34;&#39;
            + &#34;/&gt;&#34;
            + &#34;\n&#34;
        )
    xml.write(&#34;Finish writing the Charge Parameters&#34; + &#34;\n&#34;)
    xml.close()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.MergeHostGuestTopology"><code class="flex name class">
<span>class <span class="ident">MergeHostGuestTopology</span></span>
<span>(</span><span>host_prmtop, guest_prmtop, host_inpcrd, guest_inpcrd, system_prmtop, system_inpcrd)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to merge the host and guest topology and coordinate
files.</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>host_prmtop</code></strong> :&ensp;<code>str</code></dt>
<dd>Topology file of the receptor.</dd>
<dt><strong><code>guest_prmtop</code></strong> :&ensp;<code>str</code></dt>
<dd>Topology file of the ligand.</dd>
<dt><strong><code>host_inpcrd</code></strong> :&ensp;<code>str</code></dt>
<dd>Coordinate file of the receptor.</dd>
<dt><strong><code>guest_inpcrd</code></strong> :&ensp;<code>str</code></dt>
<dd>Coordinate file of the ligand.</dd>
<dt><strong><code>system_prmtop</code></strong> :&ensp;<code>str</code></dt>
<dd>Topology file of the receptor - ligand complex.</dd>
<dt><strong><code>system_inpcrd</code></strong> :&ensp;<code>str</code></dt>
<dd>Coordinate file of the receptor - ligand complex.</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>host_prmtop</code></strong> :&ensp;<code>str</code></dt>
<dd>Topology file of the receptor.</dd>
<dt><strong><code>guest_prmtop</code></strong> :&ensp;<code>str</code></dt>
<dd>Topology file of the ligand.</dd>
<dt><strong><code>host_inpcrd</code></strong> :&ensp;<code>str</code></dt>
<dd>Coordinate file of the receptor.</dd>
<dt><strong><code>guest_inpcrd</code></strong> :&ensp;<code>str</code></dt>
<dd>Coordinate file of the ligand.</dd>
<dt><strong><code>system_prmtop</code></strong> :&ensp;<code>str</code></dt>
<dd>Topology file of the receptor - ligand complex.</dd>
<dt><strong><code>system_inpcrd</code></strong> :&ensp;<code>str</code></dt>
<dd>Coordinate file of the receptor - ligand complex.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MergeHostGuestTopology:
    &#34;&#34;&#34;
    This class is used to merge the host and guest topology and coordinate
    files.

    ...

    Attributes
    ----------
    host_prmtop : str
        Topology file of the receptor.

    guest_prmtop : str
        Topology file of the ligand.

    host_inpcrd : str
        Coordinate file of the receptor. 

    guest_inpcrd : str
        Coordinate file of the ligand. 

    system_prmtop : str
        Topology file of the receptor - ligand complex. 

    system_inpcrd : str
        Coordinate file of the receptor - ligand complex. 

    &#34;&#34;&#34;
    def __init__(
        self,
        host_prmtop,
        guest_prmtop,
        host_inpcrd,
        guest_inpcrd,
        system_prmtop,
        system_inpcrd,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        host_prmtop : str
            Topology file of the receptor.

        guest_prmtop : str
            Topology file of the ligand.

        host_inpcrd : str
            Coordinate file of the receptor. 

        guest_inpcrd : str
            Coordinate file of the ligand. 

        system_prmtop : str
            Topology file of the receptor - ligand complex. 

        system_inpcrd : str
            Coordinate file of the receptor - ligand complex. 

        &#34;&#34;&#34;
        self.host_prmtop = host_prmtop
        self.guest_prmtop = guest_prmtop
        self.host_inpcrd = host_inpcrd
        self.guest_inpcrd = guest_inpcrd
        self.system_prmtop = system_prmtop
        self.system_inpcrd = system_inpcrd

    def merge_topology_files(self):
        &#34;&#34;&#34;
        Merge the host and guest topology and coordinate files.
        &#34;&#34;&#34;
        print(
            &#34;Merging the &#34;
            + self.host_prmtop
            + &#34; &#34;
            + self.guest_prmtop
            + &#34; files&#34;
        )
        print(
            &#34;Merging the &#34;
            + self.host_inpcrd
            + &#34; &#34;
            + self.guest_inpcrd
            + &#34; files&#34;
        )
        host_system = parmed.load_file(self.host_prmtop, xyz=self.host_inpcrd)
        guest_system = parmed.load_file(
            self.guest_prmtop, xyz=self.guest_inpcrd
        )
        system = host_system + guest_system
        system.save(self.system_prmtop, overwrite=True)
        system.save(self.system_inpcrd, overwrite=True)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.MergeHostGuestTopology.merge_topology_files"><code class="name flex">
<span>def <span class="ident">merge_topology_files</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Merge the host and guest topology and coordinate files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_topology_files(self):
    &#34;&#34;&#34;
    Merge the host and guest topology and coordinate files.
    &#34;&#34;&#34;
    print(
        &#34;Merging the &#34;
        + self.host_prmtop
        + &#34; &#34;
        + self.guest_prmtop
        + &#34; files&#34;
    )
    print(
        &#34;Merging the &#34;
        + self.host_inpcrd
        + &#34; &#34;
        + self.guest_inpcrd
        + &#34; files&#34;
    )
    host_system = parmed.load_file(self.host_prmtop, xyz=self.host_inpcrd)
    guest_system = parmed.load_file(
        self.guest_prmtop, xyz=self.guest_inpcrd
    )
    system = host_system + guest_system
    system.save(self.system_prmtop, overwrite=True)
    system.save(self.system_inpcrd, overwrite=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.ParameterizeGuest"><code class="flex name class">
<span>class <span class="ident">ParameterizeGuest</span></span>
<span>(</span><span>vibrational_scaling, xyz_file='guest_coords.xyz', coordinate_file='guest_coordinates.txt', unprocessed_hessian_file='guest_unprocessed_hessian.txt', bond_list_file='guest_bond_list.txt', angle_list_file='guest_angle_list.txt', hessian_file='guest_hessian.txt', atom_names_file='guest_atom_names.txt', bond_parameter_file='guest_bonds.txt', angle_parameter_file='guest_angles.txt', charge_parameter_file='guest_charges.txt', guest_pdb='guest_init_II.pdb', proper_dihedral_file='proper_dihedrals.txt')</span>
</code></dt>
<dd>
<div class="desc"><p>A class used to obtain force field parameters for the ligand (bond,
angle and charge parameters) from QM calculations.</p>
<p>This class contain methods to process the output files of the
Gaussian QM output files (.chk, .fchk and .log files). Methods
in the class extract the unprocessed hessian matrix from the
Gaussian QM calculations, processes it and uses the Modified
Seminario Method to ontain the bond and angle parameters. The
class also extracts the QM charges from the log file.</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>vibrational_scaling</code></strong> :&ensp;<code>float</code></dt>
<dd>Vibrational scaling factor for the DFT deficits/anharmonicities
in the bond parameters.</dd>
<dt><strong><code>xyz_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>XYZ file for ligand coordinates obtained from its corresponding
formatted checkpoint file.</dd>
<dt><strong><code>coordinate_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the ligand coordinates (extracted
from the formatted checkpoint file).</dd>
<dt><strong><code>unprocessed_hessian_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Unprocessed hessian matrix of the ligand obtained from the
formatted checkpoint file.</dd>
<dt><strong><code>bond_list_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the bond information of the ligand extracted
from the log file.</dd>
<dt><strong><code>angle_list_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the angle information of the ligand extracted
from the log file.</dd>
<dt><strong><code>hessian_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Processed hessian matrix of the ligand.</dd>
<dt><strong><code>atom_names_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the list of atom names from the fchk file.</dd>
<dt><strong><code>bond_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the bond parameters for the ligand obtained
using the Modified Seminario method.</dd>
<dt><strong><code>angle_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the angle parameters of the ligand obtained
using the Modified Seminario method..</dd>
<dt><strong><code>charge_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the QM charges of the ligand.</dd>
<dt><strong><code>guest_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ligand PDB file with atom numbers beginning from 1.</dd>
<dt><strong><code>proper_dihedral_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A text file containing proper dihedral angles of the ligand.</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vibrational_scaling</code></strong> :&ensp;<code>float</code></dt>
<dd>Vibrational scaling factor for the DFT deficits/anharmonicities
in the bond parameters.</dd>
<dt><strong><code>xyz_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>XYZ file for ligand coordinates obtained from its corresponding
formatted checkpoint file.</dd>
<dt><strong><code>coordinate_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the ligand coordinates (extracted
from the formatted checkpoint file).</dd>
<dt><strong><code>unprocessed_hessian_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Unprocessed hessian matrix of the ligand obtained from the
formatted checkpoint file.</dd>
<dt><strong><code>bond_list_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the bond information of the ligand extracted
from the log file.</dd>
<dt><strong><code>angle_list_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the angle information of the ligand extracted
from the log file.</dd>
<dt><strong><code>hessian_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Processed hessian matrix of the ligand.</dd>
<dt><strong><code>atom_names_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the list of atom names from the fchk file.</dd>
<dt><strong><code>bond_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the bond parameters for the ligand obtained
using the Modified Seminario method.</dd>
<dt><strong><code>angle_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the angle parameters of the ligand.</dd>
<dt><strong><code>charge_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the QM charges of the ligand.</dd>
<dt><strong><code>guest_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ligand PDB file with atom numbers beginning from 1.</dd>
<dt><strong><code>proper_dihedral_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A text file containing proper dihedral angles of the ligand.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterizeGuest:
    &#34;&#34;&#34;
    A class used to obtain force field parameters for the ligand (bond, 
    angle and charge parameters) from QM calculations.

    This class contain methods to process the output files of the 
    Gaussian QM output files (.chk, .fchk and .log files). Methods 
    in the class extract the unprocessed hessian matrix from the 
    Gaussian QM calculations, processes it and uses the Modified 
    Seminario Method to ontain the bond and angle parameters. The 
    class also extracts the QM charges from the log file.

    ...

    Attributes
    ----------
    vibrational_scaling: float
        Vibrational scaling factor for the DFT deficits/anharmonicities
        in the bond parameters.

    xyz_file: str, optional
        XYZ file for ligand coordinates obtained from its corresponding 
        formatted checkpoint file.

    coordinate_file: str, optional
        Text file containing the ligand coordinates (extracted
        from the formatted checkpoint file).

    unprocessed_hessian_file: str, optional
        Unprocessed hessian matrix of the ligand obtained from the 
        formatted checkpoint file.

    bond_list_file: str, optional
        Text file containing the bond information of the ligand extracted 
        from the log file.

    angle_list_file: str, optional
        Text file containing the angle information of the ligand extracted 
        from the log file.

    hessian_file: str, optional
        Processed hessian matrix of the ligand.

    atom_names_file: str, optional
        Text file containing the list of atom names from the fchk file.

    bond_parameter_file: str, optional
        Text file containing the bond parameters for the ligand obtained 
        using the Modified Seminario method.

    angle_parameter_file: str, optional
        Text file containing the angle parameters of the ligand obtained 
        using the Modified Seminario method..

    charge_parameter_file: str, optional
        Text file containing the QM charges of the ligand.

    guest_pdb: str, optional
        Ligand PDB file with atom numbers beginning from 1.

    proper_dihedral_file: str, optional
        A text file containing proper dihedral angles of the ligand.

    &#34;&#34;&#34;
    def __init__(
        self,
        vibrational_scaling,
        xyz_file=&#34;guest_coords.xyz&#34;,
        coordinate_file=&#34;guest_coordinates.txt&#34;,
        unprocessed_hessian_file=&#34;guest_unprocessed_hessian.txt&#34;,
        bond_list_file=&#34;guest_bond_list.txt&#34;,
        angle_list_file=&#34;guest_angle_list.txt&#34;,
        hessian_file=&#34;guest_hessian.txt&#34;,
        atom_names_file=&#34;guest_atom_names.txt&#34;,
        bond_parameter_file=&#34;guest_bonds.txt&#34;,
        angle_parameter_file=&#34;guest_angles.txt&#34;,
        charge_parameter_file=&#34;guest_charges.txt&#34;,
        guest_pdb=&#34;guest_init_II.pdb&#34;,
        proper_dihedral_file=&#34;proper_dihedrals.txt&#34;,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        vibrational_scaling: float
            Vibrational scaling factor for the DFT deficits/anharmonicities
            in the bond parameters.

        xyz_file: str, optional
            XYZ file for ligand coordinates obtained from its corresponding 
            formatted checkpoint file.

        coordinate_file: str, optional
            Text file containing the ligand coordinates (extracted
            from the formatted checkpoint file).

        unprocessed_hessian_file: str, optional
            Unprocessed hessian matrix of the ligand obtained from the 
            formatted checkpoint file.

        bond_list_file: str, optional
            Text file containing the bond information of the ligand extracted 
            from the log file.

        angle_list_file: str, optional

            Text file containing the angle information of the ligand extracted 
            from the log file.

        hessian_file: str, optional
            Processed hessian matrix of the ligand.

        atom_names_file: str, optional
            Text file containing the list of atom names from the fchk file.

        bond_parameter_file: str, optional
            Text file containing the bond parameters for the ligand obtained 
            using the Modified Seminario method.

        angle_parameter_file: str, optional
            Text file containing the angle parameters of the ligand.

        charge_parameter_file: str, optional
            Text file containing the QM charges of the ligand.

        guest_pdb: str, optional
            Ligand PDB file with atom numbers beginning from 1.

        proper_dihedral_file: str, optional
            A text file containing proper dihedral angles of the ligand.

        &#34;&#34;&#34;
        self.vibrational_scaling = vibrational_scaling
        self.xyz_file = xyz_file
        self.coordinate_file = coordinate_file
        self.unprocessed_hessian_file = unprocessed_hessian_file
        self.bond_list_file = bond_list_file
        self.angle_list_file = angle_list_file
        self.hessian_file = hessian_file
        self.atom_names_file = atom_names_file
        self.bond_parameter_file = bond_parameter_file
        self.angle_parameter_file = angle_parameter_file
        self.charge_parameter_file = charge_parameter_file
        self.guest_pdb = guest_pdb
        self.proper_dihedral_file = proper_dihedral_file

    def get_xyz(self):
        &#34;&#34;&#34;
        Saves XYZ file from the formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
        with open(fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
                no_coordinates = int(no_coordinates[0])
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                to_begin = int(i)
        cartesian_coords = lines[
            to_begin + 1 : to_begin + 1 + int(math.ceil(no_coordinates / 5))
        ]
        cartesian_list = []
        for i in range(len(cartesian_coords)):
            cartesian_list.append(cartesian_coords[i].strip().split())
        coordinates_list = [
            item for sublist in cartesian_list for item in sublist
        ]
        list_coords = [float(x) * float(0.529) for x in coordinates_list]
        for i in range(len(lines)):
            if &#34;Atomic numbers&#34; in lines[i]:
                to_begin = int(i)
            if &#34;Nuclear charges&#34; in lines[i]:
                to_end = int(i)
        atomic_numbers = lines[to_begin + 1 : to_end]
        atom_numbers = []
        for i in range(len(atomic_numbers)):
            atom_numbers.append(atomic_numbers[i].strip().split())
        numbers = [item for sublist in atom_numbers for item in sublist]
        N = int(no_coordinates / 3)
        # Opens the new xyz file
        file = open(self.xyz_file, &#34;w&#34;)
        file.write(str(N) + &#34;\n \n&#34;)
        coords = np.zeros((N, 3))
        n = 0
        names = []
        # Gives name for atomic number
        for x in range(0, len(numbers)):
            names.append(element_list[int(numbers[x]) - 1][1])
        # Print coordinates to new input_coords.xyz file
        for i in range(0, N):
            for j in range(0, 3):
                coords[i][j] = list_coords[n]
                n = n + 1
            file.write(
                names[i]
                + str(round(coords[i][0], 3))
                + &#34; &#34;
                + str(round(coords[i][1], 3))
                + &#34; &#34;
                + str(round(coords[i][2], 3))
                + &#34;\n&#34;
            )
        file.close()
        np.savetxt(self.coordinate_file, coords, fmt=&#34;%s&#34;)

    def get_unprocessed_hessian(self):
        &#34;&#34;&#34;
        Saves a text file of the unprocessed hessian matrix from the 
        formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
        with open(fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Cartesian Force Constants&#34; in lines[i]:
                no_hessian = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
                no_hessian = int(no_hessian[0])
        for i in range(len(lines)):
            if &#34;Cartesian Force Constants&#34; in lines[i]:
                to_begin = int(i)
        hessian = lines[
            to_begin + 1 : to_begin + 1 + int(math.ceil(no_hessian / 5))
        ]
        hessian_list = []
        for i in range(len(hessian)):
            hessian_list.append(hessian[i].strip().split())
        unprocessed_Hessian = [
            item for sublist in hessian_list for item in sublist
        ]
        np.savetxt(
            self.unprocessed_hessian_file, unprocessed_Hessian, fmt=&#34;%s&#34;
        )

    def get_bond_angles(self):
        &#34;&#34;&#34;
        Saves a text file containing bonds and angles from the gaussian 
        log file.
        &#34;&#34;&#34;
        log_file = self.guest_pdb[:-4] + &#34;.log&#34;
        fid = open(log_file, &#34;r&#34;)
        tline = fid.readline()
        bond_list = []
        angle_list = []
        n = 1
        n_bond = 1
        n_angle = 1
        tmp = &#34;R&#34;  # States if bond or angle
        B = []
        # Finds the bond and angles from the .log file
        while tline:
            tline = fid.readline()
            # Line starts at point when bond and angle list occurs
            if (
                len(tline) &gt; 80
                and tline[0:81].strip()
                == &#34;! Name  Definition              Value          Derivative Info.                !&#34;
            ):
                tline = fid.readline()
                tline = fid.readline()
                # Stops when all bond and angles recorded
                while (tmp[0] == &#34;R&#34;) or (tmp[0] == &#34;A&#34;):
                    line = tline.split()
                    tmp = line[1]
                    # Bond or angles listed as string
                    list_terms = line[2][2:-1]
                    # Bond List
                    if tmp[0] == &#34;R&#34;:
                        x = list_terms.split(&#34;,&#34;)
                        # Subtraction due to python array indexing at 0
                        x = [(int(i) - 1) for i in x]
                        bond_list.append(x)
                        # Angle List
                    if tmp[0] == &#34;A&#34;:
                        x = list_terms.split(&#34;,&#34;)
                        # Subtraction due to python array indexing at 0
                        x = [(int(i) - 1) for i in x]
                        angle_list.append(x)
                    tline = fid.readline()
                # Leave loop
                tline = -1
        np.savetxt(self.bond_list_file, bond_list, fmt=&#34;%s&#34;)
        np.savetxt(self.angle_list_file, angle_list, fmt=&#34;%s&#34;)

    def get_hessian(self):
        &#34;&#34;&#34;
        Extracts hessian matrix from the unprocessed hessian matrix 
        and saves into a new file.
        &#34;&#34;&#34;
        unprocessed_Hessian = np.loadtxt(self.unprocessed_hessian_file)
        fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
        with open(fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
                no_coordinates = int(no_coordinates[0])
        N = int(no_coordinates / 3)
        length_hessian = 3 * N
        hessian = np.zeros((length_hessian, length_hessian))
        m = 0
        # Write the hessian in a 2D array format
        for i in range(0, (length_hessian)):
            for j in range(0, (i + 1)):
                hessian[i][j] = unprocessed_Hessian[m]
                hessian[j][i] = unprocessed_Hessian[m]
                m = m + 1
        hessian = (hessian * (627.509391)) / (
            0.529 ** 2
        )  # Change from Hartree/bohr to kcal/mol/ang
        np.savetxt(self.hessian_file, hessian, fmt=&#34;%s&#34;)

    def get_atom_names(self):
        &#34;&#34;&#34;
        Saves a list of atom names from the formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
        with open(fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Atomic numbers&#34; in lines[i]:
                to_begin = int(i)
            if &#34;Nuclear charges&#34; in lines[i]:
                to_end = int(i)
        atomic_numbers = lines[to_begin + 1 : to_end]
        atom_numbers = []
        for i in range(len(atomic_numbers)):
            atom_numbers.append(atomic_numbers[i].strip().split())
        numbers = [item for sublist in atom_numbers for item in sublist]
        names = []
        # Gives name for atomic number
        for x in range(0, len(numbers)):
            names.append(element_list[int(numbers[x]) - 1][1])
        atom_names = []
        for i in range(0, len(names)):
            atom_names.append(names[i].strip() + str(i + 1))
        np.savetxt(self.atom_names_file, atom_names, fmt=&#34;%s&#34;)

    def get_bond_angle_params(self):
        &#34;&#34;&#34;
        Saves the bond and angle parameter files obtained from 
        the formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
        with open(fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
                no_coordinates = int(no_coordinates[0])
        N = int(no_coordinates / 3)
        coords = np.loadtxt(self.coordinate_file)
        hessian = np.loadtxt(self.hessian_file)
        bond_list = np.loadtxt(self.bond_list_file, dtype=int)
        atom_names = np.loadtxt(self.atom_names_file, dtype=str)
        # Find bond lengths
        bond_lengths = np.zeros((N, N))
        for i in range(0, N):
            for j in range(0, N):
                diff_i_j = np.array(coords[i, :]) - np.array(coords[j, :])
                bond_lengths[i][j] = np.linalg.norm(diff_i_j)
        eigenvectors = np.empty((3, 3, N, N), dtype=complex)
        eigenvalues = np.empty((N, N, 3), dtype=complex)
        partial_hessian = np.zeros((3, 3))
        for i in range(0, N):
            for j in range(0, N):
                partial_hessian = hessian[
                    (i * 3) : ((i + 1) * 3), (j * 3) : ((j + 1) * 3)
                ]
                [a, b] = np.linalg.eig(partial_hessian)
                eigenvalues[i, j, :] = a
                eigenvectors[:, :, i, j] = b
        # Modified Seminario method to find the bond parameters and print them to file
        file_bond = open(self.bond_parameter_file, &#34;w&#34;)
        k_b = np.zeros(len(bond_list))
        bond_length_list = np.zeros(len(bond_list))
        unique_values_bonds = []  # Used to find average values
        for i in range(0, len(bond_list)):
            AB = force_constant_bond(
                bond_list[i][0],
                bond_list[i][1],
                eigenvalues,
                eigenvectors,
                coords,
            )
            BA = force_constant_bond(
                bond_list[i][1],
                bond_list[i][0],
                eigenvalues,
                eigenvectors,
                coords,
            )
            # Order of bonds sometimes causes slight differences, find the mean
            k_b[i] = np.real((AB + BA) / 2)
            # Vibrational_scaling takes into account DFT deficities/ anharmocity
            vibrational_scaling_squared = self.vibrational_scaling ** 2
            k_b[i] = k_b[i] * vibrational_scaling_squared
            bond_length_list[i] = bond_lengths[bond_list[i][0]][
                bond_list[i][1]
            ]
            file_bond.write(
                atom_names[bond_list[i][0]]
                + &#34;-&#34;
                + atom_names[bond_list[i][1]]
                + &#34;  &#34;
            )
            file_bond.write(
                str(&#34;%#.5g&#34; % k_b[i])
                + &#34;   &#34;
                + str(&#34;%#.4g&#34; % bond_length_list[i])
                + &#34;   &#34;
                + str(bond_list[i][0] + 1)
                + &#34;   &#34;
                + str(bond_list[i][1] + 1)
            )
            file_bond.write(&#34;\n&#34;)
            unique_values_bonds.append(
                [
                    atom_names[bond_list[i][0]],
                    atom_names[bond_list[i][1]],
                    k_b[i],
                    bond_length_list[i],
                    1,
                ]
            )
        file_bond.close()
        angle_list = np.loadtxt(self.angle_list_file, dtype=int)
        # Modified Seminario method to find the angle parameters and print them to file
        file_angle = open(self.angle_parameter_file, &#34;w&#34;)
        k_theta = np.zeros(len(angle_list))
        theta_0 = np.zeros(len(angle_list))
        unique_values_angles = []  # Used to find average values
        # Modified Seminario part goes here ...
        # Connectivity information for Modified Seminario Method
        central_atoms_angles = []
        # A structure is created with the index giving the central atom of the angle, 
        # an array then lists the angles with that central atom.
        # i.e. central_atoms_angles{3} contains an array of angles with central atom 3
        for i in range(0, len(coords)):
            central_atoms_angles.append([])
            for j in range(0, len(angle_list)):
                if i == angle_list[j][1]:
                    # For angle ABC, atoms A C are written to array
                    AC_array = [angle_list[j][0], angle_list[j][2], j]
                    central_atoms_angles[i].append(AC_array)
                    # For angle ABC, atoms C A are written to array
                    CA_array = [angle_list[j][2], angle_list[j][0], j]
                    central_atoms_angles[i].append(CA_array)
        # Sort rows by atom number
        for i in range(0, len(coords)):
            central_atoms_angles[i] = sorted(
                central_atoms_angles[i], key=itemgetter(0)
            )
        # Find normals u_PA for each angle
        unit_PA_all_angles = []
        for i in range(0, len(central_atoms_angles)):
            unit_PA_all_angles.append([])
            for j in range(0, len(central_atoms_angles[i])):
                # For the angle at central_atoms_angles[i][j,:] the corresponding u_PA value
                # is found for the plane ABC and bond AB, where ABC corresponds to the order 
                # of the arguements. This is why the reverse order was also added
                unit_PA_all_angles[i].append(
                    u_PA_from_angles(
                        central_atoms_angles[i][j][0],
                        i,
                        central_atoms_angles[i][j][1],
                        coords,
                    )
                )
        # Finds the contributing factors from the other angle terms scaling_factor_all_angles 
        # = cell(max(max(angle_list))); %This array will contain scaling factor and angle
        # list position
        scaling_factor_all_angles = []
        for i in range(0, len(central_atoms_angles)):
            scaling_factor_all_angles.append([])
            for j in range(0, len(central_atoms_angles[i])):
                n = 1
                m = 1
                angles_around = 0
                additional_contributions = 0
                scaling_factor_all_angles[i].append([0, 0])
                # Position in angle list
                scaling_factor_all_angles[i][j][1] = central_atoms_angles[i][
                    j
                ][2]
                # Goes through the list of angles with the same central atom and computes the 
                # term need for the modified Seminario method
                # Forwards directions, finds the same bonds with the central atom i
                while (
                    (j + n) &lt; len(central_atoms_angles[i])
                ) and central_atoms_angles[i][j][0] == central_atoms_angles[i][
                    j + n
                ][
                    0
                ]:
                    additional_contributions = (
                        additional_contributions
                        + (
                            abs(
                                np.dot(
                                    unit_PA_all_angles[i][j][:],
                                    unit_PA_all_angles[i][j + n][:],
                                )
                            )
                        )
                        ** 2
                    )
                    n = n + 1
                    angles_around = angles_around + 1
                # Backwards direction, finds the same bonds with the central atom i
                while ((j - m) &gt;= 0) and central_atoms_angles[i][j][
                    0
                ] == central_atoms_angles[i][j - m][0]:
                    additional_contributions = (
                        additional_contributions
                        + (
                            abs(
                                np.dot(
                                    unit_PA_all_angles[i][j][:],
                                    unit_PA_all_angles[i][j - m][:],
                                )
                            )
                        )
                        ** 2
                    )
                    m = m + 1
                    angles_around = angles_around + 1
                if n != 1 or m != 1:
                    # Finds the mean value of the additional contribution to change to normal 
                    # Seminario method comment out + part
                    scaling_factor_all_angles[i][j][0] = 1 + (
                        additional_contributions / (m + n - 2)
                    )
                else:
                    scaling_factor_all_angles[i][j][0] = 1
        scaling_factors_angles_list = []
        for i in range(0, len(angle_list)):
            scaling_factors_angles_list.append([])
        # Orders the scaling factors according to the angle list
        for i in range(0, len(central_atoms_angles)):
            for j in range(0, len(central_atoms_angles[i])):
                scaling_factors_angles_list[
                    scaling_factor_all_angles[i][j][1]
                ].append(scaling_factor_all_angles[i][j][0])
        # Finds the angle force constants with the scaling factors included for each angle
        for i in range(0, len(angle_list)):
            # Ensures that there is no difference when the ordering is changed
            [AB_k_theta, AB_theta_0] = force_angle_constant(
                angle_list[i][0],
                angle_list[i][1],
                angle_list[i][2],
                bond_lengths,
                eigenvalues,
                eigenvectors,
                coords,
                scaling_factors_angles_list[i][0],
                scaling_factors_angles_list[i][1],
            )
            [BA_k_theta, BA_theta_0] = force_angle_constant(
                angle_list[i][2],
                angle_list[i][1],
                angle_list[i][0],
                bond_lengths,
                eigenvalues,
                eigenvectors,
                coords,
                scaling_factors_angles_list[i][1],
                scaling_factors_angles_list[i][0],
            )
            k_theta[i] = (AB_k_theta + BA_k_theta) / 2
            theta_0[i] = (AB_theta_0 + BA_theta_0) / 2
            # Vibrational_scaling takes into account DFT deficities/ anharmonicity
            k_theta[i] = k_theta[i] * vibrational_scaling_squared
            file_angle.write(
                atom_names[angle_list[i][0]]
                + &#34;-&#34;
                + atom_names[angle_list[i][1]]
                + &#34;-&#34;
                + atom_names[angle_list[i][2]]
                + &#34;  &#34;
            )
            file_angle.write(
                str(&#34;%#.4g&#34; % k_theta[i])
                + &#34;   &#34;
                + str(&#34;%#.4g&#34; % theta_0[i])
                + &#34;   &#34;
                + str(angle_list[i][0] + 1)
                + &#34;   &#34;
                + str(angle_list[i][1] + 1)
                + &#34;   &#34;
                + str(angle_list[i][2] + 1)
            )
            file_angle.write(&#34;\n&#34;)
            unique_values_angles.append(
                [
                    atom_names[angle_list[i][0]],
                    atom_names[angle_list[i][1]],
                    atom_names[angle_list[i][2]],
                    k_theta[i],
                    theta_0[i],
                    1,
                ]
            )
        file_angle.close()

    def get_charges(self):
        &#34;&#34;&#34;
        Saves the atomic charges in a text file obtained from
        the Gaussian log file.
        &#34;&#34;&#34;
        log_file = self.guest_pdb[:-4] + &#34;.log&#34;
        with open(log_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Fitting point charges to electrostatic potential&#34; in lines[i]:
                to_begin = int(i)
            if &#34; Sum of ESP charges =&#34; in lines[i]:
                to_end = int(i)
        charges = lines[to_begin + 4 : to_end]
        charge_list = []
        for i in range(len(charges)):
            charge_list.append(charges[i].strip().split())
        charge_list_value = []
        atom_list = []
        for i in range(len(charge_list)):
            charge_list_value.append(charge_list[i][2])
            atom_list.append(charge_list[i][1])
        data_tuples = list(zip(atom_list, charge_list_value))
        df_charge = pd.DataFrame(data_tuples, columns=[&#34;Atom&#34;, &#34;Charge&#34;])
        df_charge.to_csv(
            self.charge_parameter_file, index=False, header=False, sep=&#34; &#34;
        )

    def get_proper_dihedrals(self):
        &#34;&#34;&#34;
        Saves proper dihedral angles of the ligand in a text file.
        &#34;&#34;&#34;
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_pdb)
        no_atoms = len(ppdb.df[&#34;ATOM&#34;])
        atom_index_list = []
        for i in range(no_atoms):
            atom_index_list.append(i + 1)
        possible_dihedrals = []
        for dihed in itertools.permutations(atom_index_list, 4):
            possible_dihedrals.append(dihed)
        df_bonds = pd.read_csv(
            self.bond_parameter_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df_bonds.columns = [
            &#34;bond&#34;,
            &#34;k_bond&#34;,
            &#34;bond_length&#34;,
            &#34;bond_1&#34;,
            &#34;bond_2&#34;,
        ]
        bond1 = df_bonds[&#34;bond_1&#34;].values.tolist()
        bond2 = df_bonds[&#34;bond_2&#34;].values.tolist()
        bond_list_list = []
        for i in range(len(bond1)):
            args = (bond1[i], bond2[i])
            bond_list_list.append(list(args))
        reverse_bond_list_list = []
        for bonds in bond_list_list:
            reverse_bond_list_list.append(reverse_list(bonds))
        bond_lists = bond_list_list + reverse_bond_list_list
        proper_dihed_repeated = []
        for i in range(len(possible_dihedrals)):
            dihed_frag = (
                [possible_dihedrals[i][0], possible_dihedrals[i][1]],
                [possible_dihedrals[i][1], possible_dihedrals[i][2]],
                [possible_dihedrals[i][2], possible_dihedrals[i][3]],
            )
            a = [
                dihed_frag[0] in bond_lists,
                dihed_frag[1] in bond_lists,
                dihed_frag[2] in bond_lists,
            ]
            if a == [True, True, True]:
                proper_dihed_repeated.append(possible_dihedrals[i])

        len_repeated_dihed_list = len(proper_dihed_repeated)
        proper_dihedrals = proper_dihed_repeated
        for x in proper_dihedrals:
            z = x[::-1]
            if z in proper_dihedrals:
                proper_dihedrals.remove(z)
        len_non_repeated_dihed_list = len(proper_dihedrals)
        # print(len_repeated_dihed_list == len_non_repeated_dihed_list * 2)
        np.savetxt(self.proper_dihedral_file, proper_dihedrals, fmt=&#34;%s&#34;)
        # return(proper_dihedrals)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.ParameterizeGuest.get_atom_names"><code class="name flex">
<span>def <span class="ident">get_atom_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a list of atom names from the formatted checkpoint file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_atom_names(self):
    &#34;&#34;&#34;
    Saves a list of atom names from the formatted checkpoint file.
    &#34;&#34;&#34;
    fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
    with open(fchk_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Atomic numbers&#34; in lines[i]:
            to_begin = int(i)
        if &#34;Nuclear charges&#34; in lines[i]:
            to_end = int(i)
    atomic_numbers = lines[to_begin + 1 : to_end]
    atom_numbers = []
    for i in range(len(atomic_numbers)):
        atom_numbers.append(atomic_numbers[i].strip().split())
    numbers = [item for sublist in atom_numbers for item in sublist]
    names = []
    # Gives name for atomic number
    for x in range(0, len(numbers)):
        names.append(element_list[int(numbers[x]) - 1][1])
    atom_names = []
    for i in range(0, len(names)):
        atom_names.append(names[i].strip() + str(i + 1))
    np.savetxt(self.atom_names_file, atom_names, fmt=&#34;%s&#34;)</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeGuest.get_bond_angle_params"><code class="name flex">
<span>def <span class="ident">get_bond_angle_params</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the bond and angle parameter files obtained from
the formatted checkpoint file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bond_angle_params(self):
    &#34;&#34;&#34;
    Saves the bond and angle parameter files obtained from 
    the formatted checkpoint file.
    &#34;&#34;&#34;
    fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
    with open(fchk_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Current cartesian coordinates&#34; in lines[i]:
            no_coordinates = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
            no_coordinates = int(no_coordinates[0])
    N = int(no_coordinates / 3)
    coords = np.loadtxt(self.coordinate_file)
    hessian = np.loadtxt(self.hessian_file)
    bond_list = np.loadtxt(self.bond_list_file, dtype=int)
    atom_names = np.loadtxt(self.atom_names_file, dtype=str)
    # Find bond lengths
    bond_lengths = np.zeros((N, N))
    for i in range(0, N):
        for j in range(0, N):
            diff_i_j = np.array(coords[i, :]) - np.array(coords[j, :])
            bond_lengths[i][j] = np.linalg.norm(diff_i_j)
    eigenvectors = np.empty((3, 3, N, N), dtype=complex)
    eigenvalues = np.empty((N, N, 3), dtype=complex)
    partial_hessian = np.zeros((3, 3))
    for i in range(0, N):
        for j in range(0, N):
            partial_hessian = hessian[
                (i * 3) : ((i + 1) * 3), (j * 3) : ((j + 1) * 3)
            ]
            [a, b] = np.linalg.eig(partial_hessian)
            eigenvalues[i, j, :] = a
            eigenvectors[:, :, i, j] = b
    # Modified Seminario method to find the bond parameters and print them to file
    file_bond = open(self.bond_parameter_file, &#34;w&#34;)
    k_b = np.zeros(len(bond_list))
    bond_length_list = np.zeros(len(bond_list))
    unique_values_bonds = []  # Used to find average values
    for i in range(0, len(bond_list)):
        AB = force_constant_bond(
            bond_list[i][0],
            bond_list[i][1],
            eigenvalues,
            eigenvectors,
            coords,
        )
        BA = force_constant_bond(
            bond_list[i][1],
            bond_list[i][0],
            eigenvalues,
            eigenvectors,
            coords,
        )
        # Order of bonds sometimes causes slight differences, find the mean
        k_b[i] = np.real((AB + BA) / 2)
        # Vibrational_scaling takes into account DFT deficities/ anharmocity
        vibrational_scaling_squared = self.vibrational_scaling ** 2
        k_b[i] = k_b[i] * vibrational_scaling_squared
        bond_length_list[i] = bond_lengths[bond_list[i][0]][
            bond_list[i][1]
        ]
        file_bond.write(
            atom_names[bond_list[i][0]]
            + &#34;-&#34;
            + atom_names[bond_list[i][1]]
            + &#34;  &#34;
        )
        file_bond.write(
            str(&#34;%#.5g&#34; % k_b[i])
            + &#34;   &#34;
            + str(&#34;%#.4g&#34; % bond_length_list[i])
            + &#34;   &#34;
            + str(bond_list[i][0] + 1)
            + &#34;   &#34;
            + str(bond_list[i][1] + 1)
        )
        file_bond.write(&#34;\n&#34;)
        unique_values_bonds.append(
            [
                atom_names[bond_list[i][0]],
                atom_names[bond_list[i][1]],
                k_b[i],
                bond_length_list[i],
                1,
            ]
        )
    file_bond.close()
    angle_list = np.loadtxt(self.angle_list_file, dtype=int)
    # Modified Seminario method to find the angle parameters and print them to file
    file_angle = open(self.angle_parameter_file, &#34;w&#34;)
    k_theta = np.zeros(len(angle_list))
    theta_0 = np.zeros(len(angle_list))
    unique_values_angles = []  # Used to find average values
    # Modified Seminario part goes here ...
    # Connectivity information for Modified Seminario Method
    central_atoms_angles = []
    # A structure is created with the index giving the central atom of the angle, 
    # an array then lists the angles with that central atom.
    # i.e. central_atoms_angles{3} contains an array of angles with central atom 3
    for i in range(0, len(coords)):
        central_atoms_angles.append([])
        for j in range(0, len(angle_list)):
            if i == angle_list[j][1]:
                # For angle ABC, atoms A C are written to array
                AC_array = [angle_list[j][0], angle_list[j][2], j]
                central_atoms_angles[i].append(AC_array)
                # For angle ABC, atoms C A are written to array
                CA_array = [angle_list[j][2], angle_list[j][0], j]
                central_atoms_angles[i].append(CA_array)
    # Sort rows by atom number
    for i in range(0, len(coords)):
        central_atoms_angles[i] = sorted(
            central_atoms_angles[i], key=itemgetter(0)
        )
    # Find normals u_PA for each angle
    unit_PA_all_angles = []
    for i in range(0, len(central_atoms_angles)):
        unit_PA_all_angles.append([])
        for j in range(0, len(central_atoms_angles[i])):
            # For the angle at central_atoms_angles[i][j,:] the corresponding u_PA value
            # is found for the plane ABC and bond AB, where ABC corresponds to the order 
            # of the arguements. This is why the reverse order was also added
            unit_PA_all_angles[i].append(
                u_PA_from_angles(
                    central_atoms_angles[i][j][0],
                    i,
                    central_atoms_angles[i][j][1],
                    coords,
                )
            )
    # Finds the contributing factors from the other angle terms scaling_factor_all_angles 
    # = cell(max(max(angle_list))); %This array will contain scaling factor and angle
    # list position
    scaling_factor_all_angles = []
    for i in range(0, len(central_atoms_angles)):
        scaling_factor_all_angles.append([])
        for j in range(0, len(central_atoms_angles[i])):
            n = 1
            m = 1
            angles_around = 0
            additional_contributions = 0
            scaling_factor_all_angles[i].append([0, 0])
            # Position in angle list
            scaling_factor_all_angles[i][j][1] = central_atoms_angles[i][
                j
            ][2]
            # Goes through the list of angles with the same central atom and computes the 
            # term need for the modified Seminario method
            # Forwards directions, finds the same bonds with the central atom i
            while (
                (j + n) &lt; len(central_atoms_angles[i])
            ) and central_atoms_angles[i][j][0] == central_atoms_angles[i][
                j + n
            ][
                0
            ]:
                additional_contributions = (
                    additional_contributions
                    + (
                        abs(
                            np.dot(
                                unit_PA_all_angles[i][j][:],
                                unit_PA_all_angles[i][j + n][:],
                            )
                        )
                    )
                    ** 2
                )
                n = n + 1
                angles_around = angles_around + 1
            # Backwards direction, finds the same bonds with the central atom i
            while ((j - m) &gt;= 0) and central_atoms_angles[i][j][
                0
            ] == central_atoms_angles[i][j - m][0]:
                additional_contributions = (
                    additional_contributions
                    + (
                        abs(
                            np.dot(
                                unit_PA_all_angles[i][j][:],
                                unit_PA_all_angles[i][j - m][:],
                            )
                        )
                    )
                    ** 2
                )
                m = m + 1
                angles_around = angles_around + 1
            if n != 1 or m != 1:
                # Finds the mean value of the additional contribution to change to normal 
                # Seminario method comment out + part
                scaling_factor_all_angles[i][j][0] = 1 + (
                    additional_contributions / (m + n - 2)
                )
            else:
                scaling_factor_all_angles[i][j][0] = 1
    scaling_factors_angles_list = []
    for i in range(0, len(angle_list)):
        scaling_factors_angles_list.append([])
    # Orders the scaling factors according to the angle list
    for i in range(0, len(central_atoms_angles)):
        for j in range(0, len(central_atoms_angles[i])):
            scaling_factors_angles_list[
                scaling_factor_all_angles[i][j][1]
            ].append(scaling_factor_all_angles[i][j][0])
    # Finds the angle force constants with the scaling factors included for each angle
    for i in range(0, len(angle_list)):
        # Ensures that there is no difference when the ordering is changed
        [AB_k_theta, AB_theta_0] = force_angle_constant(
            angle_list[i][0],
            angle_list[i][1],
            angle_list[i][2],
            bond_lengths,
            eigenvalues,
            eigenvectors,
            coords,
            scaling_factors_angles_list[i][0],
            scaling_factors_angles_list[i][1],
        )
        [BA_k_theta, BA_theta_0] = force_angle_constant(
            angle_list[i][2],
            angle_list[i][1],
            angle_list[i][0],
            bond_lengths,
            eigenvalues,
            eigenvectors,
            coords,
            scaling_factors_angles_list[i][1],
            scaling_factors_angles_list[i][0],
        )
        k_theta[i] = (AB_k_theta + BA_k_theta) / 2
        theta_0[i] = (AB_theta_0 + BA_theta_0) / 2
        # Vibrational_scaling takes into account DFT deficities/ anharmonicity
        k_theta[i] = k_theta[i] * vibrational_scaling_squared
        file_angle.write(
            atom_names[angle_list[i][0]]
            + &#34;-&#34;
            + atom_names[angle_list[i][1]]
            + &#34;-&#34;
            + atom_names[angle_list[i][2]]
            + &#34;  &#34;
        )
        file_angle.write(
            str(&#34;%#.4g&#34; % k_theta[i])
            + &#34;   &#34;
            + str(&#34;%#.4g&#34; % theta_0[i])
            + &#34;   &#34;
            + str(angle_list[i][0] + 1)
            + &#34;   &#34;
            + str(angle_list[i][1] + 1)
            + &#34;   &#34;
            + str(angle_list[i][2] + 1)
        )
        file_angle.write(&#34;\n&#34;)
        unique_values_angles.append(
            [
                atom_names[angle_list[i][0]],
                atom_names[angle_list[i][1]],
                atom_names[angle_list[i][2]],
                k_theta[i],
                theta_0[i],
                1,
            ]
        )
    file_angle.close()</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeGuest.get_bond_angles"><code class="name flex">
<span>def <span class="ident">get_bond_angles</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a text file containing bonds and angles from the gaussian
log file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bond_angles(self):
    &#34;&#34;&#34;
    Saves a text file containing bonds and angles from the gaussian 
    log file.
    &#34;&#34;&#34;
    log_file = self.guest_pdb[:-4] + &#34;.log&#34;
    fid = open(log_file, &#34;r&#34;)
    tline = fid.readline()
    bond_list = []
    angle_list = []
    n = 1
    n_bond = 1
    n_angle = 1
    tmp = &#34;R&#34;  # States if bond or angle
    B = []
    # Finds the bond and angles from the .log file
    while tline:
        tline = fid.readline()
        # Line starts at point when bond and angle list occurs
        if (
            len(tline) &gt; 80
            and tline[0:81].strip()
            == &#34;! Name  Definition              Value          Derivative Info.                !&#34;
        ):
            tline = fid.readline()
            tline = fid.readline()
            # Stops when all bond and angles recorded
            while (tmp[0] == &#34;R&#34;) or (tmp[0] == &#34;A&#34;):
                line = tline.split()
                tmp = line[1]
                # Bond or angles listed as string
                list_terms = line[2][2:-1]
                # Bond List
                if tmp[0] == &#34;R&#34;:
                    x = list_terms.split(&#34;,&#34;)
                    # Subtraction due to python array indexing at 0
                    x = [(int(i) - 1) for i in x]
                    bond_list.append(x)
                    # Angle List
                if tmp[0] == &#34;A&#34;:
                    x = list_terms.split(&#34;,&#34;)
                    # Subtraction due to python array indexing at 0
                    x = [(int(i) - 1) for i in x]
                    angle_list.append(x)
                tline = fid.readline()
            # Leave loop
            tline = -1
    np.savetxt(self.bond_list_file, bond_list, fmt=&#34;%s&#34;)
    np.savetxt(self.angle_list_file, angle_list, fmt=&#34;%s&#34;)</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeGuest.get_charges"><code class="name flex">
<span>def <span class="ident">get_charges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the atomic charges in a text file obtained from
the Gaussian log file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_charges(self):
    &#34;&#34;&#34;
    Saves the atomic charges in a text file obtained from
    the Gaussian log file.
    &#34;&#34;&#34;
    log_file = self.guest_pdb[:-4] + &#34;.log&#34;
    with open(log_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Fitting point charges to electrostatic potential&#34; in lines[i]:
            to_begin = int(i)
        if &#34; Sum of ESP charges =&#34; in lines[i]:
            to_end = int(i)
    charges = lines[to_begin + 4 : to_end]
    charge_list = []
    for i in range(len(charges)):
        charge_list.append(charges[i].strip().split())
    charge_list_value = []
    atom_list = []
    for i in range(len(charge_list)):
        charge_list_value.append(charge_list[i][2])
        atom_list.append(charge_list[i][1])
    data_tuples = list(zip(atom_list, charge_list_value))
    df_charge = pd.DataFrame(data_tuples, columns=[&#34;Atom&#34;, &#34;Charge&#34;])
    df_charge.to_csv(
        self.charge_parameter_file, index=False, header=False, sep=&#34; &#34;
    )</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeGuest.get_hessian"><code class="name flex">
<span>def <span class="ident">get_hessian</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Extracts hessian matrix from the unprocessed hessian matrix
and saves into a new file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hessian(self):
    &#34;&#34;&#34;
    Extracts hessian matrix from the unprocessed hessian matrix 
    and saves into a new file.
    &#34;&#34;&#34;
    unprocessed_Hessian = np.loadtxt(self.unprocessed_hessian_file)
    fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
    with open(fchk_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Current cartesian coordinates&#34; in lines[i]:
            no_coordinates = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
            no_coordinates = int(no_coordinates[0])
    N = int(no_coordinates / 3)
    length_hessian = 3 * N
    hessian = np.zeros((length_hessian, length_hessian))
    m = 0
    # Write the hessian in a 2D array format
    for i in range(0, (length_hessian)):
        for j in range(0, (i + 1)):
            hessian[i][j] = unprocessed_Hessian[m]
            hessian[j][i] = unprocessed_Hessian[m]
            m = m + 1
    hessian = (hessian * (627.509391)) / (
        0.529 ** 2
    )  # Change from Hartree/bohr to kcal/mol/ang
    np.savetxt(self.hessian_file, hessian, fmt=&#34;%s&#34;)</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeGuest.get_proper_dihedrals"><code class="name flex">
<span>def <span class="ident">get_proper_dihedrals</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves proper dihedral angles of the ligand in a text file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_proper_dihedrals(self):
    &#34;&#34;&#34;
    Saves proper dihedral angles of the ligand in a text file.
    &#34;&#34;&#34;
    ppdb = PandasPdb()
    ppdb.read_pdb(self.guest_pdb)
    no_atoms = len(ppdb.df[&#34;ATOM&#34;])
    atom_index_list = []
    for i in range(no_atoms):
        atom_index_list.append(i + 1)
    possible_dihedrals = []
    for dihed in itertools.permutations(atom_index_list, 4):
        possible_dihedrals.append(dihed)
    df_bonds = pd.read_csv(
        self.bond_parameter_file, header=None, delimiter=r&#34;\s+&#34;
    )
    df_bonds.columns = [
        &#34;bond&#34;,
        &#34;k_bond&#34;,
        &#34;bond_length&#34;,
        &#34;bond_1&#34;,
        &#34;bond_2&#34;,
    ]
    bond1 = df_bonds[&#34;bond_1&#34;].values.tolist()
    bond2 = df_bonds[&#34;bond_2&#34;].values.tolist()
    bond_list_list = []
    for i in range(len(bond1)):
        args = (bond1[i], bond2[i])
        bond_list_list.append(list(args))
    reverse_bond_list_list = []
    for bonds in bond_list_list:
        reverse_bond_list_list.append(reverse_list(bonds))
    bond_lists = bond_list_list + reverse_bond_list_list
    proper_dihed_repeated = []
    for i in range(len(possible_dihedrals)):
        dihed_frag = (
            [possible_dihedrals[i][0], possible_dihedrals[i][1]],
            [possible_dihedrals[i][1], possible_dihedrals[i][2]],
            [possible_dihedrals[i][2], possible_dihedrals[i][3]],
        )
        a = [
            dihed_frag[0] in bond_lists,
            dihed_frag[1] in bond_lists,
            dihed_frag[2] in bond_lists,
        ]
        if a == [True, True, True]:
            proper_dihed_repeated.append(possible_dihedrals[i])

    len_repeated_dihed_list = len(proper_dihed_repeated)
    proper_dihedrals = proper_dihed_repeated
    for x in proper_dihedrals:
        z = x[::-1]
        if z in proper_dihedrals:
            proper_dihedrals.remove(z)
    len_non_repeated_dihed_list = len(proper_dihedrals)
    # print(len_repeated_dihed_list == len_non_repeated_dihed_list * 2)
    np.savetxt(self.proper_dihedral_file, proper_dihedrals, fmt=&#34;%s&#34;)
    # return(proper_dihedrals)</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeGuest.get_unprocessed_hessian"><code class="name flex">
<span>def <span class="ident">get_unprocessed_hessian</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a text file of the unprocessed hessian matrix from the
formatted checkpoint file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_unprocessed_hessian(self):
    &#34;&#34;&#34;
    Saves a text file of the unprocessed hessian matrix from the 
    formatted checkpoint file.
    &#34;&#34;&#34;
    fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
    with open(fchk_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Cartesian Force Constants&#34; in lines[i]:
            no_hessian = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
            no_hessian = int(no_hessian[0])
    for i in range(len(lines)):
        if &#34;Cartesian Force Constants&#34; in lines[i]:
            to_begin = int(i)
    hessian = lines[
        to_begin + 1 : to_begin + 1 + int(math.ceil(no_hessian / 5))
    ]
    hessian_list = []
    for i in range(len(hessian)):
        hessian_list.append(hessian[i].strip().split())
    unprocessed_Hessian = [
        item for sublist in hessian_list for item in sublist
    ]
    np.savetxt(
        self.unprocessed_hessian_file, unprocessed_Hessian, fmt=&#34;%s&#34;
    )</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeGuest.get_xyz"><code class="name flex">
<span>def <span class="ident">get_xyz</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves XYZ file from the formatted checkpoint file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_xyz(self):
    &#34;&#34;&#34;
    Saves XYZ file from the formatted checkpoint file.
    &#34;&#34;&#34;
    fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
    with open(fchk_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Current cartesian coordinates&#34; in lines[i]:
            no_coordinates = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
            no_coordinates = int(no_coordinates[0])
    for i in range(len(lines)):
        if &#34;Current cartesian coordinates&#34; in lines[i]:
            to_begin = int(i)
    cartesian_coords = lines[
        to_begin + 1 : to_begin + 1 + int(math.ceil(no_coordinates / 5))
    ]
    cartesian_list = []
    for i in range(len(cartesian_coords)):
        cartesian_list.append(cartesian_coords[i].strip().split())
    coordinates_list = [
        item for sublist in cartesian_list for item in sublist
    ]
    list_coords = [float(x) * float(0.529) for x in coordinates_list]
    for i in range(len(lines)):
        if &#34;Atomic numbers&#34; in lines[i]:
            to_begin = int(i)
        if &#34;Nuclear charges&#34; in lines[i]:
            to_end = int(i)
    atomic_numbers = lines[to_begin + 1 : to_end]
    atom_numbers = []
    for i in range(len(atomic_numbers)):
        atom_numbers.append(atomic_numbers[i].strip().split())
    numbers = [item for sublist in atom_numbers for item in sublist]
    N = int(no_coordinates / 3)
    # Opens the new xyz file
    file = open(self.xyz_file, &#34;w&#34;)
    file.write(str(N) + &#34;\n \n&#34;)
    coords = np.zeros((N, 3))
    n = 0
    names = []
    # Gives name for atomic number
    for x in range(0, len(numbers)):
        names.append(element_list[int(numbers[x]) - 1][1])
    # Print coordinates to new input_coords.xyz file
    for i in range(0, N):
        for j in range(0, 3):
            coords[i][j] = list_coords[n]
            n = n + 1
        file.write(
            names[i]
            + str(round(coords[i][0], 3))
            + &#34; &#34;
            + str(round(coords[i][1], 3))
            + &#34; &#34;
            + str(round(coords[i][2], 3))
            + &#34;\n&#34;
        )
    file.close()
    np.savetxt(self.coordinate_file, coords, fmt=&#34;%s&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.ParameterizeHost"><code class="flex name class">
<span>class <span class="ident">ParameterizeHost</span></span>
<span>(</span><span>vibrational_scaling, xyz_file='host_qm_coords.xyz', coordinate_file='host_qm_coordinates.txt', unprocessed_hessian_file='host_qm_unprocessed_hessian.txt', bond_list_file='host_qm_bond_list.txt', angle_list_file='host_qm_angle_list.txt', hessian_file='host_qm_hessian.txt', atom_names_file='host_qm_atom_names.txt', bond_parameter_file='host_qm_bonds.txt', angle_parameter_file='host_qm_angles.txt', charge_parameter_file='host_qm_surround_charges.txt', host_qm_pdb='host_qm.pdb')</span>
</code></dt>
<dd>
<div class="desc"><p>A class used to obtain force field parameters for the QM region
of the receptor (bond, angle and charge parameters) from QM
calculations.</p>
<p>This class contain methods to process the output files of the
Gaussian QM output files (.chk, .fchk and .log files). Methods
in the class extract the unprocessed hessian matrix from the
Gaussian QM calculations, processes it and uses the Modified
Seminario Method to ontain the bond and angle parameters. The
class also extracts the QM charges from the log file.</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>vibrational_scaling</code></strong> :&ensp;<code>float</code></dt>
<dd>Vibrational scaling factor for the DFT deficits/anharmonicities
in the bond parameters.</dd>
<dt><strong><code>xyz_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>XYZ file for ligand coordinates obtained from its corresponding
formatted checkpoint file.</dd>
<dt><strong><code>coordinate_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the receptor coordinates (extracted
from the formatted checkpoint file).</dd>
<dt><strong><code>unprocessed_hessian_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Unprocessed hessian matrix of the receptor obtained from the
formatted checkpoint file.</dd>
<dt><strong><code>bond_list_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the bond information of the receptor
extracted from the log file.</dd>
<dt><strong><code>angle_list_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the angle information of the receptor
extracted from the log file.</dd>
<dt><strong><code>hessian_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Processed hessian matrix of the receptor.</dd>
<dt><strong><code>atom_names_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the list of atom names from the fchk file.</dd>
<dt><strong><code>bond_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the bond parameters for the receptor
obtained using the Modified Seminario method.</dd>
<dt><strong><code>angle_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the angle parameters of the receptor.</dd>
<dt><strong><code>charge_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the QM charges of the receptor.</dd>
<dt><strong><code>host_qm_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>PDB file for the receptor's QM region.</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vibrational_scaling</code></strong> :&ensp;<code>float</code></dt>
<dd>Vibrational scaling factor for the DFT deficits/anharmonicities
in the bond parameters.</dd>
<dt><strong><code>xyz_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>XYZ file for ligand coordinates obtained from its corresponding
formatted checkpoint file.</dd>
<dt><strong><code>coordinate_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the receptor coordinates (extracted
from the formatted checkpoint file).</dd>
<dt><strong><code>unprocessed_hessian_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Unprocessed hessian matrix of the receptor obtained from the
formatted checkpoint file.</dd>
<dt><strong><code>bond_list_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the bond information of the receptor
extracted from the log file.</dd>
<dt><strong><code>angle_list_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the angle information of the receptor
extracted from the log file.</dd>
<dt><strong><code>hessian_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Processed hessian matrix of the receptor.</dd>
<dt><strong><code>atom_names_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the list of atom names from the fchk file.</dd>
<dt><strong><code>bond_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the bond parameters for the receptor
obtained using the Modified Seminario method.</dd>
<dt><strong><code>angle_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the angle parameters of the receptor.</dd>
<dt><strong><code>charge_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing the QM charges of the receptor.</dd>
<dt><strong><code>host_qm_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>PDB file for the receptor's QM region.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterizeHost:
    &#34;&#34;&#34;
    A class used to obtain force field parameters for the QM region 
    of the receptor (bond, angle and charge parameters) from QM 
    calculations.

    This class contain methods to process the output files of the 
    Gaussian QM output files (.chk, .fchk and .log files). Methods 
    in the class extract the unprocessed hessian matrix from the 
    Gaussian QM calculations, processes it and uses the Modified 
    Seminario Method to ontain the bond and angle parameters. The 
    class also extracts the QM charges from the log file.

    ...

    Attributes
    ----------
    vibrational_scaling: float
        Vibrational scaling factor for the DFT deficits/anharmonicities
        in the bond parameters.

    xyz_file: str, optional
        XYZ file for ligand coordinates obtained from its corresponding 
        formatted checkpoint file.

    coordinate_file: str, optional
        Text file containing the receptor coordinates (extracted
        from the formatted checkpoint file).

    unprocessed_hessian_file: str, optional
        Unprocessed hessian matrix of the receptor obtained from the 
        formatted checkpoint file.

    bond_list_file: str, optional
        Text file containing the bond information of the receptor 
        extracted from the log file.

    angle_list_file: str, optional
        Text file containing the angle information of the receptor 
        extracted from the log file.

    hessian_file: str, optional
        Processed hessian matrix of the receptor.

    atom_names_file: str, optional
        Text file containing the list of atom names from the fchk file.

    bond_parameter_file: str, optional
        Text file containing the bond parameters for the receptor 
        obtained using the Modified Seminario method.

    angle_parameter_file: str, optional
        Text file containing the angle parameters of the receptor.

    charge_parameter_file: str, optional
        Text file containing the QM charges of the receptor.

    host_qm_pdb: str, optional
        PDB file for the receptor&#39;s QM region.

    &#34;&#34;&#34;

    def __init__(
        self,
        vibrational_scaling,
        xyz_file=&#34;host_qm_coords.xyz&#34;,
        coordinate_file=&#34;host_qm_coordinates.txt&#34;,
        unprocessed_hessian_file=&#34;host_qm_unprocessed_hessian.txt&#34;,
        bond_list_file=&#34;host_qm_bond_list.txt&#34;,
        angle_list_file=&#34;host_qm_angle_list.txt&#34;,
        hessian_file=&#34;host_qm_hessian.txt&#34;,
        atom_names_file=&#34;host_qm_atom_names.txt&#34;,
        bond_parameter_file=&#34;host_qm_bonds.txt&#34;,
        angle_parameter_file=&#34;host_qm_angles.txt&#34;,
        charge_parameter_file=&#34;host_qm_surround_charges.txt&#34;,
        host_qm_pdb=&#34;host_qm.pdb&#34;,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        vibrational_scaling: float
            Vibrational scaling factor for the DFT deficits/anharmonicities
            in the bond parameters.

        xyz_file: str, optional
            XYZ file for ligand coordinates obtained from its corresponding 
            formatted checkpoint file.

        coordinate_file: str, optional
            Text file containing the receptor coordinates (extracted
            from the formatted checkpoint file).

        unprocessed_hessian_file: str, optional
            Unprocessed hessian matrix of the receptor obtained from the 
            formatted checkpoint file.

        bond_list_file: str, optional
            Text file containing the bond information of the receptor 
            extracted from the log file.

        angle_list_file: str, optional
            Text file containing the angle information of the receptor 
            extracted from the log file.

        hessian_file: str, optional
            Processed hessian matrix of the receptor.

        atom_names_file: str, optional
            Text file containing the list of atom names from the fchk file.

        bond_parameter_file: str, optional
            Text file containing the bond parameters for the receptor 
            obtained using the Modified Seminario method.

        angle_parameter_file: str, optional
            Text file containing the angle parameters of the receptor.

        charge_parameter_file: str, optional
            Text file containing the QM charges of the receptor.

        host_qm_pdb: str, optional
            PDB file for the receptor&#39;s QM region.

        &#34;&#34;&#34;
        self.vibrational_scaling = vibrational_scaling
        self.xyz_file = xyz_file
        self.coordinate_file = coordinate_file
        self.unprocessed_hessian_file = unprocessed_hessian_file
        self.bond_list_file = bond_list_file
        self.angle_list_file = angle_list_file
        self.hessian_file = hessian_file
        self.atom_names_file = atom_names_file
        self.bond_parameter_file = bond_parameter_file
        self.angle_parameter_file = angle_parameter_file
        self.charge_parameter_file = charge_parameter_file
        self.host_qm_pdb = host_qm_pdb

    def get_xyz(self):
        &#34;&#34;&#34;
        Saves XYZ file from the formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
        with open(fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
                no_coordinates = int(no_coordinates[0])
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                to_begin = int(i)
        cartesian_coords = lines[
            to_begin + 1 : to_begin + 1 + int(math.ceil(no_coordinates / 5))
        ]
        cartesian_list = []
        for i in range(len(cartesian_coords)):
            cartesian_list.append(cartesian_coords[i].strip().split())
        coordinates_list = [
            item for sublist in cartesian_list for item in sublist
        ]
        list_coords = [float(x) * float(0.529) for x in coordinates_list]
        for i in range(len(lines)):
            if &#34;Atomic numbers&#34; in lines[i]:
                to_begin = int(i)
            if &#34;Nuclear charges&#34; in lines[i]:
                to_end = int(i)
        atomic_numbers = lines[to_begin + 1 : to_end]
        atom_numbers = []
        for i in range(len(atomic_numbers)):
            atom_numbers.append(atomic_numbers[i].strip().split())
        numbers = [item for sublist in atom_numbers for item in sublist]
        N = int(no_coordinates / 3)
        # Opens the new xyz file
        file = open(self.xyz_file, &#34;w&#34;)
        file.write(str(N) + &#34;\n \n&#34;)
        coords = np.zeros((N, 3))
        n = 0
        names = []
        # Gives name for atomic number
        for x in range(0, len(numbers)):
            names.append(element_list[int(numbers[x]) - 1][1])
        # Print coordinates to new input_coords.xyz file
        for i in range(0, N):
            for j in range(0, 3):
                coords[i][j] = list_coords[n]
                n = n + 1
            file.write(
                names[i]
                + str(round(coords[i][0], 3))
                + &#34; &#34;
                + str(round(coords[i][1], 3))
                + &#34; &#34;
                + str(round(coords[i][2], 3))
                + &#34;\n&#34;
            )
        file.close()
        np.savetxt(self.coordinate_file, coords, fmt=&#34;%s&#34;)

    def get_unprocessed_hessian(self):
        &#34;&#34;&#34;
        Saves a text file of the unprocessed hessian matrix from the 
        formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
        with open(fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Cartesian Force Constants&#34; in lines[i]:
                no_hessian = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
                no_hessian = int(no_hessian[0])
        for i in range(len(lines)):
            if &#34;Cartesian Force Constants&#34; in lines[i]:
                to_begin = int(i)
        hessian = lines[
            to_begin + 1 : to_begin + 1 + int(math.ceil(no_hessian / 5))
        ]
        hessian_list = []
        for i in range(len(hessian)):
            hessian_list.append(hessian[i].strip().split())
        unprocessed_Hessian = [
            item for sublist in hessian_list for item in sublist
        ]
        np.savetxt(
            self.unprocessed_hessian_file, unprocessed_Hessian, fmt=&#34;%s&#34;
        )

    def get_bond_angles(self):
        &#34;&#34;&#34;
        Saves a text file containing bonds and angles from the gaussian 
        log file.
        &#34;&#34;&#34;
        log_file = self.host_qm_pdb[:-4] + &#34;.log&#34;
        fid = open(log_file, &#34;r&#34;)
        tline = fid.readline()
        bond_list = []
        angle_list = []
        n = 1
        n_bond = 1
        n_angle = 1
        tmp = &#34;R&#34;  # States if bond or angle
        B = []
        # Finds the bond and angles from the .log file
        while tline:
            tline = fid.readline()
            # Line starts at point when bond and angle list occurs
            if (
                len(tline) &gt; 80
                and tline[0:81].strip()
                == &#34;! Name  Definition              Value          Derivative Info.                !&#34;
            ):
                tline = fid.readline()
                tline = fid.readline()
                # Stops when all bond and angles recorded
                while (tmp[0] == &#34;R&#34;) or (tmp[0] == &#34;A&#34;):
                    line = tline.split()
                    tmp = line[1]
                    # Bond or angles listed as string
                    list_terms = line[2][2:-1]
                    # Bond List
                    if tmp[0] == &#34;R&#34;:
                        x = list_terms.split(&#34;,&#34;)
                        # Subtraction due to python array indexing at 0
                        x = [(int(i) - 1) for i in x]
                        bond_list.append(x)
                        # Angle List
                    if tmp[0] == &#34;A&#34;:
                        x = list_terms.split(&#34;,&#34;)
                        # Subtraction due to python array indexing at 0
                        x = [(int(i) - 1) for i in x]
                        angle_list.append(x)
                    tline = fid.readline()
                # Leave loop
                tline = -1
        np.savetxt(self.bond_list_file, bond_list, fmt=&#34;%s&#34;)
        np.savetxt(self.angle_list_file, angle_list, fmt=&#34;%s&#34;)

    def get_hessian(self):
        &#34;&#34;&#34;
        Extracts hessian matrix from the unprocessed hessian matrix 
        and saves into a new file.
        &#34;&#34;&#34;
        unprocessed_Hessian = np.loadtxt(self.unprocessed_hessian_file)
        fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
        with open(fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
                no_coordinates = int(no_coordinates[0])
        N = int(no_coordinates / 3)
        length_hessian = 3 * N
        hessian = np.zeros((length_hessian, length_hessian))
        m = 0
        # Write the hessian in a 2D array format
        for i in range(0, (length_hessian)):
            for j in range(0, (i + 1)):
                hessian[i][j] = unprocessed_Hessian[m]
                hessian[j][i] = unprocessed_Hessian[m]
                m = m + 1
        hessian = (hessian * (627.509391)) / (
            0.529 ** 2
        )  # Change from Hartree/bohr to kcal/mol/ang
        np.savetxt(self.hessian_file, hessian, fmt=&#34;%s&#34;)

    def get_atom_names(self):
        &#34;&#34;&#34;
        Saves a list of atom names from the formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
        with open(fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Atomic numbers&#34; in lines[i]:
                to_begin = int(i)
            if &#34;Nuclear charges&#34; in lines[i]:
                to_end = int(i)
        atomic_numbers = lines[to_begin + 1 : to_end]
        atom_numbers = []
        for i in range(len(atomic_numbers)):
            atom_numbers.append(atomic_numbers[i].strip().split())
        numbers = [item for sublist in atom_numbers for item in sublist]
        names = []
        # Gives name for atomic number
        for x in range(0, len(numbers)):
            names.append(element_list[int(numbers[x]) - 1][1])
        atom_names = []
        for i in range(0, len(names)):
            atom_names.append(names[i].strip() + str(i + 1))
        np.savetxt(self.atom_names_file, atom_names, fmt=&#34;%s&#34;)

    def get_bond_angle_params(self):
        &#34;&#34;&#34;
        Saves the bond and angle parameter files obtained from 
        the formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
        with open(fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
                no_coordinates = int(no_coordinates[0])
        N = int(no_coordinates / 3)
        coords = np.loadtxt(self.coordinate_file)
        hessian = np.loadtxt(self.hessian_file)
        bond_list = np.loadtxt(self.bond_list_file, dtype=int)
        atom_names = np.loadtxt(self.atom_names_file, dtype=str)
        # Find bond lengths
        bond_lengths = np.zeros((N, N))
        for i in range(0, N):
            for j in range(0, N):
                diff_i_j = np.array(coords[i, :]) - np.array(coords[j, :])
                bond_lengths[i][j] = np.linalg.norm(diff_i_j)
        eigenvectors = np.empty((3, 3, N, N), dtype=complex)
        eigenvalues = np.empty((N, N, 3), dtype=complex)
        partial_hessian = np.zeros((3, 3))
        for i in range(0, N):
            for j in range(0, N):
                partial_hessian = hessian[
                    (i * 3) : ((i + 1) * 3), (j * 3) : ((j + 1) * 3)
                ]
                [a, b] = np.linalg.eig(partial_hessian)
                eigenvalues[i, j, :] = a
                eigenvectors[:, :, i, j] = b
        # Modified Seminario method to find the bond parameters and print them to file
        file_bond = open(self.bond_parameter_file, &#34;w&#34;)
        k_b = np.zeros(len(bond_list))
        bond_length_list = np.zeros(len(bond_list))
        unique_values_bonds = []  # Used to find average values
        for i in range(0, len(bond_list)):
            AB = force_constant_bond(
                bond_list[i][0],
                bond_list[i][1],
                eigenvalues,
                eigenvectors,
                coords,
            )
            BA = force_constant_bond(
                bond_list[i][1],
                bond_list[i][0],
                eigenvalues,
                eigenvectors,
                coords,
            )
            # Order of bonds sometimes causes slight differences, find the mean
            k_b[i] = np.real((AB + BA) / 2)
            # Vibrational_scaling takes into account DFT deficities/ anharmocity
            vibrational_scaling_squared = self.vibrational_scaling ** 2
            k_b[i] = k_b[i] * vibrational_scaling_squared
            bond_length_list[i] = bond_lengths[bond_list[i][0]][
                bond_list[i][1]
            ]
            file_bond.write(
                atom_names[bond_list[i][0]]
                + &#34;-&#34;
                + atom_names[bond_list[i][1]]
                + &#34;  &#34;
            )
            file_bond.write(
                str(&#34;%#.5g&#34; % k_b[i])
                + &#34;   &#34;
                + str(&#34;%#.4g&#34; % bond_length_list[i])
                + &#34;   &#34;
                + str(bond_list[i][0] + 1)
                + &#34;   &#34;
                + str(bond_list[i][1] + 1)
            )
            file_bond.write(&#34;\n&#34;)
            unique_values_bonds.append(
                [
                    atom_names[bond_list[i][0]],
                    atom_names[bond_list[i][1]],
                    k_b[i],
                    bond_length_list[i],
                    1,
                ]
            )
        file_bond.close()
        angle_list = np.loadtxt(self.angle_list_file, dtype=int)
        # Modified Seminario method to find the angle parameters and print them to file
        file_angle = open(self.angle_parameter_file, &#34;w&#34;)
        k_theta = np.zeros(len(angle_list))
        theta_0 = np.zeros(len(angle_list))
        unique_values_angles = []  # Used to find average values
        # Modified Seminario part goes here ...
        # Connectivity information for Modified Seminario Method
        central_atoms_angles = []
        # A structure is created with the index giving the central atom of the angle, an array then lists the angles with that central atom.
        # i.e. central_atoms_angles{3} contains an array of angles with central atom 3
        for i in range(0, len(coords)):
            central_atoms_angles.append([])
            for j in range(0, len(angle_list)):
                if i == angle_list[j][1]:
                    # For angle ABC, atoms A C are written to array
                    AC_array = [angle_list[j][0], angle_list[j][2], j]
                    central_atoms_angles[i].append(AC_array)
                    # For angle ABC, atoms C A are written to array
                    CA_array = [angle_list[j][2], angle_list[j][0], j]
                    central_atoms_angles[i].append(CA_array)
        # Sort rows by atom number
        for i in range(0, len(coords)):
            central_atoms_angles[i] = sorted(
                central_atoms_angles[i], key=itemgetter(0)
            )
        # Find normals u_PA for each angle
        unit_PA_all_angles = []
        for i in range(0, len(central_atoms_angles)):
            unit_PA_all_angles.append([])
            for j in range(0, len(central_atoms_angles[i])):
                # For the angle at central_atoms_angles[i][j,:] the corresponding u_PA value is found for the plane ABC and bond AB, where ABC corresponds to the order of the arguements. This is why the reverse order was also added
                unit_PA_all_angles[i].append(
                    u_PA_from_angles(
                        central_atoms_angles[i][j][0],
                        i,
                        central_atoms_angles[i][j][1],
                        coords,
                    )
                )
        # Finds the contributing factors from the other angle terms scaling_factor_all_angles = cell(max(max(angle_list))); %This array will contain scaling factor and angle list position
        scaling_factor_all_angles = []
        for i in range(0, len(central_atoms_angles)):
            scaling_factor_all_angles.append([])
            for j in range(0, len(central_atoms_angles[i])):
                n = 1
                m = 1
                angles_around = 0
                additional_contributions = 0
                scaling_factor_all_angles[i].append([0, 0])
                # Position in angle list
                scaling_factor_all_angles[i][j][1] = central_atoms_angles[i][
                    j
                ][2]
                # Goes through the list of angles with the same central atom and computes the term need for the modified Seminario method
                # Forwards directions, finds the same bonds with the central atom i
                while (
                    (j + n) &lt; len(central_atoms_angles[i])
                ) and central_atoms_angles[i][j][0] == central_atoms_angles[i][
                    j + n
                ][
                    0
                ]:
                    additional_contributions = (
                        additional_contributions
                        + (
                            abs(
                                np.dot(
                                    unit_PA_all_angles[i][j][:],
                                    unit_PA_all_angles[i][j + n][:],
                                )
                            )
                        )
                        ** 2
                    )
                    n = n + 1
                    angles_around = angles_around + 1
                # Backwards direction, finds the same bonds with the central atom i
                while ((j - m) &gt;= 0) and central_atoms_angles[i][j][
                    0
                ] == central_atoms_angles[i][j - m][0]:
                    additional_contributions = (
                        additional_contributions
                        + (
                            abs(
                                np.dot(
                                    unit_PA_all_angles[i][j][:],
                                    unit_PA_all_angles[i][j - m][:],
                                )
                            )
                        )
                        ** 2
                    )
                    m = m + 1
                    angles_around = angles_around + 1
                if n != 1 or m != 1:
                    # Finds the mean value of the additional contribution to change to normal Seminario method comment out + part
                    scaling_factor_all_angles[i][j][0] = 1 + (
                        additional_contributions / (m + n - 2)
                    )
                else:
                    scaling_factor_all_angles[i][j][0] = 1
        scaling_factors_angles_list = []
        for i in range(0, len(angle_list)):
            scaling_factors_angles_list.append([])
        # Orders the scaling factors according to the angle list
        for i in range(0, len(central_atoms_angles)):
            for j in range(0, len(central_atoms_angles[i])):
                scaling_factors_angles_list[
                    scaling_factor_all_angles[i][j][1]
                ].append(scaling_factor_all_angles[i][j][0])
        # Finds the angle force constants with the scaling factors included for each angle
        for i in range(0, len(angle_list)):
            # Ensures that there is no difference when the ordering is changed
            [AB_k_theta, AB_theta_0] = force_angle_constant(
                angle_list[i][0],
                angle_list[i][1],
                angle_list[i][2],
                bond_lengths,
                eigenvalues,
                eigenvectors,
                coords,
                scaling_factors_angles_list[i][0],
                scaling_factors_angles_list[i][1],
            )
            [BA_k_theta, BA_theta_0] = force_angle_constant(
                angle_list[i][2],
                angle_list[i][1],
                angle_list[i][0],
                bond_lengths,
                eigenvalues,
                eigenvectors,
                coords,
                scaling_factors_angles_list[i][1],
                scaling_factors_angles_list[i][0],
            )
            k_theta[i] = (AB_k_theta + BA_k_theta) / 2
            theta_0[i] = (AB_theta_0 + BA_theta_0) / 2
            # Vibrational_scaling takes into account DFT deficities/ anharmonicity
            k_theta[i] = k_theta[i] * vibrational_scaling_squared
            file_angle.write(
                atom_names[angle_list[i][0]]
                + &#34;-&#34;
                + atom_names[angle_list[i][1]]
                + &#34;-&#34;
                + atom_names[angle_list[i][2]]
                + &#34;  &#34;
            )
            file_angle.write(
                str(&#34;%#.4g&#34; % k_theta[i])
                + &#34;   &#34;
                + str(&#34;%#.4g&#34; % theta_0[i])
                + &#34;   &#34;
                + str(angle_list[i][0] + 1)
                + &#34;   &#34;
                + str(angle_list[i][1] + 1)
                + &#34;   &#34;
                + str(angle_list[i][2] + 1)
            )
            file_angle.write(&#34;\n&#34;)
            unique_values_angles.append(
                [
                    atom_names[angle_list[i][0]],
                    atom_names[angle_list[i][1]],
                    atom_names[angle_list[i][2]],
                    k_theta[i],
                    theta_0[i],
                    1,
                ]
            )
        file_angle.close()

    def get_charges(self):
        &#34;&#34;&#34;
        Saves the atomic charges in a text file obtained from
        the Gaussian log file.
        &#34;&#34;&#34;
        log_file = self.host_qm_pdb[:-4] + &#34;.log&#34;
        with open(log_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Fitting point charges to electrostatic potential&#34; in lines[i]:
                to_begin = int(i)
            if &#34; Sum of ESP charges =&#34; in lines[i]:
                to_end = int(i)
        charges = lines[to_begin + 4 : to_end]
        charge_list = []
        for i in range(len(charges)):
            charge_list.append(charges[i].strip().split())
        charge_list_value = []
        atom_list = []
        for i in range(len(charge_list)):
            charge_list_value.append(charge_list[i][2])
            atom_list.append(charge_list[i][1])
        data_tuples = list(zip(atom_list, charge_list_value))
        df_charge = pd.DataFrame(data_tuples, columns=[&#34;Atom&#34;, &#34;Charge&#34;])
        df_charge.to_csv(
            self.charge_parameter_file, index=False, header=False, sep=&#34; &#34;
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.ParameterizeHost.get_atom_names"><code class="name flex">
<span>def <span class="ident">get_atom_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a list of atom names from the formatted checkpoint file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_atom_names(self):
    &#34;&#34;&#34;
    Saves a list of atom names from the formatted checkpoint file.
    &#34;&#34;&#34;
    fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
    with open(fchk_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Atomic numbers&#34; in lines[i]:
            to_begin = int(i)
        if &#34;Nuclear charges&#34; in lines[i]:
            to_end = int(i)
    atomic_numbers = lines[to_begin + 1 : to_end]
    atom_numbers = []
    for i in range(len(atomic_numbers)):
        atom_numbers.append(atomic_numbers[i].strip().split())
    numbers = [item for sublist in atom_numbers for item in sublist]
    names = []
    # Gives name for atomic number
    for x in range(0, len(numbers)):
        names.append(element_list[int(numbers[x]) - 1][1])
    atom_names = []
    for i in range(0, len(names)):
        atom_names.append(names[i].strip() + str(i + 1))
    np.savetxt(self.atom_names_file, atom_names, fmt=&#34;%s&#34;)</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeHost.get_bond_angle_params"><code class="name flex">
<span>def <span class="ident">get_bond_angle_params</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the bond and angle parameter files obtained from
the formatted checkpoint file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bond_angle_params(self):
    &#34;&#34;&#34;
    Saves the bond and angle parameter files obtained from 
    the formatted checkpoint file.
    &#34;&#34;&#34;
    fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
    with open(fchk_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Current cartesian coordinates&#34; in lines[i]:
            no_coordinates = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
            no_coordinates = int(no_coordinates[0])
    N = int(no_coordinates / 3)
    coords = np.loadtxt(self.coordinate_file)
    hessian = np.loadtxt(self.hessian_file)
    bond_list = np.loadtxt(self.bond_list_file, dtype=int)
    atom_names = np.loadtxt(self.atom_names_file, dtype=str)
    # Find bond lengths
    bond_lengths = np.zeros((N, N))
    for i in range(0, N):
        for j in range(0, N):
            diff_i_j = np.array(coords[i, :]) - np.array(coords[j, :])
            bond_lengths[i][j] = np.linalg.norm(diff_i_j)
    eigenvectors = np.empty((3, 3, N, N), dtype=complex)
    eigenvalues = np.empty((N, N, 3), dtype=complex)
    partial_hessian = np.zeros((3, 3))
    for i in range(0, N):
        for j in range(0, N):
            partial_hessian = hessian[
                (i * 3) : ((i + 1) * 3), (j * 3) : ((j + 1) * 3)
            ]
            [a, b] = np.linalg.eig(partial_hessian)
            eigenvalues[i, j, :] = a
            eigenvectors[:, :, i, j] = b
    # Modified Seminario method to find the bond parameters and print them to file
    file_bond = open(self.bond_parameter_file, &#34;w&#34;)
    k_b = np.zeros(len(bond_list))
    bond_length_list = np.zeros(len(bond_list))
    unique_values_bonds = []  # Used to find average values
    for i in range(0, len(bond_list)):
        AB = force_constant_bond(
            bond_list[i][0],
            bond_list[i][1],
            eigenvalues,
            eigenvectors,
            coords,
        )
        BA = force_constant_bond(
            bond_list[i][1],
            bond_list[i][0],
            eigenvalues,
            eigenvectors,
            coords,
        )
        # Order of bonds sometimes causes slight differences, find the mean
        k_b[i] = np.real((AB + BA) / 2)
        # Vibrational_scaling takes into account DFT deficities/ anharmocity
        vibrational_scaling_squared = self.vibrational_scaling ** 2
        k_b[i] = k_b[i] * vibrational_scaling_squared
        bond_length_list[i] = bond_lengths[bond_list[i][0]][
            bond_list[i][1]
        ]
        file_bond.write(
            atom_names[bond_list[i][0]]
            + &#34;-&#34;
            + atom_names[bond_list[i][1]]
            + &#34;  &#34;
        )
        file_bond.write(
            str(&#34;%#.5g&#34; % k_b[i])
            + &#34;   &#34;
            + str(&#34;%#.4g&#34; % bond_length_list[i])
            + &#34;   &#34;
            + str(bond_list[i][0] + 1)
            + &#34;   &#34;
            + str(bond_list[i][1] + 1)
        )
        file_bond.write(&#34;\n&#34;)
        unique_values_bonds.append(
            [
                atom_names[bond_list[i][0]],
                atom_names[bond_list[i][1]],
                k_b[i],
                bond_length_list[i],
                1,
            ]
        )
    file_bond.close()
    angle_list = np.loadtxt(self.angle_list_file, dtype=int)
    # Modified Seminario method to find the angle parameters and print them to file
    file_angle = open(self.angle_parameter_file, &#34;w&#34;)
    k_theta = np.zeros(len(angle_list))
    theta_0 = np.zeros(len(angle_list))
    unique_values_angles = []  # Used to find average values
    # Modified Seminario part goes here ...
    # Connectivity information for Modified Seminario Method
    central_atoms_angles = []
    # A structure is created with the index giving the central atom of the angle, an array then lists the angles with that central atom.
    # i.e. central_atoms_angles{3} contains an array of angles with central atom 3
    for i in range(0, len(coords)):
        central_atoms_angles.append([])
        for j in range(0, len(angle_list)):
            if i == angle_list[j][1]:
                # For angle ABC, atoms A C are written to array
                AC_array = [angle_list[j][0], angle_list[j][2], j]
                central_atoms_angles[i].append(AC_array)
                # For angle ABC, atoms C A are written to array
                CA_array = [angle_list[j][2], angle_list[j][0], j]
                central_atoms_angles[i].append(CA_array)
    # Sort rows by atom number
    for i in range(0, len(coords)):
        central_atoms_angles[i] = sorted(
            central_atoms_angles[i], key=itemgetter(0)
        )
    # Find normals u_PA for each angle
    unit_PA_all_angles = []
    for i in range(0, len(central_atoms_angles)):
        unit_PA_all_angles.append([])
        for j in range(0, len(central_atoms_angles[i])):
            # For the angle at central_atoms_angles[i][j,:] the corresponding u_PA value is found for the plane ABC and bond AB, where ABC corresponds to the order of the arguements. This is why the reverse order was also added
            unit_PA_all_angles[i].append(
                u_PA_from_angles(
                    central_atoms_angles[i][j][0],
                    i,
                    central_atoms_angles[i][j][1],
                    coords,
                )
            )
    # Finds the contributing factors from the other angle terms scaling_factor_all_angles = cell(max(max(angle_list))); %This array will contain scaling factor and angle list position
    scaling_factor_all_angles = []
    for i in range(0, len(central_atoms_angles)):
        scaling_factor_all_angles.append([])
        for j in range(0, len(central_atoms_angles[i])):
            n = 1
            m = 1
            angles_around = 0
            additional_contributions = 0
            scaling_factor_all_angles[i].append([0, 0])
            # Position in angle list
            scaling_factor_all_angles[i][j][1] = central_atoms_angles[i][
                j
            ][2]
            # Goes through the list of angles with the same central atom and computes the term need for the modified Seminario method
            # Forwards directions, finds the same bonds with the central atom i
            while (
                (j + n) &lt; len(central_atoms_angles[i])
            ) and central_atoms_angles[i][j][0] == central_atoms_angles[i][
                j + n
            ][
                0
            ]:
                additional_contributions = (
                    additional_contributions
                    + (
                        abs(
                            np.dot(
                                unit_PA_all_angles[i][j][:],
                                unit_PA_all_angles[i][j + n][:],
                            )
                        )
                    )
                    ** 2
                )
                n = n + 1
                angles_around = angles_around + 1
            # Backwards direction, finds the same bonds with the central atom i
            while ((j - m) &gt;= 0) and central_atoms_angles[i][j][
                0
            ] == central_atoms_angles[i][j - m][0]:
                additional_contributions = (
                    additional_contributions
                    + (
                        abs(
                            np.dot(
                                unit_PA_all_angles[i][j][:],
                                unit_PA_all_angles[i][j - m][:],
                            )
                        )
                    )
                    ** 2
                )
                m = m + 1
                angles_around = angles_around + 1
            if n != 1 or m != 1:
                # Finds the mean value of the additional contribution to change to normal Seminario method comment out + part
                scaling_factor_all_angles[i][j][0] = 1 + (
                    additional_contributions / (m + n - 2)
                )
            else:
                scaling_factor_all_angles[i][j][0] = 1
    scaling_factors_angles_list = []
    for i in range(0, len(angle_list)):
        scaling_factors_angles_list.append([])
    # Orders the scaling factors according to the angle list
    for i in range(0, len(central_atoms_angles)):
        for j in range(0, len(central_atoms_angles[i])):
            scaling_factors_angles_list[
                scaling_factor_all_angles[i][j][1]
            ].append(scaling_factor_all_angles[i][j][0])
    # Finds the angle force constants with the scaling factors included for each angle
    for i in range(0, len(angle_list)):
        # Ensures that there is no difference when the ordering is changed
        [AB_k_theta, AB_theta_0] = force_angle_constant(
            angle_list[i][0],
            angle_list[i][1],
            angle_list[i][2],
            bond_lengths,
            eigenvalues,
            eigenvectors,
            coords,
            scaling_factors_angles_list[i][0],
            scaling_factors_angles_list[i][1],
        )
        [BA_k_theta, BA_theta_0] = force_angle_constant(
            angle_list[i][2],
            angle_list[i][1],
            angle_list[i][0],
            bond_lengths,
            eigenvalues,
            eigenvectors,
            coords,
            scaling_factors_angles_list[i][1],
            scaling_factors_angles_list[i][0],
        )
        k_theta[i] = (AB_k_theta + BA_k_theta) / 2
        theta_0[i] = (AB_theta_0 + BA_theta_0) / 2
        # Vibrational_scaling takes into account DFT deficities/ anharmonicity
        k_theta[i] = k_theta[i] * vibrational_scaling_squared
        file_angle.write(
            atom_names[angle_list[i][0]]
            + &#34;-&#34;
            + atom_names[angle_list[i][1]]
            + &#34;-&#34;
            + atom_names[angle_list[i][2]]
            + &#34;  &#34;
        )
        file_angle.write(
            str(&#34;%#.4g&#34; % k_theta[i])
            + &#34;   &#34;
            + str(&#34;%#.4g&#34; % theta_0[i])
            + &#34;   &#34;
            + str(angle_list[i][0] + 1)
            + &#34;   &#34;
            + str(angle_list[i][1] + 1)
            + &#34;   &#34;
            + str(angle_list[i][2] + 1)
        )
        file_angle.write(&#34;\n&#34;)
        unique_values_angles.append(
            [
                atom_names[angle_list[i][0]],
                atom_names[angle_list[i][1]],
                atom_names[angle_list[i][2]],
                k_theta[i],
                theta_0[i],
                1,
            ]
        )
    file_angle.close()</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeHost.get_bond_angles"><code class="name flex">
<span>def <span class="ident">get_bond_angles</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a text file containing bonds and angles from the gaussian
log file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bond_angles(self):
    &#34;&#34;&#34;
    Saves a text file containing bonds and angles from the gaussian 
    log file.
    &#34;&#34;&#34;
    log_file = self.host_qm_pdb[:-4] + &#34;.log&#34;
    fid = open(log_file, &#34;r&#34;)
    tline = fid.readline()
    bond_list = []
    angle_list = []
    n = 1
    n_bond = 1
    n_angle = 1
    tmp = &#34;R&#34;  # States if bond or angle
    B = []
    # Finds the bond and angles from the .log file
    while tline:
        tline = fid.readline()
        # Line starts at point when bond and angle list occurs
        if (
            len(tline) &gt; 80
            and tline[0:81].strip()
            == &#34;! Name  Definition              Value          Derivative Info.                !&#34;
        ):
            tline = fid.readline()
            tline = fid.readline()
            # Stops when all bond and angles recorded
            while (tmp[0] == &#34;R&#34;) or (tmp[0] == &#34;A&#34;):
                line = tline.split()
                tmp = line[1]
                # Bond or angles listed as string
                list_terms = line[2][2:-1]
                # Bond List
                if tmp[0] == &#34;R&#34;:
                    x = list_terms.split(&#34;,&#34;)
                    # Subtraction due to python array indexing at 0
                    x = [(int(i) - 1) for i in x]
                    bond_list.append(x)
                    # Angle List
                if tmp[0] == &#34;A&#34;:
                    x = list_terms.split(&#34;,&#34;)
                    # Subtraction due to python array indexing at 0
                    x = [(int(i) - 1) for i in x]
                    angle_list.append(x)
                tline = fid.readline()
            # Leave loop
            tline = -1
    np.savetxt(self.bond_list_file, bond_list, fmt=&#34;%s&#34;)
    np.savetxt(self.angle_list_file, angle_list, fmt=&#34;%s&#34;)</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeHost.get_charges"><code class="name flex">
<span>def <span class="ident">get_charges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the atomic charges in a text file obtained from
the Gaussian log file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_charges(self):
    &#34;&#34;&#34;
    Saves the atomic charges in a text file obtained from
    the Gaussian log file.
    &#34;&#34;&#34;
    log_file = self.host_qm_pdb[:-4] + &#34;.log&#34;
    with open(log_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Fitting point charges to electrostatic potential&#34; in lines[i]:
            to_begin = int(i)
        if &#34; Sum of ESP charges =&#34; in lines[i]:
            to_end = int(i)
    charges = lines[to_begin + 4 : to_end]
    charge_list = []
    for i in range(len(charges)):
        charge_list.append(charges[i].strip().split())
    charge_list_value = []
    atom_list = []
    for i in range(len(charge_list)):
        charge_list_value.append(charge_list[i][2])
        atom_list.append(charge_list[i][1])
    data_tuples = list(zip(atom_list, charge_list_value))
    df_charge = pd.DataFrame(data_tuples, columns=[&#34;Atom&#34;, &#34;Charge&#34;])
    df_charge.to_csv(
        self.charge_parameter_file, index=False, header=False, sep=&#34; &#34;
    )</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeHost.get_hessian"><code class="name flex">
<span>def <span class="ident">get_hessian</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Extracts hessian matrix from the unprocessed hessian matrix
and saves into a new file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hessian(self):
    &#34;&#34;&#34;
    Extracts hessian matrix from the unprocessed hessian matrix 
    and saves into a new file.
    &#34;&#34;&#34;
    unprocessed_Hessian = np.loadtxt(self.unprocessed_hessian_file)
    fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
    with open(fchk_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Current cartesian coordinates&#34; in lines[i]:
            no_coordinates = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
            no_coordinates = int(no_coordinates[0])
    N = int(no_coordinates / 3)
    length_hessian = 3 * N
    hessian = np.zeros((length_hessian, length_hessian))
    m = 0
    # Write the hessian in a 2D array format
    for i in range(0, (length_hessian)):
        for j in range(0, (i + 1)):
            hessian[i][j] = unprocessed_Hessian[m]
            hessian[j][i] = unprocessed_Hessian[m]
            m = m + 1
    hessian = (hessian * (627.509391)) / (
        0.529 ** 2
    )  # Change from Hartree/bohr to kcal/mol/ang
    np.savetxt(self.hessian_file, hessian, fmt=&#34;%s&#34;)</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeHost.get_unprocessed_hessian"><code class="name flex">
<span>def <span class="ident">get_unprocessed_hessian</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a text file of the unprocessed hessian matrix from the
formatted checkpoint file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_unprocessed_hessian(self):
    &#34;&#34;&#34;
    Saves a text file of the unprocessed hessian matrix from the 
    formatted checkpoint file.
    &#34;&#34;&#34;
    fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
    with open(fchk_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Cartesian Force Constants&#34; in lines[i]:
            no_hessian = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
            no_hessian = int(no_hessian[0])
    for i in range(len(lines)):
        if &#34;Cartesian Force Constants&#34; in lines[i]:
            to_begin = int(i)
    hessian = lines[
        to_begin + 1 : to_begin + 1 + int(math.ceil(no_hessian / 5))
    ]
    hessian_list = []
    for i in range(len(hessian)):
        hessian_list.append(hessian[i].strip().split())
    unprocessed_Hessian = [
        item for sublist in hessian_list for item in sublist
    ]
    np.savetxt(
        self.unprocessed_hessian_file, unprocessed_Hessian, fmt=&#34;%s&#34;
    )</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeHost.get_xyz"><code class="name flex">
<span>def <span class="ident">get_xyz</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves XYZ file from the formatted checkpoint file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_xyz(self):
    &#34;&#34;&#34;
    Saves XYZ file from the formatted checkpoint file.
    &#34;&#34;&#34;
    fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
    with open(fchk_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Current cartesian coordinates&#34; in lines[i]:
            no_coordinates = re.findall(r&#34;\d+|\d+.\d+&#34;, lines[i])
            no_coordinates = int(no_coordinates[0])
    for i in range(len(lines)):
        if &#34;Current cartesian coordinates&#34; in lines[i]:
            to_begin = int(i)
    cartesian_coords = lines[
        to_begin + 1 : to_begin + 1 + int(math.ceil(no_coordinates / 5))
    ]
    cartesian_list = []
    for i in range(len(cartesian_coords)):
        cartesian_list.append(cartesian_coords[i].strip().split())
    coordinates_list = [
        item for sublist in cartesian_list for item in sublist
    ]
    list_coords = [float(x) * float(0.529) for x in coordinates_list]
    for i in range(len(lines)):
        if &#34;Atomic numbers&#34; in lines[i]:
            to_begin = int(i)
        if &#34;Nuclear charges&#34; in lines[i]:
            to_end = int(i)
    atomic_numbers = lines[to_begin + 1 : to_end]
    atom_numbers = []
    for i in range(len(atomic_numbers)):
        atom_numbers.append(atomic_numbers[i].strip().split())
    numbers = [item for sublist in atom_numbers for item in sublist]
    N = int(no_coordinates / 3)
    # Opens the new xyz file
    file = open(self.xyz_file, &#34;w&#34;)
    file.write(str(N) + &#34;\n \n&#34;)
    coords = np.zeros((N, 3))
    n = 0
    names = []
    # Gives name for atomic number
    for x in range(0, len(numbers)):
        names.append(element_list[int(numbers[x]) - 1][1])
    # Print coordinates to new input_coords.xyz file
    for i in range(0, N):
        for j in range(0, 3):
            coords[i][j] = list_coords[n]
            n = n + 1
        file.write(
            names[i]
            + str(round(coords[i][0], 3))
            + &#34; &#34;
            + str(round(coords[i][1], 3))
            + &#34; &#34;
            + str(round(coords[i][2], 3))
            + &#34;\n&#34;
        )
    file.close()
    np.savetxt(self.coordinate_file, coords, fmt=&#34;%s&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.PrepareGaussianGuest"><code class="flex name class">
<span>class <span class="ident">PrepareGaussianGuest</span></span>
<span>(</span><span>charge, multiplicity, guest_pdb='guest_init_II.pdb', n_processors=12, memory=50, functional='B3LYP', basis_set='6-31G', optimisation='OPT', frequency='FREQ', add_keywords_I='Integral=(Grid=UltraFine)', add_keywords_II='Pop(MK,ReadRadii)', add_keywords_III='IOp(6/33=2,6/42=6)', gauss_out_file='guest.out', fchk_out_file='guest_fchk.out')</span>
</code></dt>
<dd>
<div class="desc"><p>A class used to prepare the QM engine input file (Gaussian)
for the ligand and run QM calculations with appropriate
keywords. </p>
<p>This class contain methods to write an input file (.com extension)
for the QM engine. It then runs a QM calculation with the given
basis set and functional. Checkpoint file is then converted to
a formatted checkpoint file. Output files (.log, .chk, and .fhck)
will then be used to extract ligand's force field parameters. </p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>charge</code></strong> :&ensp;<code>int</code></dt>
<dd>Charge of the ligand.</dd>
<dt><strong><code>multiplicity</code></strong> :&ensp;<code>int</code></dt>
<dd>Spin Multiplicity (2S+1) of the ligand where S represents
the total spin of the ligand.</dd>
<dt><strong><code>guest_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ligand PDB file with atom numbers beginning from 1.</dd>
<dt><strong><code>n_processors</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of processors to be used for Gaussian program to run and
set in %NProcShared command of Gaussian.</dd>
<dt><strong><code>memory</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Memory (in GB) to be used set in %Mem command of Gaussian.</dd>
<dt><strong><code>functional</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Exchange/Correlation or hybrid functional to use in the Gaussian
QM calculation.</dd>
<dt><strong><code>basis_set</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Basis set to use for the Gaussian QM calculation.</dd>
<dt><strong><code>optimisation</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>set to "OPT" to perform a geometry optimization on the ligand
specified in the system; else set to an empty string.</dd>
<dt><strong><code>frequency</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>set to "FREQ" for Gaussian to perform a frequency calculation;
else set to an empty string.</dd>
<dt><strong><code>add_keywords_I</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specifies the integration grid.</dd>
<dt><strong><code>add_keywords_II</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specifies the Gaussian described options for generating
population.</dd>
<dt><strong><code>add_keywords_III</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Used to include the IOp keyword (to set the internal options to
specific values) in the Gaussian command.</dd>
<dt><strong><code>gauss_out_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>This file contains the output script obtained after running
the Gaussian QM calculation.</dd>
<dt><strong><code>fchk_out_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Formatted checkpoint file obtained from the checkpoint file
using formchk command.</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>charge</code></strong> :&ensp;<code>int</code></dt>
<dd>Charge of the ligand.</dd>
<dt><strong><code>multiplicity</code></strong> :&ensp;<code>int</code></dt>
<dd>Spin Multiplicity (2S+1) of the ligand where S represents
the total spin of the ligand.</dd>
<dt><strong><code>guest_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ligand PDB file with atom numbers beginning from 1.</dd>
<dt><strong><code>n_processors</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of processors to be used for Gaussian program to run and
set in %NProcShared command of Gaussian.</dd>
<dt><strong><code>memory</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Memory (in GB) to be used set in %Mem command of Gaussian.</dd>
<dt><strong><code>functional</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Exchange/Correlation or hybrid functional to use in the Gaussian
QM calculation.</dd>
<dt><strong><code>basis_set</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Basis set to use for the Gaussian QM calculation.</dd>
<dt><strong><code>optimisation</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>set to "OPT" to perform a geometry optimization on the ligand
specified in the system; else set to an empty string.</dd>
<dt><strong><code>frequency</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>set to "FREQ" for Gaussian to perform a frequency calculation;
else set to an empty string.</dd>
<dt><strong><code>add_keywords_I</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specifies the integration grid.</dd>
<dt><strong><code>add_keywords_II</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specifies the Gaussian described options for generating
population.</dd>
<dt><strong><code>add_keywords_III</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Used to include the IOp keyword (to set the internal options to
specific values) in the Gaussian command.</dd>
<dt><strong><code>gauss_out_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>This file contains the output script obtained after running
the Gaussian QM calculation.</dd>
<dt><strong><code>fchk_out_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Formatted checkpoint file obtained from the checkpoint file
using formchk command.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrepareGaussianGuest:
    &#34;&#34;&#34;
    A class used to prepare the QM engine input file (Gaussian) 
    for the ligand and run QM calculations with appropriate 
    keywords. 

    This class contain methods to write an input file (.com extension)
    for the QM engine. It then runs a QM calculation with the given
    basis set and functional. Checkpoint file is then converted to 
    a formatted checkpoint file. Output files (.log, .chk, and .fhck)
    will then be used to extract ligand&#39;s force field parameters. 

    ...

    Attributes
    ----------
    charge : int
        Charge of the ligand. 

    multiplicity: int
        Spin Multiplicity (2S+1) of the ligand where S represents 
        the total spin of the ligand. 

    guest_pdb: str, optional
        Ligand PDB file with atom numbers beginning from 1.

    n_processors : int, optional
        Number of processors to be used for Gaussian program to run and 
        set in %NProcShared command of Gaussian.

    memory : int, optional
        Memory (in GB) to be used set in %Mem command of Gaussian.

    functional: str, optional
        Exchange/Correlation or hybrid functional to use in the Gaussian
        QM calculation.

    basis_set: str, optional
        Basis set to use for the Gaussian QM calculation.

    optimisation: str, optional
        set to &#34;OPT&#34; to perform a geometry optimization on the ligand
        specified in the system; else set to an empty string.

    frequency: str, optional
        set to &#34;FREQ&#34; for Gaussian to perform a frequency calculation;
        else set to an empty string.

    add_keywords_I: str, optional
        Specifies the integration grid.

    add_keywords_II: str, optional
        Specifies the Gaussian described options for generating
        population.

    add_keywords_III: str, optional
        Used to include the IOp keyword (to set the internal options to
        specific values) in the Gaussian command.

    gauss_out_file: str, optional
        This file contains the output script obtained after running
        the Gaussian QM calculation.

    fchk_out_file: str, optional
        Formatted checkpoint file obtained from the checkpoint file
        using formchk command.


    &#34;&#34;&#34;
    def __init__(
        self,
        charge,
        multiplicity,
        guest_pdb=&#34;guest_init_II.pdb&#34;,
        n_processors=12,
        memory=50,
        functional=&#34;B3LYP&#34;,
        basis_set=&#34;6-31G&#34;,
        optimisation=&#34;OPT&#34;,
        frequency=&#34;FREQ&#34;,
        add_keywords_I=&#34;Integral=(Grid=UltraFine)&#34;,
        add_keywords_II=&#34;Pop(MK,ReadRadii)&#34;,
        add_keywords_III=&#34;IOp(6/33=2,6/42=6)&#34;,
        gauss_out_file=&#34;guest.out&#34;,
        fchk_out_file=&#34;guest_fchk.out&#34;,
    ):

        &#34;&#34;&#34;
        Parameters
        ----------
        charge : int
            Charge of the ligand. 

        multiplicity: int
            Spin Multiplicity (2S+1) of the ligand where S represents 
            the total spin of the ligand. 

        guest_pdb: str, optional
            Ligand PDB file with atom numbers beginning from 1.

        n_processors : int, optional
            Number of processors to be used for Gaussian program to run and 
            set in %NProcShared command of Gaussian.

        memory : int, optional
            Memory (in GB) to be used set in %Mem command of Gaussian.

        functional: str, optional
            Exchange/Correlation or hybrid functional to use in the Gaussian
            QM calculation.

        basis_set: str, optional
            Basis set to use for the Gaussian QM calculation.

        optimisation: str, optional
            set to &#34;OPT&#34; to perform a geometry optimization on the ligand
            specified in the system; else set to an empty string.

        frequency: str, optional
            set to &#34;FREQ&#34; for Gaussian to perform a frequency calculation;
            else set to an empty string.

        add_keywords_I: str, optional
            Specifies the integration grid.

        add_keywords_II: str, optional
            Specifies the Gaussian described options for generating
            population.

        add_keywords_III: str, optional
            Used to include the IOp keyword (to set the internal options to
            specific values) in the Gaussian command.

        gauss_out_file: str, optional
            This file contains the output script obtained after running
            the Gaussian QM calculation.

        fchk_out_file: str, optional
            Formatted checkpoint file obtained from the checkpoint file
            using formchk command.

        &#34;&#34;&#34;

        self.charge = charge
        self.multiplicity = multiplicity
        self.guest_pdb = guest_pdb
        self.n_processors = n_processors
        self.memory = memory
        self.functional = functional
        self.basis_set = basis_set
        self.optimisation = optimisation
        self.frequency = frequency
        self.gauss_out_file = gauss_out_file
        self.fchk_out_file = fchk_out_file
        self.add_keywords_I = add_keywords_I
        self.add_keywords_II = add_keywords_II
        self.add_keywords_III = add_keywords_III

    def write_input(self):
        &#34;&#34;&#34;
        Writes a Gaussian input file for the ligand. 
        &#34;&#34;&#34;

        command_line_1 = &#34;%Chk = &#34; + self.guest_pdb[:-4] + &#34;.chk&#34;
        command_line_2 = &#34;%Mem = &#34; + str(self.memory) + &#34;GB&#34;
        command_line_3 = &#34;%NProcShared = &#34; + str(self.n_processors)
        command_line_4 = (
            &#34;# &#34;
            + self.functional
            + &#34; &#34;
            + self.basis_set
            + &#34; &#34;
            + self.optimisation
            + &#34; &#34;
            + self.frequency
            + &#34; &#34;
            + self.add_keywords_I
            + &#34; &#34;
            + self.add_keywords_II
            + &#34; &#34;
            + self.add_keywords_III
        )
        command_line_5 = &#34; &#34;
        command_line_6 = self.guest_pdb[:-4] + &#34; &#34; + &#34;gaussian input file&#34;
        command_line_7 = &#34; &#34;
        command_line_8 = str(self.charge) + &#34; &#34; + str(self.multiplicity)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_pdb)
        df = ppdb.df[&#34;ATOM&#34;]
        df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
        df_1.columns = [&#34;atom&#34;]
        df_2 = df[[&#34;x_coord&#34;, &#34;y_coord&#34;, &#34;z_coord&#34;]]
        df_merged = pd.concat([df_1, df_2], axis=1)
        command_line_9 = df_merged.to_string(header=False, index=False)
        command_line_10 = &#34; &#34;
        command = [
            command_line_1,
            command_line_2,
            command_line_3,
            command_line_4,
            command_line_5,
            command_line_6,
            command_line_7,
            command_line_8,
            command_line_9,
            command_line_10,
        ]
        commands = &#34;\n&#34;.join(command)
        with open(self.guest_pdb[:-4] + &#34;.com&#34;, &#34;w&#34;) as f:
            f.write(commands)

    def run_gaussian(self):
        &#34;&#34;&#34;
        Runs the Gaussian QM calculation for the ligand locally.
        &#34;&#34;&#34;
        execute_command = (
            &#34;g16&#34;
            + &#34; &lt; &#34;
            + self.guest_pdb[:-4]
            + &#34;.com&#34;
            + &#34; &gt; &#34;
            + self.guest_pdb[:-4]
            + &#34;.log&#34;
        )
        with open(self.gauss_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell=True, stdout=f, stderr=sp.STDOUT)

    def get_fchk(self):
        &#34;&#34;&#34;
        Converts the Gaussian checkpoint file (.chk) to a formatted checkpoint
        file (.fchk).
        &#34;&#34;&#34;
        execute_command = (
            &#34;formchk&#34;
            + &#34; &#34;
            + self.guest_pdb[:-4]
            + &#34;.chk&#34;
            + &#34; &#34;
            + self.guest_pdb[:-4]
            + &#34;.fchk&#34;
        )
        with open(self.fchk_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell=True, stdout=f, stderr=sp.STDOUT)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.PrepareGaussianGuest.get_fchk"><code class="name flex">
<span>def <span class="ident">get_fchk</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the Gaussian checkpoint file (.chk) to a formatted checkpoint
file (.fchk).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fchk(self):
    &#34;&#34;&#34;
    Converts the Gaussian checkpoint file (.chk) to a formatted checkpoint
    file (.fchk).
    &#34;&#34;&#34;
    execute_command = (
        &#34;formchk&#34;
        + &#34; &#34;
        + self.guest_pdb[:-4]
        + &#34;.chk&#34;
        + &#34; &#34;
        + self.guest_pdb[:-4]
        + &#34;.fchk&#34;
    )
    with open(self.fchk_out_file, &#34;w+&#34;) as f:
        sp.run(execute_command, shell=True, stdout=f, stderr=sp.STDOUT)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareGaussianGuest.run_gaussian"><code class="name flex">
<span>def <span class="ident">run_gaussian</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the Gaussian QM calculation for the ligand locally.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_gaussian(self):
    &#34;&#34;&#34;
    Runs the Gaussian QM calculation for the ligand locally.
    &#34;&#34;&#34;
    execute_command = (
        &#34;g16&#34;
        + &#34; &lt; &#34;
        + self.guest_pdb[:-4]
        + &#34;.com&#34;
        + &#34; &gt; &#34;
        + self.guest_pdb[:-4]
        + &#34;.log&#34;
    )
    with open(self.gauss_out_file, &#34;w+&#34;) as f:
        sp.run(execute_command, shell=True, stdout=f, stderr=sp.STDOUT)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareGaussianGuest.write_input"><code class="name flex">
<span>def <span class="ident">write_input</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes a Gaussian input file for the ligand.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_input(self):
    &#34;&#34;&#34;
    Writes a Gaussian input file for the ligand. 
    &#34;&#34;&#34;

    command_line_1 = &#34;%Chk = &#34; + self.guest_pdb[:-4] + &#34;.chk&#34;
    command_line_2 = &#34;%Mem = &#34; + str(self.memory) + &#34;GB&#34;
    command_line_3 = &#34;%NProcShared = &#34; + str(self.n_processors)
    command_line_4 = (
        &#34;# &#34;
        + self.functional
        + &#34; &#34;
        + self.basis_set
        + &#34; &#34;
        + self.optimisation
        + &#34; &#34;
        + self.frequency
        + &#34; &#34;
        + self.add_keywords_I
        + &#34; &#34;
        + self.add_keywords_II
        + &#34; &#34;
        + self.add_keywords_III
    )
    command_line_5 = &#34; &#34;
    command_line_6 = self.guest_pdb[:-4] + &#34; &#34; + &#34;gaussian input file&#34;
    command_line_7 = &#34; &#34;
    command_line_8 = str(self.charge) + &#34; &#34; + str(self.multiplicity)
    ppdb = PandasPdb()
    ppdb.read_pdb(self.guest_pdb)
    df = ppdb.df[&#34;ATOM&#34;]
    df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
    df_1.columns = [&#34;atom&#34;]
    df_2 = df[[&#34;x_coord&#34;, &#34;y_coord&#34;, &#34;z_coord&#34;]]
    df_merged = pd.concat([df_1, df_2], axis=1)
    command_line_9 = df_merged.to_string(header=False, index=False)
    command_line_10 = &#34; &#34;
    command = [
        command_line_1,
        command_line_2,
        command_line_3,
        command_line_4,
        command_line_5,
        command_line_6,
        command_line_7,
        command_line_8,
        command_line_9,
        command_line_10,
    ]
    commands = &#34;\n&#34;.join(command)
    with open(self.guest_pdb[:-4] + &#34;.com&#34;, &#34;w&#34;) as f:
        f.write(commands)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.PrepareGaussianHost"><code class="flex name class">
<span>class <span class="ident">PrepareGaussianHost</span></span>
<span>(</span><span>charge, multiplicity, host_qm_pdb='host_qm.pdb', n_processors=12, memory=50, functional='B3LYP', basis_set='6-31G', optimisation='OPT', frequency='FREQ', add_keywords_I='Integral=(Grid=UltraFine)', add_keywords_II='Pop(MK,ReadRadii)', add_keywords_III='IOp(6/33=2,6/42=6)', gauss_out_file='host_qm.out', fchk_out_file='host_qm_fchk.out')</span>
</code></dt>
<dd>
<div class="desc"><p>A class used to prepare the QM engine input file (Gaussian)
for the receptor and run QM calculations with appropriate keywords. </p>
<p>This class contain methods to write an input file (.com extension)
for the QM engine. It then runs a QM calculation with the given
basis set and functional. Checkpoint file is then converted to
a formatted checkpoint file. Output files (.log, .chk, and .fhck)
will then be used to extract receptors's force field parameters. </p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>charge</code></strong> :&ensp;<code>int</code></dt>
<dd>Charge of the receptor.</dd>
<dt><strong><code>multiplicity</code></strong> :&ensp;<code>int</code></dt>
<dd>Spin Multiplicity (2S+1) of the receptor where S represents
the total spin of the receptor.</dd>
<dt><strong><code>host_qm_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>PDB file of the receptor's QM region with atom numbers
beginning from 1.</dd>
<dt><strong><code>n_processors</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of processors to be used for Gaussian program to run and
set in %NProcShared command of Gaussian.</dd>
<dt><strong><code>memory</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Memory (in GB) to be used set in %Mem command of Gaussian.</dd>
<dt><strong><code>functional</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Exchange/Correlation or hybrid functional to use in the Gaussian
QM calculation.</dd>
<dt><strong><code>basis_set</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Basis set to use for the Gaussian QM calculation.</dd>
<dt><strong><code>optimisation</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>set to "OPT" to perform a geometry optimization on the receptor
specified in the system; else set to an empty string.</dd>
<dt><strong><code>frequency</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>set to "FREQ" for Gaussian to perform a frequency calculation;
else set to an empty string.</dd>
<dt><strong><code>add_keywords_I</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specifies the integration grid.</dd>
<dt><strong><code>add_keywords_II</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specifies the Gaussian described options for generating
population.</dd>
<dt><strong><code>add_keywords_III</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Used to include the IOp keyword (to set the internal options to
specific values) in the Gaussian command.</dd>
<dt><strong><code>gauss_out_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>This file contains the output script obtained after running
the Gaussian QM calculation.</dd>
<dt><strong><code>fchk_out_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Formatted checkpoint file obtained from the checkpoint file
using formchk command.</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>charge</code></strong> :&ensp;<code>int</code></dt>
<dd>Charge of the receptor.</dd>
<dt><strong><code>multiplicity</code></strong> :&ensp;<code>int</code></dt>
<dd>Spin Multiplicity (2S+1) of the receptor where S represents
the total spin of the receptor.</dd>
<dt><strong><code>host_qm_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>PDB file of the receptor's QM region with atom numbers
beginning from 1.</dd>
<dt><strong><code>n_processors</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of processors to be used for Gaussian program to run and
set in %NProcShared command of Gaussian.</dd>
<dt><strong><code>memory</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Memory (in GB) to be used set in %Mem command of Gaussian.</dd>
<dt><strong><code>functional</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Exchange/Correlation or hybrid functional to use in the Gaussian
QM calculation.</dd>
<dt><strong><code>basis_set</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Basis set to use for the Gaussian QM calculation.</dd>
<dt><strong><code>optimisation</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>set to "OPT" to perform a geometry optimization on the receptor
specified in the system; else set to an empty string.</dd>
<dt><strong><code>frequency</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>set to "FREQ" for Gaussian to perform a frequency calculation;
else set to an empty string.</dd>
<dt><strong><code>add_keywords_I</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specifies the integration grid.</dd>
<dt><strong><code>add_keywords_II</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specifies the Gaussian described options for generating
population.</dd>
<dt><strong><code>add_keywords_III</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Used to include the IOp keyword (to set the internal options to
specific values) in the Gaussian command.</dd>
<dt><strong><code>gauss_out_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>This file contains the output script obtained after running
the Gaussian QM calculation.</dd>
<dt><strong><code>fchk_out_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Formatted checkpoint file obtained from the checkpoint file
using formchk command.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrepareGaussianHost:
    &#34;&#34;&#34;
    A class used to prepare the QM engine input file (Gaussian) 
    for the receptor and run QM calculations with appropriate keywords. 

    This class contain methods to write an input file (.com extension)
    for the QM engine. It then runs a QM calculation with the given
    basis set and functional. Checkpoint file is then converted to 
    a formatted checkpoint file. Output files (.log, .chk, and .fhck)
    will then be used to extract receptors&#39;s force field parameters. 

    ...

    Attributes
    ----------
    charge : int
        Charge of the receptor. 

    multiplicity: int
        Spin Multiplicity (2S+1) of the receptor where S represents 
        the total spin of the receptor. 

    host_qm_pdb: str, optional
        PDB file of the receptor&#39;s QM region with atom numbers 
        beginning from 1.

    n_processors : int, optional
        Number of processors to be used for Gaussian program to run and 
        set in %NProcShared command of Gaussian.

    memory : int, optional
        Memory (in GB) to be used set in %Mem command of Gaussian.

    functional: str, optional
        Exchange/Correlation or hybrid functional to use in the Gaussian
        QM calculation.

    basis_set: str, optional
        Basis set to use for the Gaussian QM calculation.

    optimisation: str, optional
        set to &#34;OPT&#34; to perform a geometry optimization on the receptor
        specified in the system; else set to an empty string.

    frequency: str, optional
        set to &#34;FREQ&#34; for Gaussian to perform a frequency calculation;
        else set to an empty string.

    add_keywords_I: str, optional
        Specifies the integration grid.

    add_keywords_II: str, optional
        Specifies the Gaussian described options for generating
        population.

    add_keywords_III: str, optional
        Used to include the IOp keyword (to set the internal options to
        specific values) in the Gaussian command.

    gauss_out_file: str, optional
        This file contains the output script obtained after running
        the Gaussian QM calculation.

    fchk_out_file: str, optional
        Formatted checkpoint file obtained from the checkpoint file
        using formchk command.

    &#34;&#34;&#34;

    def __init__(
        self,
        charge,
        multiplicity,
        host_qm_pdb=&#34;host_qm.pdb&#34;,
        n_processors=12,
        memory=50,
        functional=&#34;B3LYP&#34;,
        basis_set=&#34;6-31G&#34;,
        optimisation=&#34;OPT&#34;,
        frequency=&#34;FREQ&#34;,
        add_keywords_I=&#34;Integral=(Grid=UltraFine)&#34;,
        add_keywords_II=&#34;Pop(MK,ReadRadii)&#34;,
        add_keywords_III=&#34;IOp(6/33=2,6/42=6)&#34;,
        gauss_out_file=&#34;host_qm.out&#34;,
        fchk_out_file=&#34;host_qm_fchk.out&#34;,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        charge : int
            Charge of the receptor. 

        multiplicity: int
            Spin Multiplicity (2S+1) of the receptor where S represents 
            the total spin of the receptor. 

        host_qm_pdb: str, optional
            PDB file of the receptor&#39;s QM region with atom numbers 
            beginning from 1.

        n_processors : int, optional
            Number of processors to be used for Gaussian program to run and 
            set in %NProcShared command of Gaussian.

        memory : int, optional
            Memory (in GB) to be used set in %Mem command of Gaussian.

        functional: str, optional
            Exchange/Correlation or hybrid functional to use in the Gaussian
            QM calculation.

        basis_set: str, optional
            Basis set to use for the Gaussian QM calculation.

        optimisation: str, optional
            set to &#34;OPT&#34; to perform a geometry optimization on the receptor
            specified in the system; else set to an empty string.

        frequency: str, optional
            set to &#34;FREQ&#34; for Gaussian to perform a frequency calculation;
            else set to an empty string.

        add_keywords_I: str, optional
            Specifies the integration grid.

        add_keywords_II: str, optional
            Specifies the Gaussian described options for generating
            population.

        add_keywords_III: str, optional
            Used to include the IOp keyword (to set the internal options to
            specific values) in the Gaussian command.

        gauss_out_file: str, optional
            This file contains the output script obtained after running
            the Gaussian QM calculation.

        fchk_out_file: str, optional
            Formatted checkpoint file obtained from the checkpoint file
            using formchk command.

        &#34;&#34;&#34;
        self.charge = charge
        self.multiplicity = multiplicity
        self.host_qm_pdb = host_qm_pdb
        self.n_processors = n_processors
        self.memory = memory
        self.functional = functional
        self.basis_set = basis_set
        self.optimisation = optimisation
        self.frequency = frequency
        self.gauss_out_file = gauss_out_file
        self.fchk_out_file = fchk_out_file
        self.add_keywords_I = add_keywords_I
        self.add_keywords_II = add_keywords_II
        self.add_keywords_III = add_keywords_III

    def write_input(self):
        &#34;&#34;&#34;
        Writes a Gaussian input file for the receptor QM region. 
        &#34;&#34;&#34;
        command_line_1 = &#34;%Chk = &#34; + self.host_qm_pdb[:-4] + &#34;.chk&#34;
        command_line_2 = &#34;%Mem = &#34; + str(self.memory) + &#34;GB&#34;
        command_line_3 = &#34;%NProcShared = &#34; + str(self.n_processors)
        command_line_4 = (
            &#34;# &#34;
            + self.functional
            + &#34; &#34;
            + self.basis_set
            + &#34; &#34;
            + self.optimisation
            + &#34; &#34;
            + self.frequency
            + &#34; &#34;
            + self.add_keywords_I
            + &#34; &#34;
            + self.add_keywords_II
            + &#34; &#34;
            + self.add_keywords_III
        )
        command_line_5 = &#34; &#34;
        command_line_6 = self.host_qm_pdb[:-4] + &#34; &#34; + &#34;gaussian input file&#34;
        command_line_7 = &#34; &#34;
        command_line_8 = str(self.charge) + &#34; &#34; + str(self.multiplicity)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_qm_pdb)
        df = ppdb.df[&#34;ATOM&#34;]
        df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
        df_1.columns = [&#34;atom&#34;]
        df_2 = df[[&#34;x_coord&#34;, &#34;y_coord&#34;, &#34;z_coord&#34;]]
        df_merged = pd.concat([df_1, df_2], axis=1)
        command_line_9 = df_merged.to_string(header=False, index=False)
        command_line_10 = &#34; &#34;
        command = [
            command_line_1,
            command_line_2,
            command_line_3,
            command_line_4,
            command_line_5,
            command_line_6,
            command_line_7,
            command_line_8,
            command_line_9,
            command_line_10,
        ]
        commands = &#34;\n&#34;.join(command)
        with open(self.host_qm_pdb[:-4] + &#34;.com&#34;, &#34;w&#34;) as f:
            f.write(commands)

    def run_gaussian(self):
        &#34;&#34;&#34;
        Runs the Gaussian QM calculation for the receptor locally.
        &#34;&#34;&#34;
        execute_command = (
            &#34;g16&#34;
            + &#34; &lt; &#34;
            + self.host_qm_pdb[:-4]
            + &#34;.com&#34;
            + &#34; &gt; &#34;
            + self.host_qm_pdb[:-4]
            + &#34;.log&#34;
        )
        with open(self.gauss_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell=True, stdout=f, stderr=sp.STDOUT)

    def get_fchk(self):
        &#34;&#34;&#34;
        Converts the Gaussian checkpoint file (.chk) to a formatted checkpoint
        file (.fchk).
        &#34;&#34;&#34;
        execute_command = (
            &#34;formchk&#34;
            + &#34; &#34;
            + self.host_qm_pdb[:-4]
            + &#34;.chk&#34;
            + &#34; &#34;
            + self.host_qm_pdb[:-4]
            + &#34;.fchk&#34;
        )
        with open(self.fchk_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell=True, stdout=f, stderr=sp.STDOUT)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.PrepareGaussianHost.get_fchk"><code class="name flex">
<span>def <span class="ident">get_fchk</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the Gaussian checkpoint file (.chk) to a formatted checkpoint
file (.fchk).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fchk(self):
    &#34;&#34;&#34;
    Converts the Gaussian checkpoint file (.chk) to a formatted checkpoint
    file (.fchk).
    &#34;&#34;&#34;
    execute_command = (
        &#34;formchk&#34;
        + &#34; &#34;
        + self.host_qm_pdb[:-4]
        + &#34;.chk&#34;
        + &#34; &#34;
        + self.host_qm_pdb[:-4]
        + &#34;.fchk&#34;
    )
    with open(self.fchk_out_file, &#34;w+&#34;) as f:
        sp.run(execute_command, shell=True, stdout=f, stderr=sp.STDOUT)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareGaussianHost.run_gaussian"><code class="name flex">
<span>def <span class="ident">run_gaussian</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the Gaussian QM calculation for the receptor locally.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_gaussian(self):
    &#34;&#34;&#34;
    Runs the Gaussian QM calculation for the receptor locally.
    &#34;&#34;&#34;
    execute_command = (
        &#34;g16&#34;
        + &#34; &lt; &#34;
        + self.host_qm_pdb[:-4]
        + &#34;.com&#34;
        + &#34; &gt; &#34;
        + self.host_qm_pdb[:-4]
        + &#34;.log&#34;
    )
    with open(self.gauss_out_file, &#34;w+&#34;) as f:
        sp.run(execute_command, shell=True, stdout=f, stderr=sp.STDOUT)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareGaussianHost.write_input"><code class="name flex">
<span>def <span class="ident">write_input</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes a Gaussian input file for the receptor QM region.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_input(self):
    &#34;&#34;&#34;
    Writes a Gaussian input file for the receptor QM region. 
    &#34;&#34;&#34;
    command_line_1 = &#34;%Chk = &#34; + self.host_qm_pdb[:-4] + &#34;.chk&#34;
    command_line_2 = &#34;%Mem = &#34; + str(self.memory) + &#34;GB&#34;
    command_line_3 = &#34;%NProcShared = &#34; + str(self.n_processors)
    command_line_4 = (
        &#34;# &#34;
        + self.functional
        + &#34; &#34;
        + self.basis_set
        + &#34; &#34;
        + self.optimisation
        + &#34; &#34;
        + self.frequency
        + &#34; &#34;
        + self.add_keywords_I
        + &#34; &#34;
        + self.add_keywords_II
        + &#34; &#34;
        + self.add_keywords_III
    )
    command_line_5 = &#34; &#34;
    command_line_6 = self.host_qm_pdb[:-4] + &#34; &#34; + &#34;gaussian input file&#34;
    command_line_7 = &#34; &#34;
    command_line_8 = str(self.charge) + &#34; &#34; + str(self.multiplicity)
    ppdb = PandasPdb()
    ppdb.read_pdb(self.host_qm_pdb)
    df = ppdb.df[&#34;ATOM&#34;]
    df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
    df_1.columns = [&#34;atom&#34;]
    df_2 = df[[&#34;x_coord&#34;, &#34;y_coord&#34;, &#34;z_coord&#34;]]
    df_merged = pd.concat([df_1, df_2], axis=1)
    command_line_9 = df_merged.to_string(header=False, index=False)
    command_line_10 = &#34; &#34;
    command = [
        command_line_1,
        command_line_2,
        command_line_3,
        command_line_4,
        command_line_5,
        command_line_6,
        command_line_7,
        command_line_8,
        command_line_9,
        command_line_10,
    ]
    commands = &#34;\n&#34;.join(command)
    with open(self.host_qm_pdb[:-4] + &#34;.com&#34;, &#34;w&#34;) as f:
        f.write(commands)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.PrepareGaussianHostGuest"><code class="flex name class">
<span>class <span class="ident">PrepareGaussianHostGuest</span></span>
<span>(</span><span>charge, multiplicity, guest_pdb='guest_init_II.pdb', host_qm_pdb='host_qm.pdb', n_processors=12, memory=50, functional='B3LYP', basis_set='6-31G', optimisation='', frequency='', add_keywords_I='Integral=(Grid=UltraFine)', add_keywords_II='Pop(MK,ReadRadii)', add_keywords_III='IOp(6/33=2,6/42=6)', gauss_system_out_file='system_qm.out', fchk_system_out_file='system_qm_fchk.out', host_guest_input='host_guest.com', qm_guest_charge_parameter_file='guest_qm_surround_charges.txt', qm_host_charge_parameter_file='host_qm_surround_charges.txt', qm_guest_atom_charge_parameter_file='guest_qm_atom_surround_charges.txt')</span>
</code></dt>
<dd>
<div class="desc"><p>A class used to prepare the QM engine input file (Gaussian) for
the receptor - ligand complex and run the QM calculations with
the appropriate keywords. </p>
<p>This class contain methods to write an input file (.com extension)
for the QM engine for the receptor - ligand complex. It then runs
a QM calculation with the given basis set and functional. Checkpoint
file is then converted to a formatted checkpoint file. Output files
(.log, .chk, and .fhck) will then be used to extract charges for the
ligand and the receptor.</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>charge</code></strong> :&ensp;<code>int</code></dt>
<dd>Total charge of the receptor - ligand complex.</dd>
<dt><strong><code>multiplicity</code></strong> :&ensp;<code>int</code></dt>
<dd>Spin Multiplicity (2S+1) of the ligand where S represents
the total spin of the ligand.</dd>
<dt><strong><code>guest_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ligand PDB file with atom numbers beginning from 1.</dd>
<dt><strong><code>host_qm_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>PDB file for the receptor's QM region.</dd>
<dt><strong><code>n_processors</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of processors to be used for Gaussian program to run and
set in %NProcShared command of Gaussian.</dd>
<dt><strong><code>memory</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Memory (in GB) to be used set in %Mem command of Gaussian.</dd>
<dt><strong><code>functional</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Exchange/Correlation or hybrid functional to use in the Gaussian
QM calculation.</dd>
<dt><strong><code>basis_set</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Basis set to use for the Gaussian QM calculation.</dd>
<dt><strong><code>optimisation</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>set to "OPT" to perform a geometry optimization on the ligand
specified in the system; else set to an empty string.</dd>
<dt><strong><code>frequency</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>set to "FREQ" for Gaussian to perform a frequency calculation;
else set to an empty string.</dd>
<dt><strong><code>add_keywords_I</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specifies the integration grid.</dd>
<dt><strong><code>add_keywords_II</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specifies the Gaussian described options for generating
population.</dd>
<dt><strong><code>add_keywords_III</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Used to include the IOp keyword (to set the internal options to
specific values) in the Gaussian command.</dd>
<dt><strong><code>gauss_system_out_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>This file contains the output script obtained after running
the Gaussian QM calculation.</dd>
<dt><strong><code>fchk_system_out_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Formatted checkpoint file obtained from the checkpoint file
using formchk command.</dd>
<dt><strong><code>host_guest_input</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Gaussian input file (.com extension) for the receptor - ligand
QM region.</dd>
<dt><strong><code>qm_guest_charge_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>File containing the charges of ligand atoms and their corresponding
atoms. Charge obtained are the polarised charged due to the
surrounding receptor's region.</dd>
<dt><strong><code>qm_host_charge_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>File containing the charges of the QM region of the receptor.</dd>
<dt><strong><code>qm_guest_atom_charge_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>File containing the charges of ligand atoms. Charge obtained
are the polarised charged due to the surrounding receptor's region.</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>charge</code></strong> :&ensp;<code>int</code></dt>
<dd>Total charge of the receptor - ligand complex.</dd>
<dt><strong><code>multiplicity</code></strong> :&ensp;<code>int</code></dt>
<dd>Spin Multiplicity (2S+1) of the ligand where S represents
the total spin of the ligand.</dd>
<dt><strong><code>guest_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ligand PDB file with atom numbers beginning from 1.</dd>
<dt><strong><code>host_qm_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>PDB file for the receptor's QM region.</dd>
<dt><strong><code>n_processors</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of processors to be used for Gaussian program to run and
set in %NProcShared command of Gaussian.</dd>
<dt><strong><code>memory</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Memory (in GB) to be used set in %Mem command of Gaussian.</dd>
<dt><strong><code>functional</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Exchange/Correlation or hybrid functional to use in the Gaussian
QM calculation.</dd>
<dt><strong><code>basis_set</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Basis set to use for the Gaussian QM calculation.</dd>
<dt><strong><code>optimisation</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>set to "OPT" to perform a geometry optimization on the ligand
specified in the system; else set to an empty string.</dd>
<dt><strong><code>frequency</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>set to "FREQ" for Gaussian to perform a frequency calculation;
else set to an empty string.</dd>
<dt><strong><code>add_keywords_I</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specifies the integration grid.</dd>
<dt><strong><code>add_keywords_II</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specifies the Gaussian described options for generating
population.</dd>
<dt><strong><code>add_keywords_III</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Used to include the IOp keyword (to set the internal options to
specific values) in the Gaussian command.</dd>
<dt><strong><code>gauss_system_out_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>This file contains the output script obtained after running
the Gaussian QM calculation.</dd>
<dt><strong><code>fchk_system_out_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Formatted checkpoint file obtained from the checkpoint file
using formchk command.</dd>
<dt><strong><code>host_guest_input</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Gaussian input file (.com extension) for the receptor - ligand
QM region.</dd>
<dt><strong><code>qm_guest_charge_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>File containing the charges of ligand atoms and their corresponding
atoms. Charge obtained are the polarised charged due to the
surrounding receptor's region.</dd>
<dt><strong><code>qm_host_charge_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>File containing the charges of the QM region of the receptor.</dd>
<dt><strong><code>qm_guest_atom_charge_parameter_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>File containing the charges of ligand atoms. Charge obtained
are the polarised charged due to the surrounding receptor's region.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrepareGaussianHostGuest:
    &#34;&#34;&#34;
    A class used to prepare the QM engine input file (Gaussian) for 
    the receptor - ligand complex and run the QM calculations with 
    the appropriate keywords. 

    This class contain methods to write an input file (.com extension)
    for the QM engine for the receptor - ligand complex. It then runs 
    a QM calculation with the given basis set and functional. Checkpoint
    file is then converted to a formatted checkpoint file. Output files
    (.log, .chk, and .fhck) will then be used to extract charges for the 
    ligand and the receptor.

    ...

    Attributes
    ----------
    charge : int
        Total charge of the receptor - ligand complex.

    multiplicity : int
        Spin Multiplicity (2S+1) of the ligand where S represents 
        the total spin of the ligand. 

    guest_pdb : str, optional
        Ligand PDB file with atom numbers beginning from 1.

    host_qm_pdb : str, optional
        PDB file for the receptor&#39;s QM region.

    n_processors : int, optional
        Number of processors to be used for Gaussian program to run and 
        set in %NProcShared command of Gaussian.

    memory : int, optional
        Memory (in GB) to be used set in %Mem command of Gaussian.

    functional: str, optional
        Exchange/Correlation or hybrid functional to use in the Gaussian
        QM calculation.

    basis_set: str, optional
        Basis set to use for the Gaussian QM calculation.

    optimisation: str, optional
        set to &#34;OPT&#34; to perform a geometry optimization on the ligand
        specified in the system; else set to an empty string.

    frequency: str, optional
        set to &#34;FREQ&#34; for Gaussian to perform a frequency calculation;
        else set to an empty string.

    add_keywords_I: str, optional
        Specifies the integration grid.

    add_keywords_II: str, optional
        Specifies the Gaussian described options for generating
        population.

    add_keywords_III: str, optional
        Used to include the IOp keyword (to set the internal options to
        specific values) in the Gaussian command.

    gauss_system_out_file : str, optional
        This file contains the output script obtained after running
        the Gaussian QM calculation.

    fchk_system_out_file : str, optional
        Formatted checkpoint file obtained from the checkpoint file
        using formchk command.

    host_guest_input : str, optional
        Gaussian input file (.com extension) for the receptor - ligand 
        QM region.

    qm_guest_charge_parameter_file : str, optional
        File containing the charges of ligand atoms and their corresponding
        atoms. Charge obtained are the polarised charged due to the 
        surrounding receptor&#39;s region.

    qm_host_charge_parameter_file : str, optional
        File containing the charges of the QM region of the receptor. 

    qm_guest_atom_charge_parameter_file : str, optional
        File containing the charges of ligand atoms. Charge obtained 
        are the polarised charged due to the surrounding receptor&#39;s region.

    &#34;&#34;&#34;
    def __init__(
        self,
        charge,
        multiplicity,
        guest_pdb=&#34;guest_init_II.pdb&#34;,
        host_qm_pdb=&#34;host_qm.pdb&#34;,
        n_processors=12,
        memory=50,
        functional=&#34;B3LYP&#34;,
        basis_set=&#34;6-31G&#34;,
        optimisation=&#34;&#34;,
        frequency=&#34;&#34;,
        add_keywords_I=&#34;Integral=(Grid=UltraFine)&#34;,
        add_keywords_II=&#34;Pop(MK,ReadRadii)&#34;,
        add_keywords_III=&#34;IOp(6/33=2,6/42=6)&#34;,
        gauss_system_out_file=&#34;system_qm.out&#34;,
        fchk_system_out_file=&#34;system_qm_fchk.out&#34;,
        host_guest_input=&#34;host_guest.com&#34;,
        qm_guest_charge_parameter_file=&#34;guest_qm_surround_charges.txt&#34;,
        qm_host_charge_parameter_file=&#34;host_qm_surround_charges.txt&#34;,
        qm_guest_atom_charge_parameter_file=&#34;guest_qm_atom_surround_charges.txt&#34;,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        charge : int
            Total charge of the receptor - ligand complex.

        multiplicity : int
            Spin Multiplicity (2S+1) of the ligand where S represents 
            the total spin of the ligand. 

        guest_pdb : str, optional
            Ligand PDB file with atom numbers beginning from 1.

        host_qm_pdb : str, optional
            PDB file for the receptor&#39;s QM region.

        n_processors : int, optional
            Number of processors to be used for Gaussian program to run and 
            set in %NProcShared command of Gaussian.

        memory : int, optional
            Memory (in GB) to be used set in %Mem command of Gaussian.

        functional: str, optional
            Exchange/Correlation or hybrid functional to use in the Gaussian
            QM calculation.

        basis_set: str, optional
            Basis set to use for the Gaussian QM calculation.

        optimisation: str, optional
            set to &#34;OPT&#34; to perform a geometry optimization on the ligand
            specified in the system; else set to an empty string.

        frequency: str, optional
            set to &#34;FREQ&#34; for Gaussian to perform a frequency calculation;
            else set to an empty string.

        add_keywords_I: str, optional
            Specifies the integration grid.

        add_keywords_II: str, optional
            Specifies the Gaussian described options for generating
            population.

        add_keywords_III: str, optional
            Used to include the IOp keyword (to set the internal options to
            specific values) in the Gaussian command.

        gauss_system_out_file : str, optional
            This file contains the output script obtained after running
            the Gaussian QM calculation.

        fchk_system_out_file : str, optional
            Formatted checkpoint file obtained from the checkpoint file
            using formchk command.

        host_guest_input : str, optional
            Gaussian input file (.com extension) for the receptor - ligand 
            QM region.

        qm_guest_charge_parameter_file : str, optional
            File containing the charges of ligand atoms and their corresponding
            atoms. Charge obtained are the polarised charged due to the 
            surrounding receptor&#39;s region.

        qm_host_charge_parameter_file : str, optional
            File containing the charges of the QM region of the receptor. 

        qm_guest_atom_charge_parameter_file : str, optional
            File containing the charges of ligand atoms. Charge obtained 
            are the polarised charged due to the surrounding receptor&#39;s region.
  
        &#34;&#34;&#34;
        self.charge = charge
        self.multiplicity = multiplicity
        self.guest_pdb = guest_pdb
        self.host_qm_pdb = host_qm_pdb
        self.n_processors = n_processors
        self.memory = memory
        self.functional = functional
        self.basis_set = basis_set
        self.optimisation = optimisation
        self.frequency = frequency
        self.add_keywords_I = add_keywords_I
        self.add_keywords_II = add_keywords_II
        self.add_keywords_III = add_keywords_III
        self.gauss_system_out_file = gauss_system_out_file
        self.fchk_system_out_file = fchk_system_out_file
        self.host_guest_input = host_guest_input
        self.qm_guest_charge_parameter_file = qm_guest_charge_parameter_file
        self.qm_host_charge_parameter_file = qm_host_charge_parameter_file
        self.qm_guest_atom_charge_parameter_file = qm_guest_atom_charge_parameter_file

    def write_input(self):
        &#34;&#34;&#34;
        Writes a Gaussian input file for the receptor - ligand QM region. 
        &#34;&#34;&#34;
        command_line_1 = &#34;%Chk = &#34; + self.host_guest_input[:-4] + &#34;.chk&#34;
        command_line_2 = &#34;%Mem = &#34; + str(self.memory) + &#34;GB&#34;
        command_line_3 = &#34;%NProcShared = &#34; + str(self.n_processors)
        command_line_4 = (
            &#34;# &#34;
            + self.functional
            + &#34; &#34;
            + self.basis_set
            + &#34; &#34;
            + self.optimisation
            + &#34; &#34;
            + self.frequency
            + &#34; &#34;
            + self.add_keywords_I
            + &#34; &#34;
            + self.add_keywords_II
            + &#34; &#34;
            + self.add_keywords_III
        )
        command_line_5 = &#34; &#34;
        command_line_6 = &#34;Gaussian Input File&#34;
        command_line_7 = &#34; &#34;
        command_line_8 = str(self.charge) + &#34; &#34; + str(self.multiplicity)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_pdb)
        df = ppdb.df[&#34;ATOM&#34;]
        df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
        df_1.columns = [&#34;atom&#34;]
        df_3 = df[[&#34;x_coord&#34;, &#34;y_coord&#34;, &#34;z_coord&#34;]]
        df_2 = pd.Series([&#34;0&#34;] * len(df), name=&#34;decide_freeze&#34;)
        df_merged_1 = pd.concat([df_1, df_2, df_3], axis=1)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_qm_pdb)
        df = ppdb.df[&#34;ATOM&#34;]
        df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
        df_1.columns = [&#34;atom&#34;]
        df_3 = df[[&#34;x_coord&#34;, &#34;y_coord&#34;, &#34;z_coord&#34;]]
        df_2 = pd.Series([&#34;0&#34;] * len(df), name=&#34;decide_freeze&#34;)
        df_merged_2 = pd.concat([df_1, df_2, df_3], axis=1)
        df_merged = pd.concat([df_merged_1, df_merged_2], axis=0)
        command_line_9 = df_merged.to_string(header=False, index=False)
        command_line_10 = &#34; &#34;
        command = [
            command_line_1,
            command_line_2,
            command_line_3,
            command_line_4,
            command_line_5,
            command_line_6,
            command_line_7,
            command_line_8,
            command_line_9,
            command_line_10,
        ]
        commands = &#34;\n&#34;.join(command)

        with open(self.host_guest_input, &#34;w&#34;) as f:
            f.write(commands)

    def run_gaussian(self):
        &#34;&#34;&#34;
        Runs the Gaussian QM calculation for the ligand - receptor region 
        locally.
        &#34;&#34;&#34;
        execute_command = (
            &#34;g16&#34;
            + &#34; &lt; &#34;
            + self.host_guest_input
            + &#34; &gt; &#34;
            + self.host_guest_input[:-4]
            + &#34;.log&#34;
        )
        with open(self.gauss_system_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell=True, stdout=f, stderr=sp.STDOUT)

    def get_fchk(self):
        &#34;&#34;&#34;
        Converts the Gaussian checkpoint file (.chk) to a formatted checkpoint
        file (.fchk).
        &#34;&#34;&#34;
        execute_command = (
            &#34;formchk&#34;
            + &#34; &#34;
            + self.host_guest_input[:-4]
            + &#34;.chk&#34;
            + &#34; &#34;
            + self.host_guest_input[:-4]
            + &#34;.fchk&#34;
        )
        with open(self.fchk_system_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell=True, stdout=f, stderr=sp.STDOUT)

    def get_qm_host_guest_charges(self):
        &#34;&#34;&#34;
        Extract charge information for the receptor - ligand QM region.
        &#34;&#34;&#34;
        log_file = self.host_guest_input[:-4] + &#34;.log&#34;
        with open(log_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Fitting point charges to electrostatic potential&#34; in lines[i]:
                to_begin = int(i)
            if &#34; Sum of ESP charges =&#34; in lines[i]:
                to_end = int(i)
        charges = lines[to_begin + 4 : to_end]
        charge_list = []
        for i in range(len(charges)):
            charge_list.append(charges[i].strip().split())
        charge_list_value = []
        atom_list = []
        for i in range(len(charge_list)):
            charge_list_value.append(charge_list[i][2])
            atom_list.append(charge_list[i][1])
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_pdb)
        df_guest = ppdb.df[&#34;ATOM&#34;]
        number_guest_atoms = df_guest.shape[0]
        data_tuples = list(zip(atom_list, charge_list_value))
        df_charge = pd.DataFrame(data_tuples, columns=[&#34;Atom&#34;, &#34;Charge&#34;])
        number_host_atoms = df_charge.shape[0] - number_guest_atoms
        df_charge_guest = df_charge.head(number_guest_atoms)
        df_charge_host = df_charge.tail(number_host_atoms)
        df_charge_only_guest = df_charge_guest[&#34;Charge&#34;]
        df_charge_guest.to_csv(
            self.qm_guest_charge_parameter_file,
            index=False,
            header=False,
            sep=&#34; &#34;,
        )
        df_charge_host.to_csv(
            self.qm_host_charge_parameter_file,
            index=False,
            header=False,
            sep=&#34; &#34;,
        )
        df_charge_only_guest.to_csv(
            self.qm_guest_atom_charge_parameter_file,
            index=False,
            header=False,
            sep=&#34; &#34;,
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.PrepareGaussianHostGuest.get_fchk"><code class="name flex">
<span>def <span class="ident">get_fchk</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the Gaussian checkpoint file (.chk) to a formatted checkpoint
file (.fchk).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fchk(self):
    &#34;&#34;&#34;
    Converts the Gaussian checkpoint file (.chk) to a formatted checkpoint
    file (.fchk).
    &#34;&#34;&#34;
    execute_command = (
        &#34;formchk&#34;
        + &#34; &#34;
        + self.host_guest_input[:-4]
        + &#34;.chk&#34;
        + &#34; &#34;
        + self.host_guest_input[:-4]
        + &#34;.fchk&#34;
    )
    with open(self.fchk_system_out_file, &#34;w+&#34;) as f:
        sp.run(execute_command, shell=True, stdout=f, stderr=sp.STDOUT)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareGaussianHostGuest.get_qm_host_guest_charges"><code class="name flex">
<span>def <span class="ident">get_qm_host_guest_charges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract charge information for the receptor - ligand QM region.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_qm_host_guest_charges(self):
    &#34;&#34;&#34;
    Extract charge information for the receptor - ligand QM region.
    &#34;&#34;&#34;
    log_file = self.host_guest_input[:-4] + &#34;.log&#34;
    with open(log_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Fitting point charges to electrostatic potential&#34; in lines[i]:
            to_begin = int(i)
        if &#34; Sum of ESP charges =&#34; in lines[i]:
            to_end = int(i)
    charges = lines[to_begin + 4 : to_end]
    charge_list = []
    for i in range(len(charges)):
        charge_list.append(charges[i].strip().split())
    charge_list_value = []
    atom_list = []
    for i in range(len(charge_list)):
        charge_list_value.append(charge_list[i][2])
        atom_list.append(charge_list[i][1])
    ppdb = PandasPdb()
    ppdb.read_pdb(self.guest_pdb)
    df_guest = ppdb.df[&#34;ATOM&#34;]
    number_guest_atoms = df_guest.shape[0]
    data_tuples = list(zip(atom_list, charge_list_value))
    df_charge = pd.DataFrame(data_tuples, columns=[&#34;Atom&#34;, &#34;Charge&#34;])
    number_host_atoms = df_charge.shape[0] - number_guest_atoms
    df_charge_guest = df_charge.head(number_guest_atoms)
    df_charge_host = df_charge.tail(number_host_atoms)
    df_charge_only_guest = df_charge_guest[&#34;Charge&#34;]
    df_charge_guest.to_csv(
        self.qm_guest_charge_parameter_file,
        index=False,
        header=False,
        sep=&#34; &#34;,
    )
    df_charge_host.to_csv(
        self.qm_host_charge_parameter_file,
        index=False,
        header=False,
        sep=&#34; &#34;,
    )
    df_charge_only_guest.to_csv(
        self.qm_guest_atom_charge_parameter_file,
        index=False,
        header=False,
        sep=&#34; &#34;,
    )</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareGaussianHostGuest.run_gaussian"><code class="name flex">
<span>def <span class="ident">run_gaussian</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the Gaussian QM calculation for the ligand - receptor region
locally.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_gaussian(self):
    &#34;&#34;&#34;
    Runs the Gaussian QM calculation for the ligand - receptor region 
    locally.
    &#34;&#34;&#34;
    execute_command = (
        &#34;g16&#34;
        + &#34; &lt; &#34;
        + self.host_guest_input
        + &#34; &gt; &#34;
        + self.host_guest_input[:-4]
        + &#34;.log&#34;
    )
    with open(self.gauss_system_out_file, &#34;w+&#34;) as f:
        sp.run(execute_command, shell=True, stdout=f, stderr=sp.STDOUT)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareGaussianHostGuest.write_input"><code class="name flex">
<span>def <span class="ident">write_input</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes a Gaussian input file for the receptor - ligand QM region.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_input(self):
    &#34;&#34;&#34;
    Writes a Gaussian input file for the receptor - ligand QM region. 
    &#34;&#34;&#34;
    command_line_1 = &#34;%Chk = &#34; + self.host_guest_input[:-4] + &#34;.chk&#34;
    command_line_2 = &#34;%Mem = &#34; + str(self.memory) + &#34;GB&#34;
    command_line_3 = &#34;%NProcShared = &#34; + str(self.n_processors)
    command_line_4 = (
        &#34;# &#34;
        + self.functional
        + &#34; &#34;
        + self.basis_set
        + &#34; &#34;
        + self.optimisation
        + &#34; &#34;
        + self.frequency
        + &#34; &#34;
        + self.add_keywords_I
        + &#34; &#34;
        + self.add_keywords_II
        + &#34; &#34;
        + self.add_keywords_III
    )
    command_line_5 = &#34; &#34;
    command_line_6 = &#34;Gaussian Input File&#34;
    command_line_7 = &#34; &#34;
    command_line_8 = str(self.charge) + &#34; &#34; + str(self.multiplicity)
    ppdb = PandasPdb()
    ppdb.read_pdb(self.guest_pdb)
    df = ppdb.df[&#34;ATOM&#34;]
    df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
    df_1.columns = [&#34;atom&#34;]
    df_3 = df[[&#34;x_coord&#34;, &#34;y_coord&#34;, &#34;z_coord&#34;]]
    df_2 = pd.Series([&#34;0&#34;] * len(df), name=&#34;decide_freeze&#34;)
    df_merged_1 = pd.concat([df_1, df_2, df_3], axis=1)
    ppdb = PandasPdb()
    ppdb.read_pdb(self.host_qm_pdb)
    df = ppdb.df[&#34;ATOM&#34;]
    df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
    df_1.columns = [&#34;atom&#34;]
    df_3 = df[[&#34;x_coord&#34;, &#34;y_coord&#34;, &#34;z_coord&#34;]]
    df_2 = pd.Series([&#34;0&#34;] * len(df), name=&#34;decide_freeze&#34;)
    df_merged_2 = pd.concat([df_1, df_2, df_3], axis=1)
    df_merged = pd.concat([df_merged_1, df_merged_2], axis=0)
    command_line_9 = df_merged.to_string(header=False, index=False)
    command_line_10 = &#34; &#34;
    command = [
        command_line_1,
        command_line_2,
        command_line_3,
        command_line_4,
        command_line_5,
        command_line_6,
        command_line_7,
        command_line_8,
        command_line_9,
        command_line_10,
    ]
    commands = &#34;\n&#34;.join(command)

    with open(self.host_guest_input, &#34;w&#34;) as f:
        f.write(commands)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.PrepareQMMM"><code class="flex name class">
<span>class <span class="ident">PrepareQMMM</span></span>
<span>(</span><span>init_pdb, distance, num_residues, guest_resname, cleaned_pdb='system.pdb', guest_init_pdb='guest_init.pdb', host_pdb='host.pdb', guest_pdb='guest_init_II.pdb', guest_xyz='guest_coord.txt', residue_list='residue_list.txt', host_qm_atoms='host_qm.txt', host_mm_atoms='host_mm.txt', host_qm_pdb='host_qm.pdb', host_mm_pdb='host_mm.pdb', qm_pdb='qm.pdb', mm_pdb='mm.pdb', host_mm_region_I_atoms='host_mm_region_I.txt', host_mm_region_II_atoms='host_mm_region_II.txt', host_mm_region_I_pdb='host_mm_region_I.pdb', host_mm_region_II_pdb='host_mm_region_II.pdb')</span>
</code></dt>
<dd>
<div class="desc"><p>A class used to segregate the QM and MM regions.</p>
<p>This class contains methods to remove the solvent, ions and all
entities that are exclusive of receptor and the ligand. It also
defines the Quantum Mechanical (QM) region and the Molecular
Mechanical (MM) region based upon the distance of the ligand
from the receptor and the chosen number of receptor residues. It
is also assumed that the initial PDB file will have the receptor
followed by the ligand.</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>init_pdb</code></strong> :&ensp;<code>str</code></dt>
<dd>Initial PDB file containing the receptor-ligand complex with
solvent, ions, etc.</dd>
<dt><strong><code>cleaned_pdb</code></strong> :&ensp;<code>str</code></dt>
<dd>Formatted PDB file containing only the receptor and the ligand.</dd>
<dt><strong><code>guest_init_pdb</code></strong> :&ensp;<code>str</code></dt>
<dd>A separate ligand PDB file with atom numbers not beginning from 1.</dd>
<dt><strong><code>host_pdb</code></strong> :&ensp;<code>str</code></dt>
<dd>A separate receptor PDB file with atom numbers beginning from 1.</dd>
<dt><strong><code>guest_resname</code></strong> :&ensp;<code>str</code></dt>
<dd>Three letter residue ID for the ligand.</dd>
<dt><strong><code>guest_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Ligand PDB file with atom numbers beginning from 1.</dd>
<dt><strong><code>guest_xyz</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A text file of the XYZ corordinates of the ligand.</dd>
<dt><strong><code>distance</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The distance required to define the QM region of the receptor.
This is the distance between the atoms of the ligand and the
atoms of the receptor.</dd>
<dt><strong><code>residue_list</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A text file of the residue numbers of the receptor within the
proximity (as defined by the distance) from the ligand.</dd>
<dt><strong><code>host_qm_atoms</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A text file of the atom numbers of the receptors in the QM
region.</dd>
<dt><strong><code>host_mm_atoms</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A text file of the atom numbers of the receptors in the MM
region (all atoms except atoms in the QM region)</dd>
<dt><strong><code>host_qm_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>PDB file for the receptor's QM region.</dd>
<dt><strong><code>host_mm_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>PDB file for the receptor's MM region.</dd>
<dt><strong><code>qm_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>PDB file for the QM region (receptor's QM region and the
ligand).</dd>
<dt><strong><code>mm_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>PDB file for the MM region.</dd>
<dt><strong><code>host_mm_region_I_atoms</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A text file of the atom numbers of the receptors in the MM
region preceeding the QM region.</dd>
<dt><strong><code>host_mm_region_II_atoms</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A text file of the atom numbers of the receptors in the MM
region following the QM region.</dd>
<dt><strong><code>host_mm_region_I_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>PDB file of the receptor in the MM region preceeding the
QM region.</dd>
<dt><strong><code>host_mm_region_II_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>PDB file of the receptor in the MM region following the
QM region.</dd>
<dt><strong><code>num_residues</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of residues required in the QM region of the receptor.</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>init_pdb</code></strong> :&ensp;<code>str</code></dt>
<dd>Initial PDB file containing the receptor-ligand complex with
solvent, ions, etc.</dd>
<dt><strong><code>cleaned_pdb</code></strong> :&ensp;<code>str</code></dt>
<dd>Formatted PDB file containing only the receptor and the ligand.</dd>
<dt><strong><code>guest_init_pdb</code></strong> :&ensp;<code>str</code></dt>
<dd>A separate ligand PDB file with atom numbers not beginning from 1.</dd>
<dt><strong><code>host_pdb</code></strong> :&ensp;<code>str</code></dt>
<dd>A separate receptor PDB file with atom numbers beginning from 1.</dd>
<dt><strong><code>guest_resname</code></strong> :&ensp;<code>str</code></dt>
<dd>Three letter residue ID for the ligand.</dd>
<dt><strong><code>guest_pdb</code></strong> :&ensp;<code>str</code></dt>
<dd>Ligand PDB file with atom numbers beginning from 1.</dd>
<dt><strong><code>guest_xyz</code></strong> :&ensp;<code>str</code></dt>
<dd>A text file of the XYZ corordinates of the ligand.</dd>
<dt><strong><code>distance</code></strong> :&ensp;<code>float</code></dt>
<dd>The distance required to define the QM region of the receptor.
This is the distance between the atoms of the ligand and the
atoms of the receptor.</dd>
<dt><strong><code>residue_list</code></strong> :&ensp;<code>str</code></dt>
<dd>A text file of the residue numbers of the receptor within the
proximity (as defined by the distance) from the ligand.</dd>
<dt><strong><code>host_qm_atoms</code></strong> :&ensp;<code>str</code></dt>
<dd>A text file of the atom numbers of the receptors in the QM
region.</dd>
<dt><strong><code>host_mm_atoms</code></strong> :&ensp;<code>str</code></dt>
<dd>A text file of the atom numbers of the receptors in the MM
region (all atoms except atoms in the QM region)</dd>
<dt><strong><code>host_qm_pdb</code></strong> :&ensp;<code>str</code></dt>
<dd>PDB file for the receptor's QM region.</dd>
<dt><strong><code>host_mm_pdb</code></strong> :&ensp;<code>str</code></dt>
<dd>PDB file for the receptor's MM region.</dd>
<dt><strong><code>qm_pdb</code></strong> :&ensp;<code>str</code></dt>
<dd>PDB file for the QM region (receptor's QM region and the
ligand).</dd>
<dt><strong><code>mm_pdb</code></strong> :&ensp;<code>str</code></dt>
<dd>PDB file for the MM region.</dd>
<dt><strong><code>host_mm_region_I_atoms</code></strong> :&ensp;<code>str</code></dt>
<dd>A text file of the atom numbers of the receptors in the MM
region preceeding the QM region.</dd>
<dt><strong><code>host_mm_region_II_atoms</code></strong> :&ensp;<code>str</code></dt>
<dd>A text file of the atom numbers of the receptors in the MM
region following the QM region.</dd>
<dt><strong><code>host_mm_region_I_pdb</code></strong> :&ensp;<code>str</code></dt>
<dd>PDB file of the receptor in the MM region preceeding the
QM region.</dd>
<dt><strong><code>host_mm_region_II_pdb</code></strong> :&ensp;<code>str</code></dt>
<dd>PDB file of the receptor in the MM region following the
QM region.</dd>
<dt><strong><code>num_residues</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of residues required in the QM region of the receptor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrepareQMMM:

    &#34;&#34;&#34;
    A class used to segregate the QM and MM regions.

    This class contains methods to remove the solvent, ions and all
    entities that are exclusive of receptor and the ligand. It also
    defines the Quantum Mechanical (QM) region and the Molecular
    Mechanical (MM) region based upon the distance of the ligand
    from the receptor and the chosen number of receptor residues. It
    is also assumed that the initial PDB file will have the receptor
    followed by the ligand.

    ...

    Attributes
    ----------
    init_pdb : str
        Initial PDB file containing the receptor-ligand complex with
        solvent, ions, etc.

    cleaned_pdb : str
        Formatted PDB file containing only the receptor and the ligand.

    guest_init_pdb : str
        A separate ligand PDB file with atom numbers not beginning from 1.

    host_pdb : str
        A separate receptor PDB file with atom numbers beginning from 1.

    guest_resname : str
        Three letter residue ID for the ligand.

    guest_pdb : str, optional
        Ligand PDB file with atom numbers beginning from 1.
        
    guest_xyz : str, optional
        A text file of the XYZ corordinates of the ligand.
        
    distance : float, optional
        The distance required to define the QM region of the receptor.
        This is the distance between the atoms of the ligand and the
        atoms of the receptor.

    residue_list : str, optional
        A text file of the residue numbers of the receptor within the
        proximity (as defined by the distance) from the ligand.
        
    host_qm_atoms : str, optional
        A text file of the atom numbers of the receptors in the QM
        region.

    host_mm_atoms : str, optional
        A text file of the atom numbers of the receptors in the MM
        region (all atoms except atoms in the QM region)
        
    host_qm_pdb : str, optional
        PDB file for the receptor&#39;s QM region.
        
    host_mm_pdb : str, optional
        PDB file for the receptor&#39;s MM region.
        
    qm_pdb : str, optional
        PDB file for the QM region (receptor&#39;s QM region and the
        ligand).
        
    mm_pdb : str, optional
        PDB file for the MM region.
        
    host_mm_region_I_atoms : str, optional
        A text file of the atom numbers of the receptors in the MM
        region preceeding the QM region.

    host_mm_region_II_atoms : str, optional
        A text file of the atom numbers of the receptors in the MM
        region following the QM region.

    host_mm_region_I_pdb : str, optional
        PDB file of the receptor in the MM region preceeding the
        QM region.

    host_mm_region_II_pdb : str, optional
        PDB file of the receptor in the MM region following the
        QM region.   

    num_residues : int, optional
        Number of residues required in the QM region of the receptor.
    &#34;&#34;&#34;

    def __init__(
        self,
        init_pdb,
        distance,
        num_residues,
        guest_resname,
        cleaned_pdb=&#34;system.pdb&#34;,
        guest_init_pdb=&#34;guest_init.pdb&#34;,
        host_pdb=&#34;host.pdb&#34;,
        guest_pdb=&#34;guest_init_II.pdb&#34;,
        guest_xyz=&#34;guest_coord.txt&#34;,
        residue_list=&#34;residue_list.txt&#34;,
        host_qm_atoms=&#34;host_qm.txt&#34;,
        host_mm_atoms=&#34;host_mm.txt&#34;,
        host_qm_pdb=&#34;host_qm.pdb&#34;,
        host_mm_pdb=&#34;host_mm.pdb&#34;,
        qm_pdb=&#34;qm.pdb&#34;,
        mm_pdb=&#34;mm.pdb&#34;,
        host_mm_region_I_atoms=&#34;host_mm_region_I.txt&#34;,
        host_mm_region_II_atoms=&#34;host_mm_region_II.txt&#34;,
        host_mm_region_I_pdb=&#34;host_mm_region_I.pdb&#34;,
        host_mm_region_II_pdb=&#34;host_mm_region_II.pdb&#34;,
    ):

        &#34;&#34;&#34;
        Parameters
        ----------
        init_pdb : str
            Initial PDB file containing the receptor-ligand complex with
            solvent, ions, etc.

        cleaned_pdb : str
            Formatted PDB file containing only the receptor and the ligand.
            
        guest_init_pdb : str
            A separate ligand PDB file with atom numbers not beginning from 1.           

        host_pdb : str
            A separate receptor PDB file with atom numbers beginning from 1.

        guest_resname : str
            Three letter residue ID for the ligand.

        guest_pdb : str
            Ligand PDB file with atom numbers beginning from 1.           

        guest_xyz : str
            A text file of the XYZ corordinates of the ligand.
            
        distance : float
            The distance required to define the QM region of the receptor.
            This is the distance between the atoms of the ligand and the
            atoms of the receptor.

        residue_list : str
            A text file of the residue numbers of the receptor within the
            proximity (as defined by the distance) from the ligand.
         
        host_qm_atoms : str
            A text file of the atom numbers of the receptors in the QM
            region.          

        host_mm_atoms : str
            A text file of the atom numbers of the receptors in the MM
            region (all atoms except atoms in the QM region)
            
        host_qm_pdb : str
            PDB file for the receptor&#39;s QM region.
            
        host_mm_pdb : str
            PDB file for the receptor&#39;s MM region.

        qm_pdb : str
            PDB file for the QM region (receptor&#39;s QM region and the
            ligand).

        mm_pdb : str
            PDB file for the MM region.

        host_mm_region_I_atoms : str
            A text file of the atom numbers of the receptors in the MM
            region preceeding the QM region.

        host_mm_region_II_atoms : str
            A text file of the atom numbers of the receptors in the MM
            region following the QM region.
            
        host_mm_region_I_pdb : str
            PDB file of the receptor in the MM region preceeding the
            QM region.

        host_mm_region_II_pdb : str
            PDB file of the receptor in the MM region following the
            QM region.

        num_residues : int
            Number of residues required in the QM region of the receptor.

        &#34;&#34;&#34;
        self.init_pdb = init_pdb
        self.distance = distance
        self.num_residues = num_residues
        self.guest_resname = guest_resname
        self.cleaned_pdb = cleaned_pdb
        self.guest_init_pdb = guest_init_pdb
        self.host_pdb = host_pdb
        self.guest_pdb = guest_pdb
        self.guest_xyz = guest_xyz
        self.residue_list = residue_list
        self.host_qm_atoms = host_qm_atoms
        self.host_mm_atoms = host_mm_atoms
        self.host_qm_pdb = host_qm_pdb
        self.host_mm_pdb = host_mm_pdb
        self.qm_pdb = qm_pdb
        self.mm_pdb = mm_pdb
        self.host_mm_region_I_atoms = host_mm_region_I_atoms
        self.host_mm_region_II_atoms = host_mm_region_II_atoms
        self.host_mm_region_I_pdb = host_mm_region_I_pdb
        self.host_mm_region_II_pdb = host_mm_region_II_pdb

    def clean_up(self):
        &#34;&#34;&#34;
        Reads the given PDB file, removes all entities except the
        receptor and ligand and saves a new pdb file.
        &#34;&#34;&#34;
        ions = [
            &#34;Na+&#34;,
            &#34;Cs+&#34;,
            &#34;K+&#34;,
            &#34;Li+&#34;,
            &#34;Rb+&#34;,
            &#34;Cl-&#34;,
            &#34;Br-&#34;,
            &#34;F-&#34;,
            &#34;I-&#34;,
            &#34;Ca2&#34;,
        ]
        intermediate_file_1 = self.cleaned_pdb[:-4] + &#34;_intermediate_1.pdb&#34;
        intermediate_file_2 = self.cleaned_pdb[:-4] + &#34;_intermediate_2.pdb&#34;
        command = (
            &#34;pdb4amber -i &#34;
            + self.init_pdb
            + &#34; -o &#34;
            + intermediate_file_1
            + &#34; --noter --dry&#34;
        )
        os.system(command)
        to_delete = (
            intermediate_file_1[:-4] + &#34;_nonprot.pdb&#34;,
            intermediate_file_1[:-4] + &#34;_renum.txt&#34;,
            intermediate_file_1[:-4] + &#34;_sslink&#34;,
            intermediate_file_1[:-4] + &#34;_water.pdb&#34;,
        )
        os.system(
            &#34;rm -rf &#34;
            + to_delete[0]
            + &#34; &#34;
            + to_delete[1]
            + &#34; &#34;
            + to_delete[2]
            + &#34; &#34;
            + to_delete[3]
        )
        with open(intermediate_file_1) as f1, open(
            intermediate_file_2, &#34;w&#34;
        ) as f2:
            for line in f1:
                if not any(ion in line for ion in ions):
                    f2.write(line)
        with open(intermediate_file_2, &#34;r&#34;) as f1:
            filedata = f1.read()
        filedata = filedata.replace(&#34;HETATM&#34;, &#34;ATOM  &#34;)
        with open(self.cleaned_pdb, &#34;w&#34;) as f2:
            f2.write(filedata)
        command = &#34;rm -rf &#34; + intermediate_file_1 + &#34; &#34; + intermediate_file_2
        os.system(command)

    def create_host_guest(self):
        &#34;&#34;&#34;
        Saves separate receptor and ligand PDB files.
        &#34;&#34;&#34;
        with open(self.cleaned_pdb) as f1, open(self.host_pdb, &#34;w&#34;) as f2:
            for line in f1:
                if not self.guest_resname in line and not &#34;CRYST1&#34; in line:
                    f2.write(line)
        with open(self.cleaned_pdb) as f1, open(
            self.guest_init_pdb, &#34;w&#34;
        ) as f2:
            for line in f1:
                if self.guest_resname in line or &#34;END&#34; in line:
                    f2.write(line)

    def realign_guest(self):
        &#34;&#34;&#34;
        Saves a ligand PDB file with atom numbers beginning from 1.
        &#34;&#34;&#34;
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_init_pdb)
        to_substract = min(ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;]) - 1
        ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] = (
            ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] - to_substract
        )
        intermediate_file_1 = self.guest_pdb[:-4] + &#34;_intermediate_1.pdb&#34;
        intermediate_file_2 = self.guest_pdb[:-4] + &#34;_intermediate_2.pdb&#34;
        ppdb.to_pdb(path=intermediate_file_1)
        command = (
            &#34;pdb4amber -i &#34;
            + intermediate_file_1
            + &#34; -o &#34;
            + intermediate_file_2
        )
        os.system(command)
        to_delete = (
            intermediate_file_2[:-4] + &#34;_nonprot.pdb&#34;,
            intermediate_file_2[:-4] + &#34;_renum.txt&#34;,
            intermediate_file_2[:-4] + &#34;_sslink&#34;,
        )
        os.system(
            &#34;rm -rf &#34; + to_delete[0] + &#34; &#34; + to_delete[1] + &#34; &#34; + to_delete[2]
        )
        with open(intermediate_file_2, &#34;r&#34;) as f1:
            filedata = f1.read()
        filedata = filedata.replace(&#34;HETATM&#34;, &#34;ATOM  &#34;)
        with open(self.guest_pdb, &#34;w&#34;) as f2:
            f2.write(filedata)
        command = &#34;rm -rf &#34; + intermediate_file_1 + &#34; &#34; + intermediate_file_2
        os.system(command)

    def get_guest_coord(self):
        &#34;&#34;&#34;
        Saves a text file of the XYZ corordinates of the ligand.
        &#34;&#34;&#34;
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_pdb)
        xyz = ppdb.df[&#34;ATOM&#34;][[&#34;x_coord&#34;, &#34;y_coord&#34;, &#34;z_coord&#34;]]
        xyz_to_list = xyz.values.tolist()
        np.savetxt(self.guest_xyz, xyz_to_list)

    def get_qm_resids(self):
        &#34;&#34;&#34;
        Saves a text file of the residue numbers of the receptor within the
        proximity (as defined by the distance) from the ligand.
        &#34;&#34;&#34;
        guest_coord_list = np.loadtxt(self.guest_xyz)
        host_atom_list = []
        for i in range(len(guest_coord_list)):
            reference_point = guest_coord_list[i]
            ppdb = PandasPdb()
            ppdb.read_pdb(self.host_pdb)
            distances = ppdb.distance(xyz=reference_point, records=(&#34;ATOM&#34;))
            all_within_distance = ppdb.df[&#34;ATOM&#34;][
                distances &lt; float(self.distance)
            ]
            host_df = all_within_distance[&#34;atom_number&#34;]
            host_list = host_df.values.tolist()
            host_atom_list.append(host_list)
        host_atom_list = list(itertools.chain(*host_atom_list))
        host_atom_list = set(host_atom_list)
        host_atom_list = list(host_atom_list)
        host_atom_list.sort()
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        df = ppdb.df[&#34;ATOM&#34;][[&#34;atom_number&#34;, &#34;residue_number&#34;, &#34;residue_name&#34;]]
        index_list = []
        for i in host_atom_list:
            indices = np.where(df[&#34;atom_number&#34;] == i)
            indices = list(indices)[0]
            indices = list(indices)
            index_list.append(indices)
        index_list = list(itertools.chain.from_iterable(index_list))
        df1 = df.iloc[
            index_list,
        ]
        resid_num = list(df1.residue_number.unique())
        np.savetxt(self.residue_list, resid_num)

    def get_host_qm_mm_atoms(self):
        &#34;&#34;&#34;
        Saves a text file of the atom numbers of the receptors in the QM
        region and MM region separately.
        &#34;&#34;&#34;
        resid_num = np.loadtxt(self.residue_list)
        # approximated_res_list = [int(i) for i in resid_num]
        approximated_res_list = []
        for i in range(
            int(statistics.median(resid_num))
            - int(int(self.num_residues) / 2),
            int(statistics.median(resid_num))
            + int(int(self.num_residues) / 2),
        ):
            approximated_res_list.append(i)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        df = ppdb.df[&#34;ATOM&#34;][[&#34;atom_number&#34;, &#34;residue_number&#34;, &#34;residue_name&#34;]]
        host_index_nested_list = []
        for i in approximated_res_list:
            indices = np.where(df[&#34;residue_number&#34;] == i)
            indices = list(indices)[0]
            indices = list(indices)
            host_index_nested_list.append(indices)
        host_index_list = list(
            itertools.chain.from_iterable(host_index_nested_list)
        )
        df_atom = df.iloc[host_index_list]
        df_atom_number = df_atom[&#34;atom_number&#34;]
        host_atom_list = df_atom_number.values.tolist()
        selected_atoms = []
        selected_atoms.extend(host_atom_list)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        len_atoms = []
        for i in range(len(ppdb.df[&#34;ATOM&#34;])):
            len_atoms.append(i + 1)
        non_selected_atoms = list(set(len_atoms).difference(selected_atoms))
        if len(non_selected_atoms) + len(selected_atoms) == len(len_atoms):
            print(
                &#34;Sum of the atoms in the selected and non-selected region \
                 equals the length of list of total atoms&#34;
            )
        else:
            print(&#34;Error&#34;)
        np.savetxt(self.host_qm_atoms, selected_atoms)
        np.savetxt(self.host_mm_atoms, non_selected_atoms)

    def save_host_pdbs(self):
        &#34;&#34;&#34;
        Saves a PDB file for the receptor&#39;s QM region and MM
        region separately.
        &#34;&#34;&#34;
        selected_atoms = np.loadtxt(self.host_qm_atoms)
        selected_atoms = [int(i) for i in selected_atoms]
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        for i in selected_atoms:
            ppdb.df[&#34;ATOM&#34;] = ppdb.df[&#34;ATOM&#34;][
                ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] != i
            ]
        ppdb.to_pdb(
            path=self.host_mm_pdb, records=None, gz=False, append_newline=True
        )
        non_selected_atoms = np.loadtxt(self.host_mm_atoms)
        non_selected_atoms = [int(i) for i in non_selected_atoms]
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        for i in non_selected_atoms:
            ppdb.df[&#34;ATOM&#34;] = ppdb.df[&#34;ATOM&#34;][
                ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] != i
            ]
        ppdb.to_pdb(
            path=self.host_qm_pdb, records=None, gz=False, append_newline=True
        )

    def get_host_mm_region_atoms(self):
        &#34;&#34;&#34;
        Saves a text file for the atoms of the receptor&#39;s MM region
        preceding the QM region and saves another text file for the
        atoms of the receptor&#39;s MM region folllowing the QM region.
        &#34;&#34;&#34;
        resid_num = np.loadtxt(self.residue_list)
        approximated_res_list = []
        for i in range(
            int(statistics.median(resid_num))
            - int(int(self.num_residues) / 2),
            int(statistics.median(resid_num))
            + int(int(self.num_residues) / 2),
        ):
            approximated_res_list.append(i)
        # print(approximated_res_list)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        df = ppdb.df[&#34;ATOM&#34;][[&#34;residue_number&#34;]]
        res_list = list(set(df[&#34;residue_number&#34;].to_list()))
        res_mm_list = list(set(res_list).difference(approximated_res_list))
        # print(res_mm_list)
        res_mm_region_I_list = []
        for i in res_mm_list:
            for j in approximated_res_list:
                if i &lt; j:
                    res_mm_region_I_list.append(i)
        res_mm_region_I_list = list(set(res_mm_region_I_list))
        # print(res_mm_region_I_list)
        res_mm_region_II_list = list(
            set(res_mm_list).difference(res_mm_region_I_list)
        )
        # print(res_mm_region_II_list)
        ppdb.read_pdb(self.host_mm_pdb)
        df = ppdb.df[&#34;ATOM&#34;][[&#34;atom_number&#34;, &#34;residue_number&#34;, &#34;residue_name&#34;]]
        mm_region_I_index_nested_list = []
        for i in res_mm_region_I_list:
            indices = np.where(df[&#34;residue_number&#34;] == i)
            indices = list(indices)[0]
            indices = list(indices)
            mm_region_I_index_nested_list.append(indices)
        mm_region_I_index_list = list(
            itertools.chain.from_iterable(mm_region_I_index_nested_list)
        )
        df_atom = df.iloc[mm_region_I_index_list]
        df_atom_number = df_atom[&#34;atom_number&#34;]
        mm_region_I_atom_list = df_atom_number.values.tolist()
        mm_region_I_atoms = []
        mm_region_I_atoms.extend(mm_region_I_atom_list)
        mm_region_II_index_nested_list = []
        for i in res_mm_region_II_list:
            indices = np.where(df[&#34;residue_number&#34;] == i)
            indices = list(indices)[0]
            indices = list(indices)
            mm_region_II_index_nested_list.append(indices)
        mm_region_II_index_list = list(
            itertools.chain.from_iterable(mm_region_II_index_nested_list)
        )
        df_atom = df.iloc[mm_region_II_index_list]
        df_atom_number = df_atom[&#34;atom_number&#34;]
        mm_region_II_atom_list = df_atom_number.values.tolist()
        mm_region_II_atoms = []
        mm_region_II_atoms.extend(mm_region_II_atom_list)
        ppdb.read_pdb(self.host_mm_pdb)
        len_atoms = []
        for i in range(len(ppdb.df[&#34;ATOM&#34;])):
            len_atoms.append(i + 1)
        if len(mm_region_I_atoms) + len(mm_region_II_atoms) == len(len_atoms):
            print(
                &#34;Sum of the MM region I atoms and  MM region II atoms equals \
                 the length of list of total MM atoms&#34;
            )
        else:
            print(&#34;Error&#34;)
        np.savetxt(self.host_mm_region_I_atoms, mm_region_I_atoms)
        np.savetxt(self.host_mm_region_II_atoms, mm_region_II_atoms)

    def save_host_mm_regions_pdbs(self):
        &#34;&#34;&#34;
        Saves a PDB file for the receptor&#39;s MM region preceding
        the QM region and saves another PDB file for the receptor&#39;s
        MM region folllowing the QM region.
        &#34;&#34;&#34;
        mm_region_I_atoms = np.loadtxt(self.host_mm_region_I_atoms)
        mm_region_I_atoms = [int(i) for i in mm_region_I_atoms]
        mm_region_II_atoms = np.loadtxt(self.host_mm_region_II_atoms)
        mm_region_II_atoms = [int(i) for i in mm_region_II_atoms]
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_mm_pdb)
        for i in mm_region_II_atoms:
            ppdb.df[&#34;ATOM&#34;] = ppdb.df[&#34;ATOM&#34;][
                ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] != i
            ]
        ppdb.to_pdb(
            path=self.host_mm_region_I_pdb,
            records=None,
            gz=False,
            append_newline=True,
        )
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_mm_pdb)
        for i in mm_region_I_atoms:
            ppdb.df[&#34;ATOM&#34;] = ppdb.df[&#34;ATOM&#34;][
                ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] != i
            ]
        ppdb.to_pdb(
            path=self.host_mm_region_II_pdb,
            records=None,
            gz=False,
            append_newline=True,
        )

    def get_qm_mm_regions(self):
        &#34;&#34;&#34;
        Saves separate PDB files for the QM and MM regions.
        QM regions comprise the QM region of the receptor
        and the entire ligand where the MM region comprise
        the non-selected QM regions of the receptor.
        &#34;&#34;&#34;
        with open(self.host_qm_pdb) as f1, open(self.qm_pdb, &#34;w&#34;) as f2:
            for line in f1:
                if &#34;ATOM&#34; in line:
                    f2.write(line)
        with open(self.guest_pdb) as f1, open(self.qm_pdb, &#34;a&#34;) as f2:
            for line in f1:
                if &#34;ATOM&#34; in line:
                    f2.write(line)
        with open(self.qm_pdb, &#34;a&#34;) as f:
            f.write(&#34;END&#34;)
        with open(self.host_mm_pdb) as f1, open(self.mm_pdb, &#34;w&#34;) as f2:
            for line in f1:
                if &#34;ATOM&#34; in line:
                    f2.write(line)
        with open(self.mm_pdb, &#34;a&#34;) as f:
            f.write(&#34;END&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.PrepareQMMM.clean_up"><code class="name flex">
<span>def <span class="ident">clean_up</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the given PDB file, removes all entities except the
receptor and ligand and saves a new pdb file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_up(self):
    &#34;&#34;&#34;
    Reads the given PDB file, removes all entities except the
    receptor and ligand and saves a new pdb file.
    &#34;&#34;&#34;
    ions = [
        &#34;Na+&#34;,
        &#34;Cs+&#34;,
        &#34;K+&#34;,
        &#34;Li+&#34;,
        &#34;Rb+&#34;,
        &#34;Cl-&#34;,
        &#34;Br-&#34;,
        &#34;F-&#34;,
        &#34;I-&#34;,
        &#34;Ca2&#34;,
    ]
    intermediate_file_1 = self.cleaned_pdb[:-4] + &#34;_intermediate_1.pdb&#34;
    intermediate_file_2 = self.cleaned_pdb[:-4] + &#34;_intermediate_2.pdb&#34;
    command = (
        &#34;pdb4amber -i &#34;
        + self.init_pdb
        + &#34; -o &#34;
        + intermediate_file_1
        + &#34; --noter --dry&#34;
    )
    os.system(command)
    to_delete = (
        intermediate_file_1[:-4] + &#34;_nonprot.pdb&#34;,
        intermediate_file_1[:-4] + &#34;_renum.txt&#34;,
        intermediate_file_1[:-4] + &#34;_sslink&#34;,
        intermediate_file_1[:-4] + &#34;_water.pdb&#34;,
    )
    os.system(
        &#34;rm -rf &#34;
        + to_delete[0]
        + &#34; &#34;
        + to_delete[1]
        + &#34; &#34;
        + to_delete[2]
        + &#34; &#34;
        + to_delete[3]
    )
    with open(intermediate_file_1) as f1, open(
        intermediate_file_2, &#34;w&#34;
    ) as f2:
        for line in f1:
            if not any(ion in line for ion in ions):
                f2.write(line)
    with open(intermediate_file_2, &#34;r&#34;) as f1:
        filedata = f1.read()
    filedata = filedata.replace(&#34;HETATM&#34;, &#34;ATOM  &#34;)
    with open(self.cleaned_pdb, &#34;w&#34;) as f2:
        f2.write(filedata)
    command = &#34;rm -rf &#34; + intermediate_file_1 + &#34; &#34; + intermediate_file_2
    os.system(command)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareQMMM.create_host_guest"><code class="name flex">
<span>def <span class="ident">create_host_guest</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves separate receptor and ligand PDB files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_host_guest(self):
    &#34;&#34;&#34;
    Saves separate receptor and ligand PDB files.
    &#34;&#34;&#34;
    with open(self.cleaned_pdb) as f1, open(self.host_pdb, &#34;w&#34;) as f2:
        for line in f1:
            if not self.guest_resname in line and not &#34;CRYST1&#34; in line:
                f2.write(line)
    with open(self.cleaned_pdb) as f1, open(
        self.guest_init_pdb, &#34;w&#34;
    ) as f2:
        for line in f1:
            if self.guest_resname in line or &#34;END&#34; in line:
                f2.write(line)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareQMMM.get_guest_coord"><code class="name flex">
<span>def <span class="ident">get_guest_coord</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a text file of the XYZ corordinates of the ligand.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_guest_coord(self):
    &#34;&#34;&#34;
    Saves a text file of the XYZ corordinates of the ligand.
    &#34;&#34;&#34;
    ppdb = PandasPdb()
    ppdb.read_pdb(self.guest_pdb)
    xyz = ppdb.df[&#34;ATOM&#34;][[&#34;x_coord&#34;, &#34;y_coord&#34;, &#34;z_coord&#34;]]
    xyz_to_list = xyz.values.tolist()
    np.savetxt(self.guest_xyz, xyz_to_list)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareQMMM.get_host_mm_region_atoms"><code class="name flex">
<span>def <span class="ident">get_host_mm_region_atoms</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a text file for the atoms of the receptor's MM region
preceding the QM region and saves another text file for the
atoms of the receptor's MM region folllowing the QM region.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_host_mm_region_atoms(self):
    &#34;&#34;&#34;
    Saves a text file for the atoms of the receptor&#39;s MM region
    preceding the QM region and saves another text file for the
    atoms of the receptor&#39;s MM region folllowing the QM region.
    &#34;&#34;&#34;
    resid_num = np.loadtxt(self.residue_list)
    approximated_res_list = []
    for i in range(
        int(statistics.median(resid_num))
        - int(int(self.num_residues) / 2),
        int(statistics.median(resid_num))
        + int(int(self.num_residues) / 2),
    ):
        approximated_res_list.append(i)
    # print(approximated_res_list)
    ppdb = PandasPdb()
    ppdb.read_pdb(self.host_pdb)
    df = ppdb.df[&#34;ATOM&#34;][[&#34;residue_number&#34;]]
    res_list = list(set(df[&#34;residue_number&#34;].to_list()))
    res_mm_list = list(set(res_list).difference(approximated_res_list))
    # print(res_mm_list)
    res_mm_region_I_list = []
    for i in res_mm_list:
        for j in approximated_res_list:
            if i &lt; j:
                res_mm_region_I_list.append(i)
    res_mm_region_I_list = list(set(res_mm_region_I_list))
    # print(res_mm_region_I_list)
    res_mm_region_II_list = list(
        set(res_mm_list).difference(res_mm_region_I_list)
    )
    # print(res_mm_region_II_list)
    ppdb.read_pdb(self.host_mm_pdb)
    df = ppdb.df[&#34;ATOM&#34;][[&#34;atom_number&#34;, &#34;residue_number&#34;, &#34;residue_name&#34;]]
    mm_region_I_index_nested_list = []
    for i in res_mm_region_I_list:
        indices = np.where(df[&#34;residue_number&#34;] == i)
        indices = list(indices)[0]
        indices = list(indices)
        mm_region_I_index_nested_list.append(indices)
    mm_region_I_index_list = list(
        itertools.chain.from_iterable(mm_region_I_index_nested_list)
    )
    df_atom = df.iloc[mm_region_I_index_list]
    df_atom_number = df_atom[&#34;atom_number&#34;]
    mm_region_I_atom_list = df_atom_number.values.tolist()
    mm_region_I_atoms = []
    mm_region_I_atoms.extend(mm_region_I_atom_list)
    mm_region_II_index_nested_list = []
    for i in res_mm_region_II_list:
        indices = np.where(df[&#34;residue_number&#34;] == i)
        indices = list(indices)[0]
        indices = list(indices)
        mm_region_II_index_nested_list.append(indices)
    mm_region_II_index_list = list(
        itertools.chain.from_iterable(mm_region_II_index_nested_list)
    )
    df_atom = df.iloc[mm_region_II_index_list]
    df_atom_number = df_atom[&#34;atom_number&#34;]
    mm_region_II_atom_list = df_atom_number.values.tolist()
    mm_region_II_atoms = []
    mm_region_II_atoms.extend(mm_region_II_atom_list)
    ppdb.read_pdb(self.host_mm_pdb)
    len_atoms = []
    for i in range(len(ppdb.df[&#34;ATOM&#34;])):
        len_atoms.append(i + 1)
    if len(mm_region_I_atoms) + len(mm_region_II_atoms) == len(len_atoms):
        print(
            &#34;Sum of the MM region I atoms and  MM region II atoms equals \
             the length of list of total MM atoms&#34;
        )
    else:
        print(&#34;Error&#34;)
    np.savetxt(self.host_mm_region_I_atoms, mm_region_I_atoms)
    np.savetxt(self.host_mm_region_II_atoms, mm_region_II_atoms)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareQMMM.get_host_qm_mm_atoms"><code class="name flex">
<span>def <span class="ident">get_host_qm_mm_atoms</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a text file of the atom numbers of the receptors in the QM
region and MM region separately.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_host_qm_mm_atoms(self):
    &#34;&#34;&#34;
    Saves a text file of the atom numbers of the receptors in the QM
    region and MM region separately.
    &#34;&#34;&#34;
    resid_num = np.loadtxt(self.residue_list)
    # approximated_res_list = [int(i) for i in resid_num]
    approximated_res_list = []
    for i in range(
        int(statistics.median(resid_num))
        - int(int(self.num_residues) / 2),
        int(statistics.median(resid_num))
        + int(int(self.num_residues) / 2),
    ):
        approximated_res_list.append(i)
    ppdb = PandasPdb()
    ppdb.read_pdb(self.host_pdb)
    df = ppdb.df[&#34;ATOM&#34;][[&#34;atom_number&#34;, &#34;residue_number&#34;, &#34;residue_name&#34;]]
    host_index_nested_list = []
    for i in approximated_res_list:
        indices = np.where(df[&#34;residue_number&#34;] == i)
        indices = list(indices)[0]
        indices = list(indices)
        host_index_nested_list.append(indices)
    host_index_list = list(
        itertools.chain.from_iterable(host_index_nested_list)
    )
    df_atom = df.iloc[host_index_list]
    df_atom_number = df_atom[&#34;atom_number&#34;]
    host_atom_list = df_atom_number.values.tolist()
    selected_atoms = []
    selected_atoms.extend(host_atom_list)
    ppdb = PandasPdb()
    ppdb.read_pdb(self.host_pdb)
    len_atoms = []
    for i in range(len(ppdb.df[&#34;ATOM&#34;])):
        len_atoms.append(i + 1)
    non_selected_atoms = list(set(len_atoms).difference(selected_atoms))
    if len(non_selected_atoms) + len(selected_atoms) == len(len_atoms):
        print(
            &#34;Sum of the atoms in the selected and non-selected region \
             equals the length of list of total atoms&#34;
        )
    else:
        print(&#34;Error&#34;)
    np.savetxt(self.host_qm_atoms, selected_atoms)
    np.savetxt(self.host_mm_atoms, non_selected_atoms)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareQMMM.get_qm_mm_regions"><code class="name flex">
<span>def <span class="ident">get_qm_mm_regions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves separate PDB files for the QM and MM regions.
QM regions comprise the QM region of the receptor
and the entire ligand where the MM region comprise
the non-selected QM regions of the receptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_qm_mm_regions(self):
    &#34;&#34;&#34;
    Saves separate PDB files for the QM and MM regions.
    QM regions comprise the QM region of the receptor
    and the entire ligand where the MM region comprise
    the non-selected QM regions of the receptor.
    &#34;&#34;&#34;
    with open(self.host_qm_pdb) as f1, open(self.qm_pdb, &#34;w&#34;) as f2:
        for line in f1:
            if &#34;ATOM&#34; in line:
                f2.write(line)
    with open(self.guest_pdb) as f1, open(self.qm_pdb, &#34;a&#34;) as f2:
        for line in f1:
            if &#34;ATOM&#34; in line:
                f2.write(line)
    with open(self.qm_pdb, &#34;a&#34;) as f:
        f.write(&#34;END&#34;)
    with open(self.host_mm_pdb) as f1, open(self.mm_pdb, &#34;w&#34;) as f2:
        for line in f1:
            if &#34;ATOM&#34; in line:
                f2.write(line)
    with open(self.mm_pdb, &#34;a&#34;) as f:
        f.write(&#34;END&#34;)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareQMMM.get_qm_resids"><code class="name flex">
<span>def <span class="ident">get_qm_resids</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a text file of the residue numbers of the receptor within the
proximity (as defined by the distance) from the ligand.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_qm_resids(self):
    &#34;&#34;&#34;
    Saves a text file of the residue numbers of the receptor within the
    proximity (as defined by the distance) from the ligand.
    &#34;&#34;&#34;
    guest_coord_list = np.loadtxt(self.guest_xyz)
    host_atom_list = []
    for i in range(len(guest_coord_list)):
        reference_point = guest_coord_list[i]
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        distances = ppdb.distance(xyz=reference_point, records=(&#34;ATOM&#34;))
        all_within_distance = ppdb.df[&#34;ATOM&#34;][
            distances &lt; float(self.distance)
        ]
        host_df = all_within_distance[&#34;atom_number&#34;]
        host_list = host_df.values.tolist()
        host_atom_list.append(host_list)
    host_atom_list = list(itertools.chain(*host_atom_list))
    host_atom_list = set(host_atom_list)
    host_atom_list = list(host_atom_list)
    host_atom_list.sort()
    ppdb = PandasPdb()
    ppdb.read_pdb(self.host_pdb)
    df = ppdb.df[&#34;ATOM&#34;][[&#34;atom_number&#34;, &#34;residue_number&#34;, &#34;residue_name&#34;]]
    index_list = []
    for i in host_atom_list:
        indices = np.where(df[&#34;atom_number&#34;] == i)
        indices = list(indices)[0]
        indices = list(indices)
        index_list.append(indices)
    index_list = list(itertools.chain.from_iterable(index_list))
    df1 = df.iloc[
        index_list,
    ]
    resid_num = list(df1.residue_number.unique())
    np.savetxt(self.residue_list, resid_num)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareQMMM.realign_guest"><code class="name flex">
<span>def <span class="ident">realign_guest</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a ligand PDB file with atom numbers beginning from 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def realign_guest(self):
    &#34;&#34;&#34;
    Saves a ligand PDB file with atom numbers beginning from 1.
    &#34;&#34;&#34;
    ppdb = PandasPdb()
    ppdb.read_pdb(self.guest_init_pdb)
    to_substract = min(ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;]) - 1
    ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] = (
        ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] - to_substract
    )
    intermediate_file_1 = self.guest_pdb[:-4] + &#34;_intermediate_1.pdb&#34;
    intermediate_file_2 = self.guest_pdb[:-4] + &#34;_intermediate_2.pdb&#34;
    ppdb.to_pdb(path=intermediate_file_1)
    command = (
        &#34;pdb4amber -i &#34;
        + intermediate_file_1
        + &#34; -o &#34;
        + intermediate_file_2
    )
    os.system(command)
    to_delete = (
        intermediate_file_2[:-4] + &#34;_nonprot.pdb&#34;,
        intermediate_file_2[:-4] + &#34;_renum.txt&#34;,
        intermediate_file_2[:-4] + &#34;_sslink&#34;,
    )
    os.system(
        &#34;rm -rf &#34; + to_delete[0] + &#34; &#34; + to_delete[1] + &#34; &#34; + to_delete[2]
    )
    with open(intermediate_file_2, &#34;r&#34;) as f1:
        filedata = f1.read()
    filedata = filedata.replace(&#34;HETATM&#34;, &#34;ATOM  &#34;)
    with open(self.guest_pdb, &#34;w&#34;) as f2:
        f2.write(filedata)
    command = &#34;rm -rf &#34; + intermediate_file_1 + &#34; &#34; + intermediate_file_2
    os.system(command)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareQMMM.save_host_mm_regions_pdbs"><code class="name flex">
<span>def <span class="ident">save_host_mm_regions_pdbs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a PDB file for the receptor's MM region preceding
the QM region and saves another PDB file for the receptor's
MM region folllowing the QM region.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_host_mm_regions_pdbs(self):
    &#34;&#34;&#34;
    Saves a PDB file for the receptor&#39;s MM region preceding
    the QM region and saves another PDB file for the receptor&#39;s
    MM region folllowing the QM region.
    &#34;&#34;&#34;
    mm_region_I_atoms = np.loadtxt(self.host_mm_region_I_atoms)
    mm_region_I_atoms = [int(i) for i in mm_region_I_atoms]
    mm_region_II_atoms = np.loadtxt(self.host_mm_region_II_atoms)
    mm_region_II_atoms = [int(i) for i in mm_region_II_atoms]
    ppdb = PandasPdb()
    ppdb.read_pdb(self.host_mm_pdb)
    for i in mm_region_II_atoms:
        ppdb.df[&#34;ATOM&#34;] = ppdb.df[&#34;ATOM&#34;][
            ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] != i
        ]
    ppdb.to_pdb(
        path=self.host_mm_region_I_pdb,
        records=None,
        gz=False,
        append_newline=True,
    )
    ppdb = PandasPdb()
    ppdb.read_pdb(self.host_mm_pdb)
    for i in mm_region_I_atoms:
        ppdb.df[&#34;ATOM&#34;] = ppdb.df[&#34;ATOM&#34;][
            ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] != i
        ]
    ppdb.to_pdb(
        path=self.host_mm_region_II_pdb,
        records=None,
        gz=False,
        append_newline=True,
    )</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareQMMM.save_host_pdbs"><code class="name flex">
<span>def <span class="ident">save_host_pdbs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a PDB file for the receptor's QM region and MM
region separately.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_host_pdbs(self):
    &#34;&#34;&#34;
    Saves a PDB file for the receptor&#39;s QM region and MM
    region separately.
    &#34;&#34;&#34;
    selected_atoms = np.loadtxt(self.host_qm_atoms)
    selected_atoms = [int(i) for i in selected_atoms]
    ppdb = PandasPdb()
    ppdb.read_pdb(self.host_pdb)
    for i in selected_atoms:
        ppdb.df[&#34;ATOM&#34;] = ppdb.df[&#34;ATOM&#34;][
            ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] != i
        ]
    ppdb.to_pdb(
        path=self.host_mm_pdb, records=None, gz=False, append_newline=True
    )
    non_selected_atoms = np.loadtxt(self.host_mm_atoms)
    non_selected_atoms = [int(i) for i in non_selected_atoms]
    ppdb = PandasPdb()
    ppdb.read_pdb(self.host_pdb)
    for i in non_selected_atoms:
        ppdb.df[&#34;ATOM&#34;] = ppdb.df[&#34;ATOM&#34;][
            ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] != i
        ]
    ppdb.to_pdb(
        path=self.host_qm_pdb, records=None, gz=False, append_newline=True
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.RunOpenMMSims"><code class="flex name class">
<span>class <span class="ident">RunOpenMMSims</span></span>
<span>(</span><span>system_prmtop, system_inpcrd, system_pdb, system_output='sim_output.pdb', sim_steps=1000)</span>
</code></dt>
<dd>
<div class="desc"><p>A class used to run the OpenMM simulation on any specified system.</p>
<p>This class contains methods to run a MD simulation to confirm the
proper structure of the reparameterized forcefield files. </p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>system_prmtop</code></strong> :&ensp;<code>str</code></dt>
<dd>Topology file of the system (receptor, ligand or
receptor - ligand complex)</dd>
<dt><strong><code>system_inpcrd</code></strong> :&ensp;<code>str</code></dt>
<dd>Coordinate file of the system (receptor, ligand or
receptor - ligand complex)</dd>
<dt><strong><code>system_pdb</code></strong> :&ensp;<code>str</code></dt>
<dd>PDB file of the system to run MD simulation (receptor,
ligand or receptor - ligand complex).</dd>
<dt><strong><code>sim_output</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>PDB file containing the trajectory coordinates for the OpenMM
simulation.</dd>
<dt><strong><code>sim_steps</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Number of steps in the OpenMM MD simulation.</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>system_prmtop</code></strong> :&ensp;<code>str</code></dt>
<dd>Topology file of the system (receptor, ligand or
receptor - ligand complex)</dd>
<dt><strong><code>system_inpcrd</code></strong> :&ensp;<code>str</code></dt>
<dd>Coordinate file of the system (receptor, ligand or
receptor - ligand complex)</dd>
<dt><strong><code>system_pdb</code></strong> :&ensp;<code>str</code></dt>
<dd>PDB file of the system to run MD simulation (receptor,
ligand or receptor - ligand complex).</dd>
<dt><strong><code>sim_output</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>PDB file containing the trajectory coordinates for the OpenMM
simulation.</dd>
<dt><strong><code>sim_steps</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Number of steps in the OpenMM MD simulation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RunOpenMMSims:
    &#34;&#34;&#34;
    A class used to run the OpenMM simulation on any specified system.

    This class contains methods to run a MD simulation to confirm the 
    proper structure of the reparameterized forcefield files. 


    ...

    Attributes
    ----------
    system_prmtop : str
        Topology file of the system (receptor, ligand or 
        receptor - ligand complex)

    system_inpcrd : str
        Coordinate file of the system (receptor, ligand or 
        receptor - ligand complex)

    system_pdb: str
        PDB file of the system to run MD simulation (receptor, 
        ligand or receptor - ligand complex).

    sim_output: str, optional
        PDB file containing the trajectory coordinates for the OpenMM
        simulation. 

    sim_steps: str, optional
        Number of steps in the OpenMM MD simulation.

    &#34;&#34;&#34;

    def __init__(
        self,
        system_prmtop,
        system_inpcrd,
        system_pdb,
        system_output=&#34;sim_output.pdb&#34;,
        sim_steps=1000,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        system_prmtop : str
            Topology file of the system (receptor, ligand or 
            receptor - ligand complex)

        system_inpcrd : str
            Coordinate file of the system (receptor, ligand or 
            receptor - ligand complex)

        system_pdb: str
            PDB file of the system to run MD simulation (receptor, 
            ligand or receptor - ligand complex).

        sim_output: str, optional
            PDB file containing the trajectory coordinates for the OpenMM
            simulation. 

        sim_steps: str, optional
            Number of steps in the OpenMM MD simulation.
        &#34;&#34;&#34;
        self.system_prmtop = system_prmtop
        self.system_inpcrd = system_inpcrd
        self.system_pdb = system_pdb
        self.system_output = system_output
        self.sim_steps = sim_steps

    def run_openmm_prmtop_inpcrd(self):
        &#34;&#34;&#34;
        Run a OpenMM MD simulation with prmtop and inpcrd file&#34;
        &#34;&#34;&#34;
        print(
            &#34;Running OpenMM simulation for &#34;
            + self.system_prmtop
            + &#34; and &#34;
            + self.system_inpcrd
        )
        prmtop = simtk.openmm.app.AmberPrmtopFile(self.system_prmtop)
        inpcrd = simtk.openmm.app.AmberInpcrdFile(self.system_inpcrd)
        system = prmtop.createSystem()
        integrator = simtk.openmm.LangevinIntegrator(
            300 * simtk.unit.kelvin,
            1 / simtk.unit.picosecond,
            0.002 * simtk.unit.picoseconds,
        )
        simulation = simtk.openmm.app.Simulation(
            prmtop.topology, system, integrator
        )
        simulation.context.setPositions(inpcrd.positions)
        if inpcrd.boxVectors is not None:
            simulation.context.setPeriodicBoxVectors(*inpcrd.boxVectors)
        simulation.minimizeEnergy()
        simulation.reporters.append(
            simtk.openmm.app.PDBReporter(
                self.system_output, self.sim_steps / 10
            )
        )
        simulation.reporters.append(
            simtk.openmm.app.StateDataReporter(
                stdout,
                reportInterval=int(self.sim_steps / 10),
                step=True,
                potentialEnergy=True,
                temperature=True,
            )
        )
        simulation.step(self.sim_steps)
        command = &#34;rm -rf &#34; + self.system_output
        os.system(command)

    def run_openmm_prmtop_pdb(self):
        &#34;&#34;&#34;
        Run a OpenMM MD simulation with prmtop and PDB file&#34;
        &#34;&#34;&#34;
        print(
            &#34;Running OpenMM simulation for &#34;
            + self.system_prmtop
            + &#34; and &#34;
            + self.system_pdb
        )
        pdb = simtk.openmm.app.PDBFile(self.system_pdb)
        prmtop = simtk.openmm.app.AmberPrmtopFile(self.system_prmtop)
        system = prmtop.createSystem()
        integrator = simtk.openmm.LangevinIntegrator(
            300 * simtk.unit.kelvin,
            1 / simtk.unit.picosecond,
            0.002 * simtk.unit.picoseconds,
        )
        simulation = simtk.openmm.app.Simulation(
            prmtop.topology, system, integrator
        )
        simulation.context.setPositions(pdb.positions)
        simulation.minimizeEnergy()
        simulation.reporters.append(
            simtk.openmm.app.PDBReporter(
                self.system_output, self.sim_steps / 10
            )
        )
        simulation.reporters.append(
            simtk.openmm.app.StateDataReporter(
                stdout,
                reportInterval=int(self.sim_steps / 10),
                step=True,
                potentialEnergy=True,
                temperature=True,
            )
        )
        simulation.step(self.sim_steps)
        command = &#34;rm -rf &#34; + self.system_output
        os.system(command)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.RunOpenMMSims.run_openmm_prmtop_inpcrd"><code class="name flex">
<span>def <span class="ident">run_openmm_prmtop_inpcrd</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run a OpenMM MD simulation with prmtop and inpcrd file"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_openmm_prmtop_inpcrd(self):
    &#34;&#34;&#34;
    Run a OpenMM MD simulation with prmtop and inpcrd file&#34;
    &#34;&#34;&#34;
    print(
        &#34;Running OpenMM simulation for &#34;
        + self.system_prmtop
        + &#34; and &#34;
        + self.system_inpcrd
    )
    prmtop = simtk.openmm.app.AmberPrmtopFile(self.system_prmtop)
    inpcrd = simtk.openmm.app.AmberInpcrdFile(self.system_inpcrd)
    system = prmtop.createSystem()
    integrator = simtk.openmm.LangevinIntegrator(
        300 * simtk.unit.kelvin,
        1 / simtk.unit.picosecond,
        0.002 * simtk.unit.picoseconds,
    )
    simulation = simtk.openmm.app.Simulation(
        prmtop.topology, system, integrator
    )
    simulation.context.setPositions(inpcrd.positions)
    if inpcrd.boxVectors is not None:
        simulation.context.setPeriodicBoxVectors(*inpcrd.boxVectors)
    simulation.minimizeEnergy()
    simulation.reporters.append(
        simtk.openmm.app.PDBReporter(
            self.system_output, self.sim_steps / 10
        )
    )
    simulation.reporters.append(
        simtk.openmm.app.StateDataReporter(
            stdout,
            reportInterval=int(self.sim_steps / 10),
            step=True,
            potentialEnergy=True,
            temperature=True,
        )
    )
    simulation.step(self.sim_steps)
    command = &#34;rm -rf &#34; + self.system_output
    os.system(command)</code></pre>
</details>
</dd>
<dt id="parameterize.RunOpenMMSims.run_openmm_prmtop_pdb"><code class="name flex">
<span>def <span class="ident">run_openmm_prmtop_pdb</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run a OpenMM MD simulation with prmtop and PDB file"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_openmm_prmtop_pdb(self):
    &#34;&#34;&#34;
    Run a OpenMM MD simulation with prmtop and PDB file&#34;
    &#34;&#34;&#34;
    print(
        &#34;Running OpenMM simulation for &#34;
        + self.system_prmtop
        + &#34; and &#34;
        + self.system_pdb
    )
    pdb = simtk.openmm.app.PDBFile(self.system_pdb)
    prmtop = simtk.openmm.app.AmberPrmtopFile(self.system_prmtop)
    system = prmtop.createSystem()
    integrator = simtk.openmm.LangevinIntegrator(
        300 * simtk.unit.kelvin,
        1 / simtk.unit.picosecond,
        0.002 * simtk.unit.picoseconds,
    )
    simulation = simtk.openmm.app.Simulation(
        prmtop.topology, system, integrator
    )
    simulation.context.setPositions(pdb.positions)
    simulation.minimizeEnergy()
    simulation.reporters.append(
        simtk.openmm.app.PDBReporter(
            self.system_output, self.sim_steps / 10
        )
    )
    simulation.reporters.append(
        simtk.openmm.app.StateDataReporter(
            stdout,
            reportInterval=int(self.sim_steps / 10),
            step=True,
            potentialEnergy=True,
            temperature=True,
        )
    )
    simulation.step(self.sim_steps)
    command = &#34;rm -rf &#34; + self.system_output
    os.system(command)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.TorsionDriveParams"><code class="flex name class">
<span>class <span class="ident">TorsionDriveParams</span></span>
<span>(</span><span>num_charge_atoms, index_charge_atom_1, charge_atom_1, tor_dir='torsion_dir', reparameterized_torsional_params_file='reparameterized_torsional_params.txt', psi_input_file='torsion_drive_input.dat', xyz_file='torsion_drive_input.xyz', coords_file='torsion_drive_input.txt', template_pdb='guest_init_II.pdb', system_pdb='torsion_drive_input.pdb', system_sdf='torsion_drive_input.sdf', system_xml='torsion_drive_input.xml', qm_scan_file='scan.xyz', load_topology='openmm', method='L-BFGS-B', dihedral_text_file='dihedrals.txt', system_init_sdf='torsion_drive_input_init.sdf', reparameterised_system_xml_file='guest_reparameterised.xml', reparameterised_torsional_system_xml_file='guest_torsional_reparameterized.xml')</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to parameterize the torsional parameters
of the ligand by fitting the torsional parameters obtained
from torsiondrive calculations. </p>
<p>&hellip;
Attributes</p>
<hr>
<dl>
<dt><strong><code>num_charge_atoms</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of charged atoms in the molecule.</dd>
</dl>
<p>index_charge_atom_1 : int
Index of the first charged atom.</p>
<p>charge_atom_1 : int
Charge on the first charged atom.</p>
<p>tor_dir : str, optional
Torsiondrive directory containing separate torsiondrive folders,
each containing files for a separate torsiondrive calculation
for a particular dihedral angle.</p>
<p>reparameterized_torsional_params_file : str, optional
Text file containing the forcefield parameters for the
ligand previously obtained without torsional reparameterization. </p>
<p>psi_input_file : str, optional
Input file for psi4 QM engine. </p>
<p>xyz_file : str, optional
XYZ file for ligand coordinates.</p>
<p>coords_file : str, optional
Text file containing the XYZ coordinates of the ligand.</p>
<p>template_pdb : str, optional
Guest PDB with atoms beginning from 1 to be used as a template PDB
to retrieve atom indices and symbols.</p>
<p>system_pdb : str, optional
PDB file for the torsiondrive torsion scans.</p>
<p>system_sdf : str, optional
SDF file for the ligand.</p>
<p>system_xml : str, optional
XML force field file for the ligand.</p>
<p>qm_scan_file : str, optional
Output scan file for the torsiondrive scans.</p>
<p>load_topology : str, optional
Argument to specify how to load the topology. Can either
be "openmm" or "parmed".</p>
<p>method : str, optional
Minimization method for fitting of torsional
parameters. </p>
<p>dihedral_text_file : str, optional
Dihedral information file for torsiondrive.</p>
<p>system_init_sdf : str, optional
Ligand SDF (structure-data) format file. This file will be generated
only if the ligand is charged.</p>
<p>reparameterised_system_xml_file : str, optional
Reparameterized force field XML file obtained using
openforcefield without torsional reparamaterization.</p>
<p>reparameterised_torsional_system_xml_file : str, optional
XML force field file for the ligand obtained with
torsional reparamaterization. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>num_charge_atoms</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of charged atoms in the molecule.</dd>
</dl>
<p>index_charge_atom_1 : int
Index of the first charged atom.</p>
<p>charge_atom_1 : int
Charge on the first charged atom.</p>
<p>tor_dir : str, optional
Torsiondrive directory containing separate torsiondrive folders,
each containing files for a separate torsiondrive calculation
for a particular dihedral angle.</p>
<p>reparameterized_torsional_params_file : str, optional
Text file containing the forcefield parameters for the
ligand previously obtained without torsional reparameterization. </p>
<p>psi_input_file : str, optional
Input file for psi4 QM engine. </p>
<p>xyz_file : str, optional
XYZ file for ligand coordinates.</p>
<p>coords_file : str, optional
Text file containing the XYZ coordinates of the ligand.</p>
<p>template_pdb : str, optional
Guest PDB with atoms beginning from 1 to be used as a template PDB
to retrieve atom indices and symbols.</p>
<p>system_pdb : str, optional
PDB file for the torsiondrive torsion scans.</p>
<p>system_sdf : str, optional
SDF file for the ligand.</p>
<p>system_xml : str, optional
XML force field file for the ligand.</p>
<p>qm_scan_file : str, optional
Output scan file for the torsiondrive scans.</p>
<p>load_topology : str, optional
Argument to specify how to load the topology. Can either
be "openmm" or "parmed".</p>
<p>method : str, optional
Minimization method for fitting of torsional
parameters. </p>
<p>dihedral_text_file : str, optional
Dihedral information file for torsiondrive.</p>
<p>system_init_sdf : str, optional
Ligand SDF (structure-data) format file. This file will be generated
only if the ligand is charged.</p>
<p>reparameterised_system_xml_file : str, optional
Reparameterized force field XML file obtained using
openforcefield without torsional reparamaterization.</p>
<p>reparameterised_torsional_system_xml_file : str, optional
XML force field file for the ligand obtained with
torsional reparamaterization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TorsionDriveParams:
    &#34;&#34;&#34;
    This class is used to parameterize the torsional parameters 
    of the ligand by fitting the torsional parameters obtained 
    from torsiondrive calculations. 

    ...
    Attributes
    ----------
    num_charge_atoms : int
        Number of charged atoms in the molecule.

    index_charge_atom_1 : int
        Index of the first charged atom.

    charge_atom_1 : int
        Charge on the first charged atom.

    tor_dir : str, optional
        Torsiondrive directory containing separate torsiondrive folders, 
        each containing files for a separate torsiondrive calculation 
        for a particular dihedral angle.

    reparameterized_torsional_params_file : str, optional
        Text file containing the forcefield parameters for the 
        ligand previously obtained without torsional reparameterization. 

    psi_input_file : str, optional
        Input file for psi4 QM engine. 

    xyz_file : str, optional
        XYZ file for ligand coordinates.

    coords_file : str, optional
        Text file containing the XYZ coordinates of the ligand.

    template_pdb : str, optional
        Guest PDB with atoms beginning from 1 to be used as a template PDB 
        to retrieve atom indices and symbols.

    system_pdb : str, optional
        PDB file for the torsiondrive torsion scans.

    system_sdf : str, optional
        SDF file for the ligand.

    system_xml : str, optional
        XML force field file for the ligand.

    qm_scan_file : str, optional
        Output scan file for the torsiondrive scans.

    load_topology : str, optional
        Argument to specify how to load the topology. Can either 
        be &#34;openmm&#34; or &#34;parmed&#34;.

    method : str, optional
        Minimization method for fitting of torsional 
        parameters. 

    dihedral_text_file : str, optional
        Dihedral information file for torsiondrive.
 
    system_init_sdf : str, optional
        Ligand SDF (structure-data) format file. This file will be generated 
        only if the ligand is charged.

    reparameterised_system_xml_file : str, optional
        Reparameterized force field XML file obtained using 
        openforcefield without torsional reparamaterization.

    reparameterised_torsional_system_xml_file : str, optional
        XML force field file for the ligand obtained with 
        torsional reparamaterization. 

    &#34;&#34;&#34;

    def __init__(
        self,
        num_charge_atoms,
        index_charge_atom_1,
        charge_atom_1,
        tor_dir=&#34;torsion_dir&#34;,
        reparameterized_torsional_params_file=&#34;reparameterized_torsional_params.txt&#34;,
        psi_input_file=&#34;torsion_drive_input.dat&#34;,
        xyz_file=&#34;torsion_drive_input.xyz&#34;,
        coords_file=&#34;torsion_drive_input.txt&#34;,
        template_pdb=&#34;guest_init_II.pdb&#34;,
        system_pdb=&#34;torsion_drive_input.pdb&#34;,
        system_sdf=&#34;torsion_drive_input.sdf&#34;,
        system_xml=&#34;torsion_drive_input.xml&#34;,
        qm_scan_file=&#34;scan.xyz&#34;,
        load_topology=&#34;openmm&#34;,
        method=&#34;L-BFGS-B&#34;,
        dihedral_text_file=&#34;dihedrals.txt&#34;,
        system_init_sdf=&#34;torsion_drive_input_init.sdf&#34;,
        reparameterised_system_xml_file=&#34;guest_reparameterised.xml&#34;,
        reparameterised_torsional_system_xml_file=&#34;guest_torsional_reparameterized.xml&#34;,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------
        num_charge_atoms : int
            Number of charged atoms in the molecule.

        index_charge_atom_1 : int
            Index of the first charged atom.

        charge_atom_1 : int
            Charge on the first charged atom.

        tor_dir : str, optional
            Torsiondrive directory containing separate torsiondrive folders, 
            each containing files for a separate torsiondrive calculation 
            for a particular dihedral angle.

        reparameterized_torsional_params_file : str, optional
            Text file containing the forcefield parameters for the 
            ligand previously obtained without torsional reparameterization. 

        psi_input_file : str, optional
            Input file for psi4 QM engine. 
    
        xyz_file : str, optional
            XYZ file for ligand coordinates.

        coords_file : str, optional
            Text file containing the XYZ coordinates of the ligand.

        template_pdb : str, optional
            Guest PDB with atoms beginning from 1 to be used as a template PDB 
            to retrieve atom indices and symbols.

        system_pdb : str, optional
            PDB file for the torsiondrive torsion scans.

        system_sdf : str, optional
            SDF file for the ligand.

        system_xml : str, optional
            XML force field file for the ligand.

        qm_scan_file : str, optional
            Output scan file for the torsiondrive scans.

        load_topology : str, optional
            Argument to specify how to load the topology. Can either 
            be &#34;openmm&#34; or &#34;parmed&#34;.

        method : str, optional
           Minimization method for fitting of torsional 
            parameters. 

        dihedral_text_file : str, optional
            Dihedral information file for torsiondrive.
 
        system_init_sdf : str, optional
            Ligand SDF (structure-data) format file. This file will be generated 
            only if the ligand is charged.

        reparameterised_system_xml_file : str, optional
            Reparameterized force field XML file obtained using 
            openforcefield without torsional reparamaterization.

        reparameterised_torsional_system_xml_file : str, optional
            XML force field file for the ligand obtained with 
            torsional reparamaterization. 
        &#34;&#34;&#34;
        self.num_charge_atoms = num_charge_atoms
        self.index_charge_atom_1 = index_charge_atom_1
        self.charge_atom_1 = charge_atom_1
        self.tor_dir = tor_dir
        self.reparameterized_torsional_params_file = reparameterized_torsional_params_file
        self.psi_input_file = psi_input_file
        self.xyz_file = xyz_file
        self.coords_file = coords_file
        self.template_pdb = template_pdb
        self.system_pdb = system_pdb
        self.system_sdf = system_sdf
        self.system_xml = system_xml
        self.qm_scan_file = qm_scan_file
        self.method = method
        self.dihedral_text_file = dihedral_text_file
        self.system_init_sdf = system_init_sdf
        self.load_topology = load_topology
        self.reparameterised_system_xml_file = reparameterised_system_xml_file
        self.reparameterised_torsional_system_xml_file = reparameterised_torsional_system_xml_file

    def write_reparams_torsion_lines(self):
        &#34;&#34;&#34;
        Saves a text file containing torsional parameters for the ligand
        obtained through openforcefield.
        &#34;&#34;&#34;
        torsional_parameters_list = []
        parent_cwd = os.getcwd()
        target_dir = parent_cwd + &#34;/&#34; + self.tor_dir
        for i in os.listdir(target_dir):
            os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + i)
            print(&#34;Entering directory&#34; + &#34; : &#34; + os.getcwd())
            torsiondrive_input_to_xyz(
                psi_input_file=self.psi_input_file, xyz_file=self.xyz_file
            )
            xyz_to_pdb(
                xyz_file=self.xyz_file,
                coords_file=self.coords_file,
                template_pdb=self.template_pdb,
                system_pdb=self.system_pdb,
            )
            generate_xml_from_charged_pdb_sdf(
                system_pdb=self.system_pdb,
                system_init_sdf=system_init_sdf,
                system_sdf=self.system_sdf,
                num_charge_atoms=num_charge_atoms,
                index_charge_atom_1=index_charge_atom_1,
                charge_atom_1=charge_atom_1,
                system_xml=self.system_xml,
            )
            torsional_lines = get_torsional_lines(
                template_pdb=self.template_pdb,
                system_xml=self.system_xml,
                qm_scan_file=self.qm_scan_file,
                load_topology=self.load_topology,
                method=self.method,
                dihedral_text_file=self.dihedral_text_file,
            )
            # print(torsional_lines)
            torsional_parameters_list.append(torsional_lines)
            remove_mm_files(qm_scan_file=self.qm_scan_file)
            os.chdir(parent_cwd)
        torsional_parameters = [
            item for sublist in torsional_parameters_list for item in sublist
        ]
        with open(self.reparameterized_torsional_params_file, &#34;w&#34;) as f:
            for i in torsional_parameters:
                f.write(i + &#34;\n&#34;)

    def write_reparams_torsion_lines_charged(self):
        &#34;&#34;&#34;
        Saves a text file containing torsional parameters for a charged ligand
        obtained through openforcefield.
        &#34;&#34;&#34;
        torsional_parameters_list = []
        parent_cwd = os.getcwd()
        target_dir = parent_cwd + &#34;/&#34; + self.tor_dir
        for i in os.listdir(target_dir):
            os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + i)
            print(&#34;Entering directory&#34; + &#34; : &#34; + os.getcwd())
            torsiondrive_input_to_xyz(
                psi_input_file=self.psi_input_file, xyz_file=self.xyz_file
            )
            xyz_to_pdb(
                xyz_file=self.xyz_file,
                coords_file=self.coords_file,
                template_pdb=self.template_pdb,
                system_pdb=self.system_pdb,
            )
            generate_xml_from_charged_pdb_sdf(
                system_pdb=self.system_pdb,
                system_init_sdf=self.system_init_sdf,
                system_sdf=self.system_sdf,
                num_charge_atoms=self.num_charge_atoms,
                index_charge_atom_1=self.index_charge_atom_1,
                charge_atom_1=self.charge_atom_1,
                system_xml=self.system_xml,
            )
            torsional_lines = get_torsional_lines(
                template_pdb=self.template_pdb,
                system_xml=self.system_xml,
                qm_scan_file=self.qm_scan_file,
                load_topology=self.load_topology,
                method=self.method,
                dihedral_text_file=self.dihedral_text_file,
            )
            # print(torsional_lines)
            torsional_parameters_list.append(torsional_lines)
            remove_mm_files(qm_scan_file=self.qm_scan_file)
            os.chdir(parent_cwd)
        torsional_parameters = [
            item for sublist in torsional_parameters_list for item in sublist
        ]
        with open(self.reparameterized_torsional_params_file, &#34;w&#34;) as f:
            for i in torsional_parameters:
                f.write(i + &#34;\n&#34;)

    def write_torsional_reparams(self):
        &#34;&#34;&#34;
        Generates a XML force field file for the ligand with reparameterized 
        torsional parameters.
        &#34;&#34;&#34;
        xml_tor = open(self.reparameterized_torsional_params_file, &#34;r&#34;)
        xml_tor_lines = xml_tor.readlines()
        non_zero_k_tor = []
        for i in xml_tor_lines:
            to_find = &#34;k=&#34; + &#39;&#34;&#39; + &#34;0.0&#34; + &#39;&#34;&#39;
            if to_find not in i:
                non_zero_k_tor.append(i)
        # print(non_zero_k_tor)
        p1 = []
        for i in range(len(non_zero_k_tor)):
            p1.append(int(re.findall(&#34;\d*\.?\d+&#34;, non_zero_k_tor[i])[2]))
        # print(p1)
        p2 = []
        for i in range(len(non_zero_k_tor)):
            p2.append(int(re.findall(&#34;\d*\.?\d+&#34;, non_zero_k_tor[i])[4]))
        # print(p2)
        p3 = []
        for i in range(len(non_zero_k_tor)):
            p3.append(int(re.findall(&#34;\d*\.?\d+&#34;, non_zero_k_tor[i])[6]))
        # print(p3)
        p4 = []
        for i in range(len(non_zero_k_tor)):
            p4.append(int(re.findall(&#34;\d*\.?\d+&#34;, non_zero_k_tor[i])[8]))
        # print(p4)
        periodicity = []
        for i in range(len(non_zero_k_tor)):
            periodicity.append(
                int(re.findall(&#34;\d*\.?\d+&#34;, non_zero_k_tor[i])[9])
            )
        # print(periodicity)
        xml_tor_reparams = open(self.reparameterised_system_xml_file, &#34;r&#34;)
        xml_tor_reparams_lines = xml_tor_reparams.readlines()
        for j in range(len(xml_tor_reparams_lines)):
            for i in range(len(non_zero_k_tor)):
                to_find_tor = (
                    &#34;p1=&#34;
                    + &#39;&#34;&#39;
                    + str(p1[i])
                    + &#39;&#34;&#39;
                    + &#34; &#34;
                    + &#34;p2=&#34;
                    + &#39;&#34;&#39;
                    + str(p2[i])
                    + &#39;&#34;&#39;
                    + &#34; &#34;
                    + &#34;p3=&#34;
                    + &#39;&#34;&#39;
                    + str(p3[i])
                    + &#39;&#34;&#39;
                    + &#34; &#34;
                    + &#34;p4=&#34;
                    + &#39;&#34;&#39;
                    + str(p4[i])
                    + &#39;&#34;&#39;
                    + &#34; &#34;
                    + &#34;periodicity=&#34;
                    + &#39;&#34;&#39;
                    + str(periodicity[i])
                    + &#39;&#34;&#39;
                )
                if to_find_tor in xml_tor_reparams_lines[j]:
                    # print(xml_tor_reparams_lines[j])
                    xml_tor_reparams_lines[j] = non_zero_k_tor[i]
        with open(self.reparameterised_torsional_system_xml_file, &#34;w&#34;) as f:
            for i in xml_tor_reparams_lines:
                f.write(i)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.TorsionDriveParams.write_reparams_torsion_lines"><code class="name flex">
<span>def <span class="ident">write_reparams_torsion_lines</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a text file containing torsional parameters for the ligand
obtained through openforcefield.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_reparams_torsion_lines(self):
    &#34;&#34;&#34;
    Saves a text file containing torsional parameters for the ligand
    obtained through openforcefield.
    &#34;&#34;&#34;
    torsional_parameters_list = []
    parent_cwd = os.getcwd()
    target_dir = parent_cwd + &#34;/&#34; + self.tor_dir
    for i in os.listdir(target_dir):
        os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + i)
        print(&#34;Entering directory&#34; + &#34; : &#34; + os.getcwd())
        torsiondrive_input_to_xyz(
            psi_input_file=self.psi_input_file, xyz_file=self.xyz_file
        )
        xyz_to_pdb(
            xyz_file=self.xyz_file,
            coords_file=self.coords_file,
            template_pdb=self.template_pdb,
            system_pdb=self.system_pdb,
        )
        generate_xml_from_charged_pdb_sdf(
            system_pdb=self.system_pdb,
            system_init_sdf=system_init_sdf,
            system_sdf=self.system_sdf,
            num_charge_atoms=num_charge_atoms,
            index_charge_atom_1=index_charge_atom_1,
            charge_atom_1=charge_atom_1,
            system_xml=self.system_xml,
        )
        torsional_lines = get_torsional_lines(
            template_pdb=self.template_pdb,
            system_xml=self.system_xml,
            qm_scan_file=self.qm_scan_file,
            load_topology=self.load_topology,
            method=self.method,
            dihedral_text_file=self.dihedral_text_file,
        )
        # print(torsional_lines)
        torsional_parameters_list.append(torsional_lines)
        remove_mm_files(qm_scan_file=self.qm_scan_file)
        os.chdir(parent_cwd)
    torsional_parameters = [
        item for sublist in torsional_parameters_list for item in sublist
    ]
    with open(self.reparameterized_torsional_params_file, &#34;w&#34;) as f:
        for i in torsional_parameters:
            f.write(i + &#34;\n&#34;)</code></pre>
</details>
</dd>
<dt id="parameterize.TorsionDriveParams.write_reparams_torsion_lines_charged"><code class="name flex">
<span>def <span class="ident">write_reparams_torsion_lines_charged</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a text file containing torsional parameters for a charged ligand
obtained through openforcefield.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_reparams_torsion_lines_charged(self):
    &#34;&#34;&#34;
    Saves a text file containing torsional parameters for a charged ligand
    obtained through openforcefield.
    &#34;&#34;&#34;
    torsional_parameters_list = []
    parent_cwd = os.getcwd()
    target_dir = parent_cwd + &#34;/&#34; + self.tor_dir
    for i in os.listdir(target_dir):
        os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + i)
        print(&#34;Entering directory&#34; + &#34; : &#34; + os.getcwd())
        torsiondrive_input_to_xyz(
            psi_input_file=self.psi_input_file, xyz_file=self.xyz_file
        )
        xyz_to_pdb(
            xyz_file=self.xyz_file,
            coords_file=self.coords_file,
            template_pdb=self.template_pdb,
            system_pdb=self.system_pdb,
        )
        generate_xml_from_charged_pdb_sdf(
            system_pdb=self.system_pdb,
            system_init_sdf=self.system_init_sdf,
            system_sdf=self.system_sdf,
            num_charge_atoms=self.num_charge_atoms,
            index_charge_atom_1=self.index_charge_atom_1,
            charge_atom_1=self.charge_atom_1,
            system_xml=self.system_xml,
        )
        torsional_lines = get_torsional_lines(
            template_pdb=self.template_pdb,
            system_xml=self.system_xml,
            qm_scan_file=self.qm_scan_file,
            load_topology=self.load_topology,
            method=self.method,
            dihedral_text_file=self.dihedral_text_file,
        )
        # print(torsional_lines)
        torsional_parameters_list.append(torsional_lines)
        remove_mm_files(qm_scan_file=self.qm_scan_file)
        os.chdir(parent_cwd)
    torsional_parameters = [
        item for sublist in torsional_parameters_list for item in sublist
    ]
    with open(self.reparameterized_torsional_params_file, &#34;w&#34;) as f:
        for i in torsional_parameters:
            f.write(i + &#34;\n&#34;)</code></pre>
</details>
</dd>
<dt id="parameterize.TorsionDriveParams.write_torsional_reparams"><code class="name flex">
<span>def <span class="ident">write_torsional_reparams</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a XML force field file for the ligand with reparameterized
torsional parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_torsional_reparams(self):
    &#34;&#34;&#34;
    Generates a XML force field file for the ligand with reparameterized 
    torsional parameters.
    &#34;&#34;&#34;
    xml_tor = open(self.reparameterized_torsional_params_file, &#34;r&#34;)
    xml_tor_lines = xml_tor.readlines()
    non_zero_k_tor = []
    for i in xml_tor_lines:
        to_find = &#34;k=&#34; + &#39;&#34;&#39; + &#34;0.0&#34; + &#39;&#34;&#39;
        if to_find not in i:
            non_zero_k_tor.append(i)
    # print(non_zero_k_tor)
    p1 = []
    for i in range(len(non_zero_k_tor)):
        p1.append(int(re.findall(&#34;\d*\.?\d+&#34;, non_zero_k_tor[i])[2]))
    # print(p1)
    p2 = []
    for i in range(len(non_zero_k_tor)):
        p2.append(int(re.findall(&#34;\d*\.?\d+&#34;, non_zero_k_tor[i])[4]))
    # print(p2)
    p3 = []
    for i in range(len(non_zero_k_tor)):
        p3.append(int(re.findall(&#34;\d*\.?\d+&#34;, non_zero_k_tor[i])[6]))
    # print(p3)
    p4 = []
    for i in range(len(non_zero_k_tor)):
        p4.append(int(re.findall(&#34;\d*\.?\d+&#34;, non_zero_k_tor[i])[8]))
    # print(p4)
    periodicity = []
    for i in range(len(non_zero_k_tor)):
        periodicity.append(
            int(re.findall(&#34;\d*\.?\d+&#34;, non_zero_k_tor[i])[9])
        )
    # print(periodicity)
    xml_tor_reparams = open(self.reparameterised_system_xml_file, &#34;r&#34;)
    xml_tor_reparams_lines = xml_tor_reparams.readlines()
    for j in range(len(xml_tor_reparams_lines)):
        for i in range(len(non_zero_k_tor)):
            to_find_tor = (
                &#34;p1=&#34;
                + &#39;&#34;&#39;
                + str(p1[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p2=&#34;
                + &#39;&#34;&#39;
                + str(p2[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p3=&#34;
                + &#39;&#34;&#39;
                + str(p3[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;p4=&#34;
                + &#39;&#34;&#39;
                + str(p4[i])
                + &#39;&#34;&#39;
                + &#34; &#34;
                + &#34;periodicity=&#34;
                + &#39;&#34;&#39;
                + str(periodicity[i])
                + &#39;&#34;&#39;
            )
            if to_find_tor in xml_tor_reparams_lines[j]:
                # print(xml_tor_reparams_lines[j])
                xml_tor_reparams_lines[j] = non_zero_k_tor[i]
    with open(self.reparameterised_torsional_system_xml_file, &#34;w&#34;) as f:
        for i in xml_tor_reparams_lines:
            f.write(i)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.TorsionDriveSims"><code class="flex name class">
<span>class <span class="ident">TorsionDriveSims</span></span>
<span>(</span><span>charge, multiplicity, reparameterised_system_xml_file='guest_reparameterised.xml', torsion_xml_file='guest_torsion_xml.txt', xyz_file='guest_coords.xyz', psi_input_file='torsion_drive_input.dat', memory=50, basis_set='STO-3G', functional='BLYP', iterations=2000, method_torsion_drive='native_opt', system_bonds_file='guest_bonds.txt', tor_dir='torsion_dir', dihedral_text_file='dihedrals.txt', template_pdb='guest_init_II.pdb', torsion_drive_run_file='run_command', dihedral_interval=15, engine='psi4', energy_threshold=0.001)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to create a filetree for torsion scan
using torsionsdrive for the dihedral angles of the ligand.</p>
<p>This class creates a directory for carrying out torsiondrive
calculations followed by fitting of torsional parameters. Methods
in this class are used to run torsiondrive calculations either for
all of the torsional angles, or for non-hydrogen / heavy atoms
contributing to the torsional angle.</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>charge</code></strong> :&ensp;<code>int</code></dt>
<dd>Charge of the ligand.</dd>
<dt><strong><code>multiplicity</code></strong> :&ensp;<code>int</code></dt>
<dd>Spin Multiplicity (2S+1) of the ligand where S represents
the total spin of the ligand.</dd>
<dt><strong><code>reparameterised_system_xml_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Reparamaterixed XML force field for the ligand.</dd>
<dt><strong><code>torsion_xml_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A text file containing torsional parameters from
reparametrised XML file.</dd>
<dt><strong><code>xyz_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>XYZ file containing the coordinates of the guest molecule.</dd>
<dt><strong><code>psi_input_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Input file for psi4 QM engine.</dd>
<dt><strong><code>memory</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Memory (in GB) to be used.</dd>
<dt><strong><code>basis_set</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Basis set to use for the QM engine.</dd>
<dt><strong><code>functional</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Exchange/Correlation or hybrid Functional for the QM engine.</dd>
<dt><strong><code>iterations</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of geometry optimization steps.</dd>
<dt><strong><code>method_torsion_drive</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The algorithm/package to use while running the torsiondrive
scan. Using &ndash;native_opt uses QM program native constrained
optimization algorithm and turns off geomeTRIC package.</dd>
<dt><strong><code>system_bonds_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing bond parameters for the ligand.</dd>
<dt><strong><code>tor_dir</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Torsiondrive directory containing separate torsiondrive
folders, each containing files for a separate torsiondrive
calculation for a particular dihedral angle.</dd>
<dt><strong><code>dihedral_text_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>&nbsp;</dd>
</dl>
<p>Dihedral information file for torsiondrive.</p>
<dl>
<dt><strong><code>template_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Guest PDB with atoms beginning from 1 to be used as a
template PDB to retrieve atom indices and symbols.</dd>
<dt><strong><code>torsion_drive_run_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>bash file for torsiondrive calculations.</dd>
<dt><strong><code>dihedral_interval</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Grid spacing for dihedral scan, i.e. every n degrees
(where n is an integer), multiple values will be mapped
to each dihedral angle.</dd>
<dt><strong><code>engine</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Engine for running torsiondrive scan.</dd>
<dt><strong><code>energy_threshold</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Only activate grid points if the new optimization is lower than
the previous lowest energy (in a.u.).</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>charge</code></strong> :&ensp;<code>int</code></dt>
<dd>Charge of the ligand.</dd>
<dt><strong><code>multiplicity</code></strong> :&ensp;<code>int</code></dt>
<dd>Spin Multiplicity (2S+1) of the ligand where S represents
the total spin of the ligand.</dd>
<dt><strong><code>reparameterised_system_xml_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Reparamaterixed XML force field for the ligand.</dd>
<dt><strong><code>torsion_xml_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A text file containing torsional parameters from
reparametrised XML file.</dd>
<dt><strong><code>xyz_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>XYZ file containing the coordinates of the guest molecule.</dd>
<dt><strong><code>psi_input_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Input file for psi4 QM engine.</dd>
<dt><strong><code>memory</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Memory (in GB) to be used.</dd>
<dt><strong><code>basis_set</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Basis set to use for the QM engine.</dd>
<dt><strong><code>functional</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Exchange/Correlation or hybrid Functional for the QM engine.</dd>
<dt><strong><code>iterations</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of geometry optimization steps.</dd>
<dt><strong><code>method_torsion_drive</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The algorithm/package to use while running the torsiondrive
scan. Using &ndash;native_opt uses QM program native constrained
optimization algorithm and turns off geomeTRIC package.</dd>
<dt><strong><code>system_bonds_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text file containing bond parameters for the ligand.</dd>
<dt><strong><code>tor_dir</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Torsiondrive directory containing separate torsiondrive
folders, each containing files for a separate torsiondrive
calculation for a particular dihedral angle.</dd>
<dt><strong><code>dihedral_text_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>&nbsp;</dd>
</dl>
<p>Dihedral information file for torsiondrive.</p>
<dl>
<dt><strong><code>template_pdb</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Guest PDB with atoms beginning from 1 to be used as a
template PDB to retrieve atom indices and symbols.</dd>
<dt><strong><code>torsion_drive_run_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>bash file for torsiondrive calculations.</dd>
<dt><strong><code>dihedral_interval</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Grid spacing for dihedral scan, i.e. every n degrees
(where n is an integer), multiple values will be mapped
to each dihedral angle.</dd>
<dt><strong><code>engine</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Engine for running torsiondrive scan.</dd>
<dt><strong><code>energy_threshold</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Only activate grid points if the new optimization is lower than
the previous lowest energy (in a.u.).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TorsionDriveSims:
    &#34;&#34;&#34;
    This class is used to create a filetree for torsion scan 
    using torsionsdrive for the dihedral angles of the ligand.

    This class creates a directory for carrying out torsiondrive 
    calculations followed by fitting of torsional parameters. Methods 
    in this class are used to run torsiondrive calculations either for
    all of the torsional angles, or for non-hydrogen / heavy atoms 
    contributing to the torsional angle.
    
    ...

    Attributes
    ----------
    charge : int
        Charge of the ligand. 

    multiplicity: int
        Spin Multiplicity (2S+1) of the ligand where S represents 
        the total spin of the ligand. 

    reparameterised_system_xml_file : str, optional
        Reparamaterixed XML force field for the ligand.

    torsion_xml_file : str, optional
        A text file containing torsional parameters from
        reparametrised XML file.

    xyz_file : str, optional
        XYZ file containing the coordinates of the guest molecule.

    psi_input_file : str, optional
        Input file for psi4 QM engine. 

    memory : int, optional
        Memory (in GB) to be used.

    basis_set: str, optional
        Basis set to use for the QM engine.

    functional: str, optional
        Exchange/Correlation or hybrid Functional for the QM engine. 

    iterations : int, optional
        Maximum number of geometry optimization steps.

    method_torsion_drive : str, optional
        The algorithm/package to use while running the torsiondrive
        scan. Using --native_opt uses QM program native constrained
        optimization algorithm and turns off geomeTRIC package.

    system_bonds_file : str, optional
        Text file containing bond parameters for the ligand.

    tor_dir : str, optional
        Torsiondrive directory containing separate torsiondrive
        folders, each containing files for a separate torsiondrive 
        calculation for a particular dihedral angle. 

    dihedral_text_file : str, optional
       Dihedral information file for torsiondrive.

    template_pdb : str, optional
        Guest PDB with atoms beginning from 1 to be used as a
        template PDB to retrieve atom indices and symbols.

    torsion_drive_run_file : str, optional
        bash file for torsiondrive calculations. 

    dihedral_interval : int, optional
        Grid spacing for dihedral scan, i.e. every n degrees 
        (where n is an integer), multiple values will be mapped 
        to each dihedral angle.

    engine : str, optional
        Engine for running torsiondrive scan. 

    energy_threshold : float, optional
        Only activate grid points if the new optimization is lower than
        the previous lowest energy (in a.u.).

    &#34;&#34;&#34;
    def __init__(
        self,
        charge,
        multiplicity,
        reparameterised_system_xml_file=&#34;guest_reparameterised.xml&#34;,
        torsion_xml_file=&#34;guest_torsion_xml.txt&#34;,
        xyz_file=&#34;guest_coords.xyz&#34;,
        psi_input_file=&#34;torsion_drive_input.dat&#34;,
        memory=50,
        basis_set=&#34;STO-3G&#34;,
        functional=&#34;BLYP&#34;,
        iterations=2000,
        method_torsion_drive=&#34;native_opt&#34;,
        system_bonds_file=&#34;guest_bonds.txt&#34;,
        tor_dir=&#34;torsion_dir&#34;,
        dihedral_text_file=&#34;dihedrals.txt&#34;,
        template_pdb=&#34;guest_init_II.pdb&#34;,
        torsion_drive_run_file=&#34;run_command&#34;,
        dihedral_interval=15,
        engine=&#34;psi4&#34;,
        energy_threshold=0.001,
    ):
        &#34;&#34;&#34;
        Parameters
        ----------

        charge : int
            Charge of the ligand. 

        multiplicity: int
            Spin Multiplicity (2S+1) of the ligand where S represents 
            the total spin of the ligand. 

        reparameterised_system_xml_file : str, optional
            Reparamaterixed XML force field for the ligand.

        torsion_xml_file : str, optional
            A text file containing torsional parameters from
            reparametrised XML file.

        xyz_file : str, optional
            XYZ file containing the coordinates of the guest molecule.

        psi_input_file : str, optional
            Input file for psi4 QM engine. 

        memory : int, optional
            Memory (in GB) to be used.

        basis_set: str, optional
            Basis set to use for the QM engine.

        functional: str, optional
            Exchange/Correlation or hybrid Functional for the QM engine. 

        iterations : int, optional
            Maximum number of geometry optimization steps.

        method_torsion_drive : str, optional
            The algorithm/package to use while running the torsiondrive
            scan. Using --native_opt uses QM program native constrained
            optimization algorithm and turns off geomeTRIC package.

        system_bonds_file : str, optional
            Text file containing bond parameters for the ligand.

        tor_dir : str, optional
            Torsiondrive directory containing separate torsiondrive
            folders, each containing files for a separate torsiondrive 
            calculation for a particular dihedral angle. 

        dihedral_text_file : str, optional
           Dihedral information file for torsiondrive.

        template_pdb : str, optional
            Guest PDB with atoms beginning from 1 to be used as a
            template PDB to retrieve atom indices and symbols.

        torsion_drive_run_file : str, optional
            bash file for torsiondrive calculations. 

        dihedral_interval : int, optional
            Grid spacing for dihedral scan, i.e. every n degrees 
            (where n is an integer), multiple values will be mapped 
            to each dihedral angle.

        engine : str, optional
            Engine for running torsiondrive scan. 

        energy_threshold : float, optional
            Only activate grid points if the new optimization is lower than
            the previous lowest energy (in a.u.).
        &#34;&#34;&#34;
        self.charge = charge
        self.multiplicity = multiplicity
        self.reparameterised_system_xml_file = reparameterised_system_xml_file
        self.torsion_xml_file = torsion_xml_file
        self.xyz_file = xyz_file
        self.psi_input_file = psi_input_file
        self.memory = memory
        self.basis_set = basis_set
        self.functional = functional
        self.iterations = iterations
        self.method_torsion_drive = method_torsion_drive
        self.system_bonds_file = system_bonds_file
        self.tor_dir = tor_dir
        self.dihedral_text_file = dihedral_text_file
        self.template_pdb = template_pdb
        self.torsion_drive_run_file = torsion_drive_run_file
        self.dihedral_interval = dihedral_interval
        self.engine = engine
        self.energy_threshold = energy_threshold

    def write_torsion_drive_run_file(self):
        &#34;&#34;&#34;
        Saves a bash file for running torsion scans for torsiondrive. 
        &#34;&#34;&#34;
        if self.method_torsion_drive == &#34;geometric&#34;:
            torsion_command = (
                &#34;torsiondrive-launch&#34;
                + &#34; &#34;
                + self.psi_input_file
                + &#34; &#34;
                + self.dihedral_text_file
                + &#34; &#34;
                + &#34;-g&#34;
                + &#34; &#34;
                + str(self.dihedral_interval)
                + &#34; &#34;
                + &#34;-e&#34;
                + &#34; &#34;
                + self.engine
                + &#34; &#34;
                + &#34;--energy_thresh&#34;
                + &#34; &#34;
                + str(self.energy_threshold)
                + &#34; &#34;
                + &#34;-v&#34;
            )
        if self.method_torsion_drive == &#34;native_opt&#34;:
            torsion_command = (
                &#34;torsiondrive-launch&#34;
                + &#34; &#34;
                + self.psi_input_file
                + &#34; &#34;
                + self.dihedral_text_file
                + &#34; &#34;
                + &#34;-g&#34;
                + &#34; &#34;
                + str(self.dihedral_interval)
                + &#34; &#34;
                + &#34;-e&#34;
                + &#34; &#34;
                + self.engine
                + &#34; &#34;
                + &#34;--energy_thresh&#34;
                + &#34; &#34;
                + str(self.energy_threshold)
                + &#34; &#34;
                + &#34;--&#34;
                + self.method_torsion_drive
                + &#34; &#34;
                + &#34;-v&#34;
            )
        print(torsion_command)
        with open(self.torsion_drive_run_file, &#34;w&#34;) as f:
            f.write(torsion_command)

    def write_tor_params_txt(self):
        &#34;&#34;&#34;
        Saves a text file containing torsional parameters from the reparameterized XML 
        force field file.
        &#34;&#34;&#34;
        xml_off = open(self.reparameterised_system_xml_file, &#34;r&#34;)
        xml_off_lines = xml_off.readlines()
        for i in range(len(xml_off_lines)):
            if &#34;&lt;Torsions&gt;&#34; in xml_off_lines[i]:
                to_begin = int(i)
            if &#34;&lt;/Torsions&gt;&#34; in xml_off_lines[i]:
                to_end = int(i)
        torsion_params = xml_off_lines[to_begin + 1 : to_end]

        k_list_off = []
        for i in range(len(torsion_params)):
            k_list_off.append(
                float(re.findall(&#34;\d*\.?\d+&#34;, torsion_params[i])[0])
            )
        k_list_off = [round(num, 10) for num in k_list_off]
        # print(k_list_off)
        p1 = []
        for i in range(len(torsion_params)):
            p1.append(int(re.findall(&#34;\d*\.?\d+&#34;, torsion_params[i])[2]))
        p1 = [i + 1 for i in p1]
        # print(p1)
        p2 = []
        for i in range(len(torsion_params)):
            p2.append(int(re.findall(&#34;\d*\.?\d+&#34;, torsion_params[i])[4]))
        p2 = [i + 1 for i in p2]
        # print(p2)
        p3 = []
        for i in range(len(torsion_params)):
            p3.append(int(re.findall(&#34;\d*\.?\d+&#34;, torsion_params[i])[6]))
        p3 = [i + 1 for i in p3]
        # print(p3)
        p4 = []
        for i in range(len(torsion_params)):
            p4.append(int(re.findall(&#34;\d*\.?\d+&#34;, torsion_params[i])[8]))
        p4 = [i + 1 for i in p4]
        # print(p4)
        periodicity = []
        for i in range(len(torsion_params)):
            periodicity.append(
                int(re.findall(&#34;\d*\.?\d+&#34;, torsion_params[i])[9])
            )
        # print(periodicity)
        phase = []
        for i in range(len(torsion_params)):
            phase.append(float(re.findall(&#34;\d*\.?\d+&#34;, torsion_params[i])[10]))
        phase = [round(num, 8) for num in phase]
        # print(phase)
        data_tuples = list(zip(k_list_off, p1, p2, p3, p4, periodicity, phase))
        df_tor = pd.DataFrame(
            data_tuples,
            columns=[&#34;k&#34;, &#34;p1&#34;, &#34;p2&#34;, &#34;p3&#34;, &#34;p4&#34;, &#34;periodicity&#34;, &#34;phase&#34;],
        )
        # print(df_tor.head())
        df_tor.to_csv(
            self.torsion_xml_file, index=False, header=False, sep=&#34; &#34;
        )

    def write_psi4_input(self):
        &#34;&#34;&#34; 
        Writes a psi4 input QM file.
        &#34;&#34;&#34;
        xyz_lines = open(self.xyz_file, &#34;r&#34;).readlines()[2:]
        with open(self.psi_input_file, &#34;w&#34;) as f:
            f.write(&#34;memory&#34; + &#34; &#34; + str(self.memory) + &#34; &#34; + &#34;GB&#34; + &#34;\n&#34;)
            f.write(&#34;molecule&#34; + &#34; &#34; + &#34;{&#34; + &#34;\n&#34;)
            f.write(str(self.charge) + &#34; &#34; + str(self.multiplicity) + &#34;\n&#34;)
            for line in xyz_lines:
                f.write(line)
            f.write(&#34;}&#34; + &#34;\n&#34;)
            f.write(&#34;set&#34; + &#34; &#34; + &#34;{&#34; + &#34;\n&#34;)
            f.write(&#34;basis&#34; + &#34; &#34; + self.basis_set + &#34;\n&#34;)
            if self.method_torsion_drive == &#34;native_opt&#34;:
                f.write(&#34;GEOM_MAXITER&#34; + &#34; &#34; + str(self.iterations) + &#34;\n&#34;)
            f.write(&#34;}&#34; + &#34;\n&#34;)
            if self.method_torsion_drive == &#34;native_opt&#34;:
                f.write(
                    &#34;optimize&#34; + &#34;(&#34; + &#34;&#39;&#34; + self.functional + &#34;&#39;&#34; &#34;)&#34; + &#34;\n&#34;
                )
            if self.method_torsion_drive == &#34;geometric&#34;:
                f.write(
                    &#34;gradient&#34; + &#34;(&#34; + &#34;&#39;&#34; + self.functional + &#34;&#39;&#34; &#34;)&#34; + &#34;\n&#34;
                )

    def create_torsion_drive_dir(self):
        &#34;&#34;&#34;
        Creates a directory for carrying out torsiondrive 
        calculations for all the proper dihedral angles. 
        &#34;&#34;&#34;
        df_tor = pd.read_csv(
            self.torsion_xml_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df_tor.columns = [&#34;k&#34;, &#34;p1&#34;, &#34;p2&#34;, &#34;p3&#34;, &#34;p4&#34;, &#34;periodicity&#34;, &#34;phase&#34;]
        # print(df_tor.head())
        df_dihedrals = df_tor[[&#34;p1&#34;, &#34;p2&#34;, &#34;p3&#34;, &#34;p4&#34;]]
        # print(df_dihedrals.head())
        dihedrals_list_list = []
        for i in range(len(df_dihedrals)):
            dihedrals_list_list.append(df_dihedrals.iloc[i].values.tolist())
        set_list = set()
        unique_dihedrals_list_list = []
        for x in dihedrals_list_list:
            srtd = tuple(sorted(x))
            if srtd not in set_list:
                unique_dihedrals_list_list.append(x)
                set_list.add(srtd)
        # print(unique_dihedrals_list_list)
        os.system(&#34;rm -rf &#34; + self.tor_dir)
        os.system(&#34;mkdir &#34; + self.tor_dir)
        parent_cwd = os.getcwd()
        shutil.copy(
            parent_cwd + &#34;/&#34; + self.psi_input_file,
            parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.psi_input_file,
        )
        shutil.copy(
            parent_cwd + &#34;/&#34; + self.template_pdb,
            parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.template_pdb,
        )
        shutil.copy(
            parent_cwd + &#34;/&#34; + self.torsion_drive_run_file,
            parent_cwd
            + &#34;/&#34;
            + self.tor_dir
            + &#34;/&#34;
            + self.torsion_drive_run_file,
        )
        os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir)
        torsion_drive_dir = os.getcwd()
        for i in range(len(unique_dihedrals_list_list)):
            dir_name = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
            os.system(&#34;rm -rf &#34; + dir_name)
            os.system(&#34;mkdir &#34; + dir_name)
            os.chdir(torsion_drive_dir + &#34;/&#34; + dir_name)
            with open(self.dihedral_text_file, &#34;w&#34;) as f:
                f.write(
                    &#34;# dihedral definition by atom indices starting from 1&#34;
                    + &#34;\n&#34;
                )
                f.write(&#34;# i     j     k     l&#34; + &#34;\n&#34;)
                i_ = unique_dihedrals_list_list[i][0]
                j_ = unique_dihedrals_list_list[i][1]
                k_ = unique_dihedrals_list_list[i][2]
                l_ = unique_dihedrals_list_list[i][3]
                f.write(
                    &#34; &#34;
                    + &#34;{:&lt; 6d}&#34;.format(i_)
                    + &#34;{:&lt; 6d}&#34;.format(j_)
                    + &#34;{:&lt; 6d}&#34;.format(k_)
                    + &#34;{:&lt; 6d}&#34;.format(l_)
                    + &#34;\n&#34;
                )
                shutil.copy(
                    torsion_drive_dir + &#34;/&#34; + self.psi_input_file,
                    torsion_drive_dir
                    + &#34;/&#34;
                    + dir_name
                    + &#34;/&#34;
                    + self.psi_input_file,
                )
                shutil.copy(
                    torsion_drive_dir + &#34;/&#34; + self.template_pdb,
                    torsion_drive_dir
                    + &#34;/&#34;
                    + dir_name
                    + &#34;/&#34;
                    + self.template_pdb,
                )
                shutil.copy(
                    torsion_drive_dir + &#34;/&#34; + self.torsion_drive_run_file,
                    torsion_drive_dir
                    + &#34;/&#34;
                    + dir_name
                    + &#34;/&#34;
                    + self.torsion_drive_run_file,
                )
                os.chdir(torsion_drive_dir)
        os.system(&#34;rm -rf &#34; + self.psi_input_file)
        os.system(&#34;rm -rf &#34; + self.template_pdb)
        os.system(&#34;rm -rf &#34; + self.torsion_drive_run_file)
        os.chdir(parent_cwd)

    def create_non_H_torsion_drive_dir(self):
        &#34;&#34;&#34;
        Creates a directory for carrying out torsiondrive 
        calculations for all non-hydrogen torsional angles. 
        &#34;&#34;&#34;
        df_tor = pd.read_csv(
            self.torsion_xml_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df_tor.columns = [&#34;k&#34;, &#34;p1&#34;, &#34;p2&#34;, &#34;p3&#34;, &#34;p4&#34;, &#34;periodicity&#34;, &#34;phase&#34;]
        # print(df_tor.head())
        ppdb = PandasPdb()
        ppdb.read_pdb(self.template_pdb)
        df_index_symbol = ppdb.df[&#34;ATOM&#34;][[&#34;atom_number&#34;, &#34;element_symbol&#34;]]
        # print(df_index_symbol.head())
        df_dihedrals = df_tor[[&#34;p1&#34;, &#34;p2&#34;, &#34;p3&#34;, &#34;p4&#34;]]
        # print(df_dihedrals.head())
        dihedrals_list_list = []
        for i in range(len(df_dihedrals)):
            dihedrals_list_list.append(df_dihedrals.iloc[i].values.tolist())
        set_list = set()
        unique_dihedrals_list_list = []
        for x in dihedrals_list_list:
            srtd = tuple(sorted(x))
            if srtd not in set_list:
                unique_dihedrals_list_list.append(x)
                set_list.add(srtd)
        # print(unique_dihedrals_list_list)
        atom_dihedral_list = []
        for sub_list in unique_dihedrals_list_list:
            atom_dihedral_list.append(
                [
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[0]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[1]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[2]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[3]
                    ][&#34;element_symbol&#34;].to_list()[0],
                ]
            )
        # print(atom_dihedral_list)
        index_to_include = []
        for i in range(len(atom_dihedral_list)):
            if &#34;H&#34; not in atom_dihedral_list[i]:
                index_to_include.append(i)
        non_H_dihedrals = []
        for i in index_to_include:
            non_H_dihedrals.append(unique_dihedrals_list_list[i])
        # print(non_H_dihedrals)
        non_H_atom_dihedral_list = []
        for sub_list in non_H_dihedrals:
            non_H_atom_dihedral_list.append(
                [
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[0]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[1]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[2]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[3]
                    ][&#34;element_symbol&#34;].to_list()[0],
                ]
            )
        print(non_H_atom_dihedral_list)
        os.system(&#34;rm -rf &#34; + self.tor_dir)
        os.system(&#34;mkdir &#34; + self.tor_dir)
        parent_cwd = os.getcwd()
        shutil.copy(
            parent_cwd + &#34;/&#34; + self.psi_input_file,
            parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.psi_input_file,
        )
        shutil.copy(
            parent_cwd + &#34;/&#34; + self.template_pdb,
            parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.template_pdb,
        )
        shutil.copy(
            parent_cwd + &#34;/&#34; + self.torsion_drive_run_file,
            parent_cwd
            + &#34;/&#34;
            + self.tor_dir
            + &#34;/&#34;
            + self.torsion_drive_run_file,
        )
        os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir)
        torsion_drive_dir = os.getcwd()
        for i in range(len(non_H_dihedrals)):
            dir_name = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
            os.system(&#34;rm -rf &#34; + dir_name)
            os.system(&#34;mkdir &#34; + dir_name)
            os.chdir(torsion_drive_dir + &#34;/&#34; + dir_name)
            with open(self.dihedral_text_file, &#34;w&#34;) as f:
                f.write(
                    &#34;# dihedral definition by atom indices starting from 1&#34;
                    + &#34;\n&#34;
                )
                f.write(&#34;# i     j     k     l&#34; + &#34;\n&#34;)
                i_ = non_H_dihedrals[i][0]
                j_ = non_H_dihedrals[i][1]
                k_ = non_H_dihedrals[i][2]
                l_ = non_H_dihedrals[i][3]
                f.write(
                    &#34; &#34;
                    + &#34;{:&lt; 6d}&#34;.format(i_)
                    + &#34;{:&lt; 6d}&#34;.format(j_)
                    + &#34;{:&lt; 6d}&#34;.format(k_)
                    + &#34;{:&lt; 6d}&#34;.format(l_)
                    + &#34;\n&#34;
                )
                shutil.copy(
                    torsion_drive_dir + &#34;/&#34; + self.psi_input_file,
                    torsion_drive_dir
                    + &#34;/&#34;
                    + dir_name
                    + &#34;/&#34;
                    + self.psi_input_file,
                )
                shutil.copy(
                    torsion_drive_dir + &#34;/&#34; + self.template_pdb,
                    torsion_drive_dir
                    + &#34;/&#34;
                    + dir_name
                    + &#34;/&#34;
                    + self.template_pdb,
                )
                shutil.copy(
                    torsion_drive_dir + &#34;/&#34; + self.torsion_drive_run_file,
                    torsion_drive_dir
                    + &#34;/&#34;
                    + dir_name
                    + &#34;/&#34;
                    + self.torsion_drive_run_file,
                )
                os.chdir(torsion_drive_dir)
        os.system(&#34;rm -rf &#34; + self.psi_input_file)
        os.system(&#34;rm -rf &#34; + self.template_pdb)
        os.system(&#34;rm -rf &#34; + self.torsion_drive_run_file)
        os.chdir(parent_cwd)

    def create_non_H_bonded_torsion_drive_dir(self):
        &#34;&#34;&#34;
        Creates a directory for carrying out torsiondrive 
        calculations for all non-hydrogen bonded torsional angles. 
        &#34;&#34;&#34;
        df_tor = pd.read_csv(
            self.torsion_xml_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df_tor.columns = [&#34;k&#34;, &#34;p1&#34;, &#34;p2&#34;, &#34;p3&#34;, &#34;p4&#34;, &#34;periodicity&#34;, &#34;phase&#34;]
        # print(df_tor.head())
        ppdb = PandasPdb()
        ppdb.read_pdb(self.template_pdb)
        df_index_symbol = ppdb.df[&#34;ATOM&#34;][[&#34;atom_number&#34;, &#34;element_symbol&#34;]]
        # print(df_index_symbol.head())
        df_dihedrals = df_tor[[&#34;p1&#34;, &#34;p2&#34;, &#34;p3&#34;, &#34;p4&#34;]]
        # print(df_dihedrals.head())
        dihedrals_list_list = []
        for i in range(len(df_dihedrals)):
            dihedrals_list_list.append(df_dihedrals.iloc[i].values.tolist())
        set_list = set()
        unique_dihedrals_list_list = []
        for x in dihedrals_list_list:
            srtd = tuple(sorted(x))
            if srtd not in set_list:
                unique_dihedrals_list_list.append(x)
                set_list.add(srtd)
        # print(unique_dihedrals_list_list)
        atom_dihedral_list = []
        for sub_list in unique_dihedrals_list_list:
            atom_dihedral_list.append(
                [
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[0]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[1]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[2]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[3]
                    ][&#34;element_symbol&#34;].to_list()[0],
                ]
            )
        # print(atom_dihedral_list)
        index_to_include = []
        for i in range(len(atom_dihedral_list)):
            if &#34;H&#34; not in atom_dihedral_list[i]:
                index_to_include.append(i)
        non_H_dihedrals = []
        for i in index_to_include:
            non_H_dihedrals.append(unique_dihedrals_list_list[i])
        # print(non_H_dihedrals)
        non_H_atom_dihedral_list = []
        for sub_list in non_H_dihedrals:
            non_H_atom_dihedral_list.append(
                [
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[0]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[1]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[2]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[3]
                    ][&#34;element_symbol&#34;].to_list()[0],
                ]
            )
        # print(non_H_atom_dihedral_list)
        df_bonds_all = pd.read_csv(
            self.system_bonds_file, header=None, delimiter=r&#34;\s+&#34;
        )
        df_bonds_all.columns = [&#34;bond_names&#34;, &#34;k&#34;, &#34;angle&#34;, &#34;b1&#34;, &#34;b2&#34;]
        df_bonds = df_bonds_all[[&#34;b1&#34;, &#34;b2&#34;]]
        bonds_list_list = []
        for i in range(len(df_bonds)):
            bonds_list_list.append(df_bonds.iloc[i].values.tolist())
        # print(bonds_list_list)
        reverse_bond_list_list = []
        for i in bonds_list_list:
            reverse_bond_list_list.append(reverse_list(i))
        # print(reverse_bond_list_list)
        bond_list = bonds_list_list + reverse_bond_list_list
        # print(bond_list)
        non_H_dihedral_bonds_list = []
        for i in non_H_dihedrals:
            non_H_dihedral_bonds_list.append(
                [[i[0], i[1]], [i[1], i[2]], [i[2], i[3]]]
            )
        # print(non_H_dihedral_bonds_list)
        bonded_index_to_include = []
        for i in range(len(non_H_dihedral_bonds_list)):
            if [
                non_H_dihedral_bonds_list[i][0] in bond_list,
                non_H_dihedral_bonds_list[i][1] in bond_list,
                non_H_dihedral_bonds_list[i][2] in bond_list,
            ] == [True, True, True]:
                bonded_index_to_include.append(i)
        # print(bonded_index_to_include)
        non_H_bonded_dihedrals = []
        for i in bonded_index_to_include:
            non_H_bonded_dihedrals.append(non_H_dihedrals[i])
        # print(non_H_bonded_dihedrals)
        non_H_bonded_atom_dihedral_list = []
        for sub_list in non_H_bonded_dihedrals:
            non_H_bonded_atom_dihedral_list.append(
                [
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[0]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[1]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[2]
                    ][&#34;element_symbol&#34;].to_list()[0],
                    df_index_symbol.loc[
                        df_index_symbol[&#34;atom_number&#34;] == sub_list[3]
                    ][&#34;element_symbol&#34;].to_list()[0],
                ]
            )
        print(non_H_bonded_atom_dihedral_list)
        os.system(&#34;rm -rf &#34; + self.tor_dir)
        os.system(&#34;mkdir &#34; + self.tor_dir)
        parent_cwd = os.getcwd()
        shutil.copy(
            parent_cwd + &#34;/&#34; + self.psi_input_file,
            parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.psi_input_file,
        )
        shutil.copy(
            parent_cwd + &#34;/&#34; + self.template_pdb,
            parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.template_pdb,
        )
        shutil.copy(
            parent_cwd + &#34;/&#34; + self.torsion_drive_run_file,
            parent_cwd
            + &#34;/&#34;
            + self.tor_dir
            + &#34;/&#34;
            + self.torsion_drive_run_file,
        )
        os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir)
        torsion_drive_dir = os.getcwd()
        for i in range(len(non_H_bonded_dihedrals)):
            dir_name = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
            os.system(&#34;rm -rf &#34; + dir_name)
            os.system(&#34;mkdir &#34; + dir_name)
            os.chdir(torsion_drive_dir + &#34;/&#34; + dir_name)
            with open(self.dihedral_text_file, &#34;w&#34;) as f:
                f.write(
                    &#34;# dihedral definition by atom indices starting from 1&#34;
                    + &#34;\n&#34;
                )
                f.write(&#34;# i     j     k     l&#34; + &#34;\n&#34;)
                i_ = non_H_bonded_dihedrals[i][0]
                j_ = non_H_bonded_dihedrals[i][1]
                k_ = non_H_bonded_dihedrals[i][2]
                l_ = non_H_bonded_dihedrals[i][3]
                f.write(
                    &#34; &#34;
                    + &#34;{:&lt; 6d}&#34;.format(i_)
                    + &#34;{:&lt; 6d}&#34;.format(j_)
                    + &#34;{:&lt; 6d}&#34;.format(k_)
                    + &#34;{:&lt; 6d}&#34;.format(l_)
                    + &#34;\n&#34;
                )
                shutil.copy(
                    torsion_drive_dir + &#34;/&#34; + self.psi_input_file,
                    torsion_drive_dir
                    + &#34;/&#34;
                    + dir_name
                    + &#34;/&#34;
                    + self.psi_input_file,
                )
                shutil.copy(
                    torsion_drive_dir + &#34;/&#34; + self.template_pdb,
                    torsion_drive_dir
                    + &#34;/&#34;
                    + dir_name
                    + &#34;/&#34;
                    + self.template_pdb,
                )
                shutil.copy(
                    torsion_drive_dir + &#34;/&#34; + self.torsion_drive_run_file,
                    torsion_drive_dir
                    + &#34;/&#34;
                    + dir_name
                    + &#34;/&#34;
                    + self.torsion_drive_run_file,
                )
                os.chdir(torsion_drive_dir)
        os.system(&#34;rm -rf &#34; + self.psi_input_file)
        os.system(&#34;rm -rf &#34; + self.template_pdb)
        os.system(&#34;rm -rf &#34; + self.torsion_drive_run_file)
        os.chdir(parent_cwd)

    def run_torsion_sim(self):
        &#34;&#34;&#34;
        Run torsion scans using torsiondrive locally. \
        &#34;&#34;&#34;
        parent_cwd = os.getcwd()
        target_dir = parent_cwd + &#34;/&#34; + self.tor_dir
        num_folders = 0
        for _, dirnames, filenames in os.walk(target_dir):
            num_folders += len(dirnames)
        for i in range(num_folders):
            dir_ = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
            os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + dir_)
            run_command = &#34;bash&#34; + &#34; &#34; + self.torsion_drive_run_file
            # os.system(run_command)
            print(run_command)
            os.chdir(parent_cwd)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.TorsionDriveSims.create_non_H_bonded_torsion_drive_dir"><code class="name flex">
<span>def <span class="ident">create_non_H_bonded_torsion_drive_dir</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a directory for carrying out torsiondrive
calculations for all non-hydrogen bonded torsional angles.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_non_H_bonded_torsion_drive_dir(self):
    &#34;&#34;&#34;
    Creates a directory for carrying out torsiondrive 
    calculations for all non-hydrogen bonded torsional angles. 
    &#34;&#34;&#34;
    df_tor = pd.read_csv(
        self.torsion_xml_file, header=None, delimiter=r&#34;\s+&#34;
    )
    df_tor.columns = [&#34;k&#34;, &#34;p1&#34;, &#34;p2&#34;, &#34;p3&#34;, &#34;p4&#34;, &#34;periodicity&#34;, &#34;phase&#34;]
    # print(df_tor.head())
    ppdb = PandasPdb()
    ppdb.read_pdb(self.template_pdb)
    df_index_symbol = ppdb.df[&#34;ATOM&#34;][[&#34;atom_number&#34;, &#34;element_symbol&#34;]]
    # print(df_index_symbol.head())
    df_dihedrals = df_tor[[&#34;p1&#34;, &#34;p2&#34;, &#34;p3&#34;, &#34;p4&#34;]]
    # print(df_dihedrals.head())
    dihedrals_list_list = []
    for i in range(len(df_dihedrals)):
        dihedrals_list_list.append(df_dihedrals.iloc[i].values.tolist())
    set_list = set()
    unique_dihedrals_list_list = []
    for x in dihedrals_list_list:
        srtd = tuple(sorted(x))
        if srtd not in set_list:
            unique_dihedrals_list_list.append(x)
            set_list.add(srtd)
    # print(unique_dihedrals_list_list)
    atom_dihedral_list = []
    for sub_list in unique_dihedrals_list_list:
        atom_dihedral_list.append(
            [
                df_index_symbol.loc[
                    df_index_symbol[&#34;atom_number&#34;] == sub_list[0]
                ][&#34;element_symbol&#34;].to_list()[0],
                df_index_symbol.loc[
                    df_index_symbol[&#34;atom_number&#34;] == sub_list[1]
                ][&#34;element_symbol&#34;].to_list()[0],
                df_index_symbol.loc[
                    df_index_symbol[&#34;atom_number&#34;] == sub_list[2]
                ][&#34;element_symbol&#34;].to_list()[0],
                df_index_symbol.loc[
                    df_index_symbol[&#34;atom_number&#34;] == sub_list[3]
                ][&#34;element_symbol&#34;].to_list()[0],
            ]
        )
    # print(atom_dihedral_list)
    index_to_include = []
    for i in range(len(atom_dihedral_list)):
        if &#34;H&#34; not in atom_dihedral_list[i]:
            index_to_include.append(i)
    non_H_dihedrals = []
    for i in index_to_include:
        non_H_dihedrals.append(unique_dihedrals_list_list[i])
    # print(non_H_dihedrals)
    non_H_atom_dihedral_list = []
    for sub_list in non_H_dihedrals:
        non_H_atom_dihedral_list.append(
            [
                df_index_symbol.loc[
                    df_index_symbol[&#34;atom_number&#34;] == sub_list[0]
                ][&#34;element_symbol&#34;].to_list()[0],
                df_index_symbol.loc[
                    df_index_symbol[&#34;atom_number&#34;] == sub_list[1]
                ][&#34;element_symbol&#34;].to_list()[0],
                df_index_symbol.loc[
                    df_index_symbol[&#34;atom_number&#34;] == sub_list[2]
                ][&#34;element_symbol&#34;].to_list()[0],
                df_index_symbol.loc[
                    df_index_symbol[&#34;atom_number&#34;] == sub_list[3]
                ][&#34;element_symbol&#34;].to_list()[0],
            ]
        )
    # print(non_H_atom_dihedral_list)
    df_bonds_all = pd.read_csv(
        self.system_bonds_file, header=None, delimiter=r&#34;\s+&#34;
    )
    df_bonds_all.columns = [&#34;bond_names&#34;, &#34;k&#34;, &#34;angle&#34;, &#34;b1&#34;, &#34;b2&#34;]
    df_bonds = df_bonds_all[[&#34;b1&#34;, &#34;b2&#34;]]
    bonds_list_list = []
    for i in range(len(df_bonds)):
        bonds_list_list.append(df_bonds.iloc[i].values.tolist())
    # print(bonds_list_list)
    reverse_bond_list_list = []
    for i in bonds_list_list:
        reverse_bond_list_list.append(reverse_list(i))
    # print(reverse_bond_list_list)
    bond_list = bonds_list_list + reverse_bond_list_list
    # print(bond_list)
    non_H_dihedral_bonds_list = []
    for i in non_H_dihedrals:
        non_H_dihedral_bonds_list.append(
            [[i[0], i[1]], [i[1], i[2]], [i[2], i[3]]]
        )
    # print(non_H_dihedral_bonds_list)
    bonded_index_to_include = []
    for i in range(len(non_H_dihedral_bonds_list)):
        if [
            non_H_dihedral_bonds_list[i][0] in bond_list,
            non_H_dihedral_bonds_list[i][1] in bond_list,
            non_H_dihedral_bonds_list[i][2] in bond_list,
        ] == [True, True, True]:
            bonded_index_to_include.append(i)
    # print(bonded_index_to_include)
    non_H_bonded_dihedrals = []
    for i in bonded_index_to_include:
        non_H_bonded_dihedrals.append(non_H_dihedrals[i])
    # print(non_H_bonded_dihedrals)
    non_H_bonded_atom_dihedral_list = []
    for sub_list in non_H_bonded_dihedrals:
        non_H_bonded_atom_dihedral_list.append(
            [
                df_index_symbol.loc[
                    df_index_symbol[&#34;atom_number&#34;] == sub_list[0]
                ][&#34;element_symbol&#34;].to_list()[0],
                df_index_symbol.loc[
                    df_index_symbol[&#34;atom_number&#34;] == sub_list[1]
                ][&#34;element_symbol&#34;].to_list()[0],
                df_index_symbol.loc[
                    df_index_symbol[&#34;atom_number&#34;] == sub_list[2]
                ][&#34;element_symbol&#34;].to_list()[0],
                df_index_symbol.loc[
                    df_index_symbol[&#34;atom_number&#34;] == sub_list[3]
                ][&#34;element_symbol&#34;].to_list()[0],
            ]
        )
    print(non_H_bonded_atom_dihedral_list)
    os.system(&#34;rm -rf &#34; + self.tor_dir)
    os.system(&#34;mkdir &#34; + self.tor_dir)
    parent_cwd = os.getcwd()
    shutil.copy(
        parent_cwd + &#34;/&#34; + self.psi_input_file,
        parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.psi_input_file,
    )
    shutil.copy(
        parent_cwd + &#34;/&#34; + self.template_pdb,
        parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.template_pdb,
    )
    shutil.copy(
        parent_cwd + &#34;/&#34; + self.torsion_drive_run_file,
        parent_cwd
        + &#34;/&#34;
        + self.tor_dir
        + &#34;/&#34;
        + self.torsion_drive_run_file,
    )
    os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir)
    torsion_drive_dir = os.getcwd()
    for i in range(len(non_H_bonded_dihedrals)):
        dir_name = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
        os.system(&#34;rm -rf &#34; + dir_name)
        os.system(&#34;mkdir &#34; + dir_name)
        os.chdir(torsion_drive_dir + &#34;/&#34; + dir_name)
        with open(self.dihedral_text_file, &#34;w&#34;) as f:
            f.write(
                &#34;# dihedral definition by atom indices starting from 1&#34;
                + &#34;\n&#34;
            )
            f.write(&#34;# i     j     k     l&#34; + &#34;\n&#34;)
            i_ = non_H_bonded_dihedrals[i][0]
            j_ = non_H_bonded_dihedrals[i][1]
            k_ = non_H_bonded_dihedrals[i][2]
            l_ = non_H_bonded_dihedrals[i][3]
            f.write(
                &#34; &#34;
                + &#34;{:&lt; 6d}&#34;.format(i_)
                + &#34;{:&lt; 6d}&#34;.format(j_)
                + &#34;{:&lt; 6d}&#34;.format(k_)
                + &#34;{:&lt; 6d}&#34;.format(l_)
                + &#34;\n&#34;
            )
            shutil.copy(
                torsion_drive_dir + &#34;/&#34; + self.psi_input_file,
                torsion_drive_dir
                + &#34;/&#34;
                + dir_name
                + &#34;/&#34;
                + self.psi_input_file,
            )
            shutil.copy(
                torsion_drive_dir + &#34;/&#34; + self.template_pdb,
                torsion_drive_dir
                + &#34;/&#34;
                + dir_name
                + &#34;/&#34;
                + self.template_pdb,
            )
            shutil.copy(
                torsion_drive_dir + &#34;/&#34; + self.torsion_drive_run_file,
                torsion_drive_dir
                + &#34;/&#34;
                + dir_name
                + &#34;/&#34;
                + self.torsion_drive_run_file,
            )
            os.chdir(torsion_drive_dir)
    os.system(&#34;rm -rf &#34; + self.psi_input_file)
    os.system(&#34;rm -rf &#34; + self.template_pdb)
    os.system(&#34;rm -rf &#34; + self.torsion_drive_run_file)
    os.chdir(parent_cwd)</code></pre>
</details>
</dd>
<dt id="parameterize.TorsionDriveSims.create_non_H_torsion_drive_dir"><code class="name flex">
<span>def <span class="ident">create_non_H_torsion_drive_dir</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a directory for carrying out torsiondrive
calculations for all non-hydrogen torsional angles.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_non_H_torsion_drive_dir(self):
    &#34;&#34;&#34;
    Creates a directory for carrying out torsiondrive 
    calculations for all non-hydrogen torsional angles. 
    &#34;&#34;&#34;
    df_tor = pd.read_csv(
        self.torsion_xml_file, header=None, delimiter=r&#34;\s+&#34;
    )
    df_tor.columns = [&#34;k&#34;, &#34;p1&#34;, &#34;p2&#34;, &#34;p3&#34;, &#34;p4&#34;, &#34;periodicity&#34;, &#34;phase&#34;]
    # print(df_tor.head())
    ppdb = PandasPdb()
    ppdb.read_pdb(self.template_pdb)
    df_index_symbol = ppdb.df[&#34;ATOM&#34;][[&#34;atom_number&#34;, &#34;element_symbol&#34;]]
    # print(df_index_symbol.head())
    df_dihedrals = df_tor[[&#34;p1&#34;, &#34;p2&#34;, &#34;p3&#34;, &#34;p4&#34;]]
    # print(df_dihedrals.head())
    dihedrals_list_list = []
    for i in range(len(df_dihedrals)):
        dihedrals_list_list.append(df_dihedrals.iloc[i].values.tolist())
    set_list = set()
    unique_dihedrals_list_list = []
    for x in dihedrals_list_list:
        srtd = tuple(sorted(x))
        if srtd not in set_list:
            unique_dihedrals_list_list.append(x)
            set_list.add(srtd)
    # print(unique_dihedrals_list_list)
    atom_dihedral_list = []
    for sub_list in unique_dihedrals_list_list:
        atom_dihedral_list.append(
            [
                df_index_symbol.loc[
                    df_index_symbol[&#34;atom_number&#34;] == sub_list[0]
                ][&#34;element_symbol&#34;].to_list()[0],
                df_index_symbol.loc[
                    df_index_symbol[&#34;atom_number&#34;] == sub_list[1]
                ][&#34;element_symbol&#34;].to_list()[0],
                df_index_symbol.loc[
                    df_index_symbol[&#34;atom_number&#34;] == sub_list[2]
                ][&#34;element_symbol&#34;].to_list()[0],
                df_index_symbol.loc[
                    df_index_symbol[&#34;atom_number&#34;] == sub_list[3]
                ][&#34;element_symbol&#34;].to_list()[0],
            ]
        )
    # print(atom_dihedral_list)
    index_to_include = []
    for i in range(len(atom_dihedral_list)):
        if &#34;H&#34; not in atom_dihedral_list[i]:
            index_to_include.append(i)
    non_H_dihedrals = []
    for i in index_to_include:
        non_H_dihedrals.append(unique_dihedrals_list_list[i])
    # print(non_H_dihedrals)
    non_H_atom_dihedral_list = []
    for sub_list in non_H_dihedrals:
        non_H_atom_dihedral_list.append(
            [
                df_index_symbol.loc[
                    df_index_symbol[&#34;atom_number&#34;] == sub_list[0]
                ][&#34;element_symbol&#34;].to_list()[0],
                df_index_symbol.loc[
                    df_index_symbol[&#34;atom_number&#34;] == sub_list[1]
                ][&#34;element_symbol&#34;].to_list()[0],
                df_index_symbol.loc[
                    df_index_symbol[&#34;atom_number&#34;] == sub_list[2]
                ][&#34;element_symbol&#34;].to_list()[0],
                df_index_symbol.loc[
                    df_index_symbol[&#34;atom_number&#34;] == sub_list[3]
                ][&#34;element_symbol&#34;].to_list()[0],
            ]
        )
    print(non_H_atom_dihedral_list)
    os.system(&#34;rm -rf &#34; + self.tor_dir)
    os.system(&#34;mkdir &#34; + self.tor_dir)
    parent_cwd = os.getcwd()
    shutil.copy(
        parent_cwd + &#34;/&#34; + self.psi_input_file,
        parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.psi_input_file,
    )
    shutil.copy(
        parent_cwd + &#34;/&#34; + self.template_pdb,
        parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.template_pdb,
    )
    shutil.copy(
        parent_cwd + &#34;/&#34; + self.torsion_drive_run_file,
        parent_cwd
        + &#34;/&#34;
        + self.tor_dir
        + &#34;/&#34;
        + self.torsion_drive_run_file,
    )
    os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir)
    torsion_drive_dir = os.getcwd()
    for i in range(len(non_H_dihedrals)):
        dir_name = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
        os.system(&#34;rm -rf &#34; + dir_name)
        os.system(&#34;mkdir &#34; + dir_name)
        os.chdir(torsion_drive_dir + &#34;/&#34; + dir_name)
        with open(self.dihedral_text_file, &#34;w&#34;) as f:
            f.write(
                &#34;# dihedral definition by atom indices starting from 1&#34;
                + &#34;\n&#34;
            )
            f.write(&#34;# i     j     k     l&#34; + &#34;\n&#34;)
            i_ = non_H_dihedrals[i][0]
            j_ = non_H_dihedrals[i][1]
            k_ = non_H_dihedrals[i][2]
            l_ = non_H_dihedrals[i][3]
            f.write(
                &#34; &#34;
                + &#34;{:&lt; 6d}&#34;.format(i_)
                + &#34;{:&lt; 6d}&#34;.format(j_)
                + &#34;{:&lt; 6d}&#34;.format(k_)
                + &#34;{:&lt; 6d}&#34;.format(l_)
                + &#34;\n&#34;
            )
            shutil.copy(
                torsion_drive_dir + &#34;/&#34; + self.psi_input_file,
                torsion_drive_dir
                + &#34;/&#34;
                + dir_name
                + &#34;/&#34;
                + self.psi_input_file,
            )
            shutil.copy(
                torsion_drive_dir + &#34;/&#34; + self.template_pdb,
                torsion_drive_dir
                + &#34;/&#34;
                + dir_name
                + &#34;/&#34;
                + self.template_pdb,
            )
            shutil.copy(
                torsion_drive_dir + &#34;/&#34; + self.torsion_drive_run_file,
                torsion_drive_dir
                + &#34;/&#34;
                + dir_name
                + &#34;/&#34;
                + self.torsion_drive_run_file,
            )
            os.chdir(torsion_drive_dir)
    os.system(&#34;rm -rf &#34; + self.psi_input_file)
    os.system(&#34;rm -rf &#34; + self.template_pdb)
    os.system(&#34;rm -rf &#34; + self.torsion_drive_run_file)
    os.chdir(parent_cwd)</code></pre>
</details>
</dd>
<dt id="parameterize.TorsionDriveSims.create_torsion_drive_dir"><code class="name flex">
<span>def <span class="ident">create_torsion_drive_dir</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a directory for carrying out torsiondrive
calculations for all the proper dihedral angles.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_torsion_drive_dir(self):
    &#34;&#34;&#34;
    Creates a directory for carrying out torsiondrive 
    calculations for all the proper dihedral angles. 
    &#34;&#34;&#34;
    df_tor = pd.read_csv(
        self.torsion_xml_file, header=None, delimiter=r&#34;\s+&#34;
    )
    df_tor.columns = [&#34;k&#34;, &#34;p1&#34;, &#34;p2&#34;, &#34;p3&#34;, &#34;p4&#34;, &#34;periodicity&#34;, &#34;phase&#34;]
    # print(df_tor.head())
    df_dihedrals = df_tor[[&#34;p1&#34;, &#34;p2&#34;, &#34;p3&#34;, &#34;p4&#34;]]
    # print(df_dihedrals.head())
    dihedrals_list_list = []
    for i in range(len(df_dihedrals)):
        dihedrals_list_list.append(df_dihedrals.iloc[i].values.tolist())
    set_list = set()
    unique_dihedrals_list_list = []
    for x in dihedrals_list_list:
        srtd = tuple(sorted(x))
        if srtd not in set_list:
            unique_dihedrals_list_list.append(x)
            set_list.add(srtd)
    # print(unique_dihedrals_list_list)
    os.system(&#34;rm -rf &#34; + self.tor_dir)
    os.system(&#34;mkdir &#34; + self.tor_dir)
    parent_cwd = os.getcwd()
    shutil.copy(
        parent_cwd + &#34;/&#34; + self.psi_input_file,
        parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.psi_input_file,
    )
    shutil.copy(
        parent_cwd + &#34;/&#34; + self.template_pdb,
        parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.template_pdb,
    )
    shutil.copy(
        parent_cwd + &#34;/&#34; + self.torsion_drive_run_file,
        parent_cwd
        + &#34;/&#34;
        + self.tor_dir
        + &#34;/&#34;
        + self.torsion_drive_run_file,
    )
    os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir)
    torsion_drive_dir = os.getcwd()
    for i in range(len(unique_dihedrals_list_list)):
        dir_name = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
        os.system(&#34;rm -rf &#34; + dir_name)
        os.system(&#34;mkdir &#34; + dir_name)
        os.chdir(torsion_drive_dir + &#34;/&#34; + dir_name)
        with open(self.dihedral_text_file, &#34;w&#34;) as f:
            f.write(
                &#34;# dihedral definition by atom indices starting from 1&#34;
                + &#34;\n&#34;
            )
            f.write(&#34;# i     j     k     l&#34; + &#34;\n&#34;)
            i_ = unique_dihedrals_list_list[i][0]
            j_ = unique_dihedrals_list_list[i][1]
            k_ = unique_dihedrals_list_list[i][2]
            l_ = unique_dihedrals_list_list[i][3]
            f.write(
                &#34; &#34;
                + &#34;{:&lt; 6d}&#34;.format(i_)
                + &#34;{:&lt; 6d}&#34;.format(j_)
                + &#34;{:&lt; 6d}&#34;.format(k_)
                + &#34;{:&lt; 6d}&#34;.format(l_)
                + &#34;\n&#34;
            )
            shutil.copy(
                torsion_drive_dir + &#34;/&#34; + self.psi_input_file,
                torsion_drive_dir
                + &#34;/&#34;
                + dir_name
                + &#34;/&#34;
                + self.psi_input_file,
            )
            shutil.copy(
                torsion_drive_dir + &#34;/&#34; + self.template_pdb,
                torsion_drive_dir
                + &#34;/&#34;
                + dir_name
                + &#34;/&#34;
                + self.template_pdb,
            )
            shutil.copy(
                torsion_drive_dir + &#34;/&#34; + self.torsion_drive_run_file,
                torsion_drive_dir
                + &#34;/&#34;
                + dir_name
                + &#34;/&#34;
                + self.torsion_drive_run_file,
            )
            os.chdir(torsion_drive_dir)
    os.system(&#34;rm -rf &#34; + self.psi_input_file)
    os.system(&#34;rm -rf &#34; + self.template_pdb)
    os.system(&#34;rm -rf &#34; + self.torsion_drive_run_file)
    os.chdir(parent_cwd)</code></pre>
</details>
</dd>
<dt id="parameterize.TorsionDriveSims.run_torsion_sim"><code class="name flex">
<span>def <span class="ident">run_torsion_sim</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run torsion scans using torsiondrive locally.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_torsion_sim(self):
    &#34;&#34;&#34;
    Run torsion scans using torsiondrive locally. \
    &#34;&#34;&#34;
    parent_cwd = os.getcwd()
    target_dir = parent_cwd + &#34;/&#34; + self.tor_dir
    num_folders = 0
    for _, dirnames, filenames in os.walk(target_dir):
        num_folders += len(dirnames)
    for i in range(num_folders):
        dir_ = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
        os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + dir_)
        run_command = &#34;bash&#34; + &#34; &#34; + self.torsion_drive_run_file
        # os.system(run_command)
        print(run_command)
        os.chdir(parent_cwd)</code></pre>
</details>
</dd>
<dt id="parameterize.TorsionDriveSims.write_psi4_input"><code class="name flex">
<span>def <span class="ident">write_psi4_input</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes a psi4 input QM file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_psi4_input(self):
    &#34;&#34;&#34; 
    Writes a psi4 input QM file.
    &#34;&#34;&#34;
    xyz_lines = open(self.xyz_file, &#34;r&#34;).readlines()[2:]
    with open(self.psi_input_file, &#34;w&#34;) as f:
        f.write(&#34;memory&#34; + &#34; &#34; + str(self.memory) + &#34; &#34; + &#34;GB&#34; + &#34;\n&#34;)
        f.write(&#34;molecule&#34; + &#34; &#34; + &#34;{&#34; + &#34;\n&#34;)
        f.write(str(self.charge) + &#34; &#34; + str(self.multiplicity) + &#34;\n&#34;)
        for line in xyz_lines:
            f.write(line)
        f.write(&#34;}&#34; + &#34;\n&#34;)
        f.write(&#34;set&#34; + &#34; &#34; + &#34;{&#34; + &#34;\n&#34;)
        f.write(&#34;basis&#34; + &#34; &#34; + self.basis_set + &#34;\n&#34;)
        if self.method_torsion_drive == &#34;native_opt&#34;:
            f.write(&#34;GEOM_MAXITER&#34; + &#34; &#34; + str(self.iterations) + &#34;\n&#34;)
        f.write(&#34;}&#34; + &#34;\n&#34;)
        if self.method_torsion_drive == &#34;native_opt&#34;:
            f.write(
                &#34;optimize&#34; + &#34;(&#34; + &#34;&#39;&#34; + self.functional + &#34;&#39;&#34; &#34;)&#34; + &#34;\n&#34;
            )
        if self.method_torsion_drive == &#34;geometric&#34;:
            f.write(
                &#34;gradient&#34; + &#34;(&#34; + &#34;&#39;&#34; + self.functional + &#34;&#39;&#34; &#34;)&#34; + &#34;\n&#34;
            )</code></pre>
</details>
</dd>
<dt id="parameterize.TorsionDriveSims.write_tor_params_txt"><code class="name flex">
<span>def <span class="ident">write_tor_params_txt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a text file containing torsional parameters from the reparameterized XML
force field file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_tor_params_txt(self):
    &#34;&#34;&#34;
    Saves a text file containing torsional parameters from the reparameterized XML 
    force field file.
    &#34;&#34;&#34;
    xml_off = open(self.reparameterised_system_xml_file, &#34;r&#34;)
    xml_off_lines = xml_off.readlines()
    for i in range(len(xml_off_lines)):
        if &#34;&lt;Torsions&gt;&#34; in xml_off_lines[i]:
            to_begin = int(i)
        if &#34;&lt;/Torsions&gt;&#34; in xml_off_lines[i]:
            to_end = int(i)
    torsion_params = xml_off_lines[to_begin + 1 : to_end]

    k_list_off = []
    for i in range(len(torsion_params)):
        k_list_off.append(
            float(re.findall(&#34;\d*\.?\d+&#34;, torsion_params[i])[0])
        )
    k_list_off = [round(num, 10) for num in k_list_off]
    # print(k_list_off)
    p1 = []
    for i in range(len(torsion_params)):
        p1.append(int(re.findall(&#34;\d*\.?\d+&#34;, torsion_params[i])[2]))
    p1 = [i + 1 for i in p1]
    # print(p1)
    p2 = []
    for i in range(len(torsion_params)):
        p2.append(int(re.findall(&#34;\d*\.?\d+&#34;, torsion_params[i])[4]))
    p2 = [i + 1 for i in p2]
    # print(p2)
    p3 = []
    for i in range(len(torsion_params)):
        p3.append(int(re.findall(&#34;\d*\.?\d+&#34;, torsion_params[i])[6]))
    p3 = [i + 1 for i in p3]
    # print(p3)
    p4 = []
    for i in range(len(torsion_params)):
        p4.append(int(re.findall(&#34;\d*\.?\d+&#34;, torsion_params[i])[8]))
    p4 = [i + 1 for i in p4]
    # print(p4)
    periodicity = []
    for i in range(len(torsion_params)):
        periodicity.append(
            int(re.findall(&#34;\d*\.?\d+&#34;, torsion_params[i])[9])
        )
    # print(periodicity)
    phase = []
    for i in range(len(torsion_params)):
        phase.append(float(re.findall(&#34;\d*\.?\d+&#34;, torsion_params[i])[10]))
    phase = [round(num, 8) for num in phase]
    # print(phase)
    data_tuples = list(zip(k_list_off, p1, p2, p3, p4, periodicity, phase))
    df_tor = pd.DataFrame(
        data_tuples,
        columns=[&#34;k&#34;, &#34;p1&#34;, &#34;p2&#34;, &#34;p3&#34;, &#34;p4&#34;, &#34;periodicity&#34;, &#34;phase&#34;],
    )
    # print(df_tor.head())
    df_tor.to_csv(
        self.torsion_xml_file, index=False, header=False, sep=&#34; &#34;
    )</code></pre>
</details>
</dd>
<dt id="parameterize.TorsionDriveSims.write_torsion_drive_run_file"><code class="name flex">
<span>def <span class="ident">write_torsion_drive_run_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves a bash file for running torsion scans for torsiondrive.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_torsion_drive_run_file(self):
    &#34;&#34;&#34;
    Saves a bash file for running torsion scans for torsiondrive. 
    &#34;&#34;&#34;
    if self.method_torsion_drive == &#34;geometric&#34;:
        torsion_command = (
            &#34;torsiondrive-launch&#34;
            + &#34; &#34;
            + self.psi_input_file
            + &#34; &#34;
            + self.dihedral_text_file
            + &#34; &#34;
            + &#34;-g&#34;
            + &#34; &#34;
            + str(self.dihedral_interval)
            + &#34; &#34;
            + &#34;-e&#34;
            + &#34; &#34;
            + self.engine
            + &#34; &#34;
            + &#34;--energy_thresh&#34;
            + &#34; &#34;
            + str(self.energy_threshold)
            + &#34; &#34;
            + &#34;-v&#34;
        )
    if self.method_torsion_drive == &#34;native_opt&#34;:
        torsion_command = (
            &#34;torsiondrive-launch&#34;
            + &#34; &#34;
            + self.psi_input_file
            + &#34; &#34;
            + self.dihedral_text_file
            + &#34; &#34;
            + &#34;-g&#34;
            + &#34; &#34;
            + str(self.dihedral_interval)
            + &#34; &#34;
            + &#34;-e&#34;
            + &#34; &#34;
            + self.engine
            + &#34; &#34;
            + &#34;--energy_thresh&#34;
            + &#34; &#34;
            + str(self.energy_threshold)
            + &#34; &#34;
            + &#34;--&#34;
            + self.method_torsion_drive
            + &#34; &#34;
            + &#34;-v&#34;
        )
    print(torsion_command)
    with open(self.torsion_drive_run_file, &#34;w&#34;) as f:
        f.write(torsion_command)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="parameterize.OPLS_LJ" href="#parameterize.OPLS_LJ">OPLS_LJ</a></code></li>
<li><code><a title="parameterize.copy_file" href="#parameterize.copy_file">copy_file</a></code></li>
<li><code><a title="parameterize.dihedral_energy" href="#parameterize.dihedral_energy">dihedral_energy</a></code></li>
<li><code><a title="parameterize.dot_product" href="#parameterize.dot_product">dot_product</a></code></li>
<li><code><a title="parameterize.error_function" href="#parameterize.error_function">error_function</a></code></li>
<li><code><a title="parameterize.error_function_boltzmann" href="#parameterize.error_function_boltzmann">error_function_boltzmann</a></code></li>
<li><code><a title="parameterize.fit_params" href="#parameterize.fit_params">fit_params</a></code></li>
<li><code><a title="parameterize.force_angle_constant" href="#parameterize.force_angle_constant">force_angle_constant</a></code></li>
<li><code><a title="parameterize.force_angle_constant_special_case" href="#parameterize.force_angle_constant_special_case">force_angle_constant_special_case</a></code></li>
<li><code><a title="parameterize.force_constant_bond" href="#parameterize.force_constant_bond">force_constant_bond</a></code></li>
<li><code><a title="parameterize.gen_init_guess" href="#parameterize.gen_init_guess">gen_init_guess</a></code></li>
<li><code><a title="parameterize.generate_mm_pdbs" href="#parameterize.generate_mm_pdbs">generate_mm_pdbs</a></code></li>
<li><code><a title="parameterize.generate_xml_from_charged_pdb_sdf" href="#parameterize.generate_xml_from_charged_pdb_sdf">generate_xml_from_charged_pdb_sdf</a></code></li>
<li><code><a title="parameterize.generate_xml_from_pdb_sdf" href="#parameterize.generate_xml_from_pdb_sdf">generate_xml_from_pdb_sdf</a></code></li>
<li><code><a title="parameterize.get_dihedrals" href="#parameterize.get_dihedrals">get_dihedrals</a></code></li>
<li><code><a title="parameterize.get_mm_potential_energies" href="#parameterize.get_mm_potential_energies">get_mm_potential_energies</a></code></li>
<li><code><a title="parameterize.get_non_torsion_mm_energy" href="#parameterize.get_non_torsion_mm_energy">get_non_torsion_mm_energy</a></code></li>
<li><code><a title="parameterize.get_qm_energies" href="#parameterize.get_qm_energies">get_qm_energies</a></code></li>
<li><code><a title="parameterize.get_tor_params" href="#parameterize.get_tor_params">get_tor_params</a></code></li>
<li><code><a title="parameterize.get_torsional_lines" href="#parameterize.get_torsional_lines">get_torsional_lines</a></code></li>
<li><code><a title="parameterize.list_diff" href="#parameterize.list_diff">list_diff</a></code></li>
<li><code><a title="parameterize.list_hartree_kcal" href="#parameterize.list_hartree_kcal">list_hartree_kcal</a></code></li>
<li><code><a title="parameterize.list_kJ_kcal" href="#parameterize.list_kJ_kcal">list_kJ_kcal</a></code></li>
<li><code><a title="parameterize.list_to_dict" href="#parameterize.list_to_dict">list_to_dict</a></code></li>
<li><code><a title="parameterize.objective_function" href="#parameterize.objective_function">objective_function</a></code></li>
<li><code><a title="parameterize.remove_mm_files" href="#parameterize.remove_mm_files">remove_mm_files</a></code></li>
<li><code><a title="parameterize.reverse_list" href="#parameterize.reverse_list">reverse_list</a></code></li>
<li><code><a title="parameterize.scale_list" href="#parameterize.scale_list">scale_list</a></code></li>
<li><code><a title="parameterize.search_in_file" href="#parameterize.search_in_file">search_in_file</a></code></li>
<li><code><a title="parameterize.torsiondrive_input_to_xyz" href="#parameterize.torsiondrive_input_to_xyz">torsiondrive_input_to_xyz</a></code></li>
<li><code><a title="parameterize.u_PA_from_angles" href="#parameterize.u_PA_from_angles">u_PA_from_angles</a></code></li>
<li><code><a title="parameterize.uniq" href="#parameterize.uniq">uniq</a></code></li>
<li><code><a title="parameterize.unit_vector_N" href="#parameterize.unit_vector_N">unit_vector_N</a></code></li>
<li><code><a title="parameterize.xyz_to_pdb" href="#parameterize.xyz_to_pdb">xyz_to_pdb</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="parameterize.GuestAmberXMLAmber" href="#parameterize.GuestAmberXMLAmber">GuestAmberXMLAmber</a></code></h4>
<ul class="">
<li><code><a title="parameterize.GuestAmberXMLAmber.analyze_diff_energies" href="#parameterize.GuestAmberXMLAmber.analyze_diff_energies">analyze_diff_energies</a></code></li>
<li><code><a title="parameterize.GuestAmberXMLAmber.generate_xml_antechamber" href="#parameterize.GuestAmberXMLAmber.generate_xml_antechamber">generate_xml_antechamber</a></code></li>
<li><code><a title="parameterize.GuestAmberXMLAmber.generate_xml_from_charged_pdb_sdf" href="#parameterize.GuestAmberXMLAmber.generate_xml_from_charged_pdb_sdf">generate_xml_from_charged_pdb_sdf</a></code></li>
<li><code><a title="parameterize.GuestAmberXMLAmber.generate_xml_from_doubly_charged_pdb_sdf" href="#parameterize.GuestAmberXMLAmber.generate_xml_from_doubly_charged_pdb_sdf">generate_xml_from_doubly_charged_pdb_sdf</a></code></li>
<li><code><a title="parameterize.GuestAmberXMLAmber.generate_xml_from_pdb_sdf" href="#parameterize.GuestAmberXMLAmber.generate_xml_from_pdb_sdf">generate_xml_from_pdb_sdf</a></code></li>
<li><code><a title="parameterize.GuestAmberXMLAmber.generate_xml_from_pdb_smi" href="#parameterize.GuestAmberXMLAmber.generate_xml_from_pdb_smi">generate_xml_from_pdb_smi</a></code></li>
<li><code><a title="parameterize.GuestAmberXMLAmber.save_amber_params" href="#parameterize.GuestAmberXMLAmber.save_amber_params">save_amber_params</a></code></li>
<li><code><a title="parameterize.GuestAmberXMLAmber.write_reparameterised_system_xml" href="#parameterize.GuestAmberXMLAmber.write_reparameterised_system_xml">write_reparameterised_system_xml</a></code></li>
<li><code><a title="parameterize.GuestAmberXMLAmber.write_system_params" href="#parameterize.GuestAmberXMLAmber.write_system_params">write_system_params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.HostAmberXMLAmber" href="#parameterize.HostAmberXMLAmber">HostAmberXMLAmber</a></code></h4>
<ul class="">
<li><code><a title="parameterize.HostAmberXMLAmber.analyze_diff_energies" href="#parameterize.HostAmberXMLAmber.analyze_diff_energies">analyze_diff_energies</a></code></li>
<li><code><a title="parameterize.HostAmberXMLAmber.save_amber_params" href="#parameterize.HostAmberXMLAmber.save_amber_params">save_amber_params</a></code></li>
<li><code><a title="parameterize.HostAmberXMLAmber.serialize_system" href="#parameterize.HostAmberXMLAmber.serialize_system">serialize_system</a></code></li>
<li><code><a title="parameterize.HostAmberXMLAmber.write_reparameterised_system_xml" href="#parameterize.HostAmberXMLAmber.write_reparameterised_system_xml">write_reparameterised_system_xml</a></code></li>
<li><code><a title="parameterize.HostAmberXMLAmber.write_system_params" href="#parameterize.HostAmberXMLAmber.write_system_params">write_system_params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.MergeHostGuestTopology" href="#parameterize.MergeHostGuestTopology">MergeHostGuestTopology</a></code></h4>
<ul class="">
<li><code><a title="parameterize.MergeHostGuestTopology.merge_topology_files" href="#parameterize.MergeHostGuestTopology.merge_topology_files">merge_topology_files</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.ParameterizeGuest" href="#parameterize.ParameterizeGuest">ParameterizeGuest</a></code></h4>
<ul class="">
<li><code><a title="parameterize.ParameterizeGuest.get_atom_names" href="#parameterize.ParameterizeGuest.get_atom_names">get_atom_names</a></code></li>
<li><code><a title="parameterize.ParameterizeGuest.get_bond_angle_params" href="#parameterize.ParameterizeGuest.get_bond_angle_params">get_bond_angle_params</a></code></li>
<li><code><a title="parameterize.ParameterizeGuest.get_bond_angles" href="#parameterize.ParameterizeGuest.get_bond_angles">get_bond_angles</a></code></li>
<li><code><a title="parameterize.ParameterizeGuest.get_charges" href="#parameterize.ParameterizeGuest.get_charges">get_charges</a></code></li>
<li><code><a title="parameterize.ParameterizeGuest.get_hessian" href="#parameterize.ParameterizeGuest.get_hessian">get_hessian</a></code></li>
<li><code><a title="parameterize.ParameterizeGuest.get_proper_dihedrals" href="#parameterize.ParameterizeGuest.get_proper_dihedrals">get_proper_dihedrals</a></code></li>
<li><code><a title="parameterize.ParameterizeGuest.get_unprocessed_hessian" href="#parameterize.ParameterizeGuest.get_unprocessed_hessian">get_unprocessed_hessian</a></code></li>
<li><code><a title="parameterize.ParameterizeGuest.get_xyz" href="#parameterize.ParameterizeGuest.get_xyz">get_xyz</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.ParameterizeHost" href="#parameterize.ParameterizeHost">ParameterizeHost</a></code></h4>
<ul class="">
<li><code><a title="parameterize.ParameterizeHost.get_atom_names" href="#parameterize.ParameterizeHost.get_atom_names">get_atom_names</a></code></li>
<li><code><a title="parameterize.ParameterizeHost.get_bond_angle_params" href="#parameterize.ParameterizeHost.get_bond_angle_params">get_bond_angle_params</a></code></li>
<li><code><a title="parameterize.ParameterizeHost.get_bond_angles" href="#parameterize.ParameterizeHost.get_bond_angles">get_bond_angles</a></code></li>
<li><code><a title="parameterize.ParameterizeHost.get_charges" href="#parameterize.ParameterizeHost.get_charges">get_charges</a></code></li>
<li><code><a title="parameterize.ParameterizeHost.get_hessian" href="#parameterize.ParameterizeHost.get_hessian">get_hessian</a></code></li>
<li><code><a title="parameterize.ParameterizeHost.get_unprocessed_hessian" href="#parameterize.ParameterizeHost.get_unprocessed_hessian">get_unprocessed_hessian</a></code></li>
<li><code><a title="parameterize.ParameterizeHost.get_xyz" href="#parameterize.ParameterizeHost.get_xyz">get_xyz</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.PrepareGaussianGuest" href="#parameterize.PrepareGaussianGuest">PrepareGaussianGuest</a></code></h4>
<ul class="">
<li><code><a title="parameterize.PrepareGaussianGuest.get_fchk" href="#parameterize.PrepareGaussianGuest.get_fchk">get_fchk</a></code></li>
<li><code><a title="parameterize.PrepareGaussianGuest.run_gaussian" href="#parameterize.PrepareGaussianGuest.run_gaussian">run_gaussian</a></code></li>
<li><code><a title="parameterize.PrepareGaussianGuest.write_input" href="#parameterize.PrepareGaussianGuest.write_input">write_input</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.PrepareGaussianHost" href="#parameterize.PrepareGaussianHost">PrepareGaussianHost</a></code></h4>
<ul class="">
<li><code><a title="parameterize.PrepareGaussianHost.get_fchk" href="#parameterize.PrepareGaussianHost.get_fchk">get_fchk</a></code></li>
<li><code><a title="parameterize.PrepareGaussianHost.run_gaussian" href="#parameterize.PrepareGaussianHost.run_gaussian">run_gaussian</a></code></li>
<li><code><a title="parameterize.PrepareGaussianHost.write_input" href="#parameterize.PrepareGaussianHost.write_input">write_input</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.PrepareGaussianHostGuest" href="#parameterize.PrepareGaussianHostGuest">PrepareGaussianHostGuest</a></code></h4>
<ul class="">
<li><code><a title="parameterize.PrepareGaussianHostGuest.get_fchk" href="#parameterize.PrepareGaussianHostGuest.get_fchk">get_fchk</a></code></li>
<li><code><a title="parameterize.PrepareGaussianHostGuest.get_qm_host_guest_charges" href="#parameterize.PrepareGaussianHostGuest.get_qm_host_guest_charges">get_qm_host_guest_charges</a></code></li>
<li><code><a title="parameterize.PrepareGaussianHostGuest.run_gaussian" href="#parameterize.PrepareGaussianHostGuest.run_gaussian">run_gaussian</a></code></li>
<li><code><a title="parameterize.PrepareGaussianHostGuest.write_input" href="#parameterize.PrepareGaussianHostGuest.write_input">write_input</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.PrepareQMMM" href="#parameterize.PrepareQMMM">PrepareQMMM</a></code></h4>
<ul class="">
<li><code><a title="parameterize.PrepareQMMM.clean_up" href="#parameterize.PrepareQMMM.clean_up">clean_up</a></code></li>
<li><code><a title="parameterize.PrepareQMMM.create_host_guest" href="#parameterize.PrepareQMMM.create_host_guest">create_host_guest</a></code></li>
<li><code><a title="parameterize.PrepareQMMM.get_guest_coord" href="#parameterize.PrepareQMMM.get_guest_coord">get_guest_coord</a></code></li>
<li><code><a title="parameterize.PrepareQMMM.get_host_mm_region_atoms" href="#parameterize.PrepareQMMM.get_host_mm_region_atoms">get_host_mm_region_atoms</a></code></li>
<li><code><a title="parameterize.PrepareQMMM.get_host_qm_mm_atoms" href="#parameterize.PrepareQMMM.get_host_qm_mm_atoms">get_host_qm_mm_atoms</a></code></li>
<li><code><a title="parameterize.PrepareQMMM.get_qm_mm_regions" href="#parameterize.PrepareQMMM.get_qm_mm_regions">get_qm_mm_regions</a></code></li>
<li><code><a title="parameterize.PrepareQMMM.get_qm_resids" href="#parameterize.PrepareQMMM.get_qm_resids">get_qm_resids</a></code></li>
<li><code><a title="parameterize.PrepareQMMM.realign_guest" href="#parameterize.PrepareQMMM.realign_guest">realign_guest</a></code></li>
<li><code><a title="parameterize.PrepareQMMM.save_host_mm_regions_pdbs" href="#parameterize.PrepareQMMM.save_host_mm_regions_pdbs">save_host_mm_regions_pdbs</a></code></li>
<li><code><a title="parameterize.PrepareQMMM.save_host_pdbs" href="#parameterize.PrepareQMMM.save_host_pdbs">save_host_pdbs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.RunOpenMMSims" href="#parameterize.RunOpenMMSims">RunOpenMMSims</a></code></h4>
<ul class="">
<li><code><a title="parameterize.RunOpenMMSims.run_openmm_prmtop_inpcrd" href="#parameterize.RunOpenMMSims.run_openmm_prmtop_inpcrd">run_openmm_prmtop_inpcrd</a></code></li>
<li><code><a title="parameterize.RunOpenMMSims.run_openmm_prmtop_pdb" href="#parameterize.RunOpenMMSims.run_openmm_prmtop_pdb">run_openmm_prmtop_pdb</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.TorsionDriveParams" href="#parameterize.TorsionDriveParams">TorsionDriveParams</a></code></h4>
<ul class="">
<li><code><a title="parameterize.TorsionDriveParams.write_reparams_torsion_lines" href="#parameterize.TorsionDriveParams.write_reparams_torsion_lines">write_reparams_torsion_lines</a></code></li>
<li><code><a title="parameterize.TorsionDriveParams.write_reparams_torsion_lines_charged" href="#parameterize.TorsionDriveParams.write_reparams_torsion_lines_charged">write_reparams_torsion_lines_charged</a></code></li>
<li><code><a title="parameterize.TorsionDriveParams.write_torsional_reparams" href="#parameterize.TorsionDriveParams.write_torsional_reparams">write_torsional_reparams</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.TorsionDriveSims" href="#parameterize.TorsionDriveSims">TorsionDriveSims</a></code></h4>
<ul class="">
<li><code><a title="parameterize.TorsionDriveSims.create_non_H_bonded_torsion_drive_dir" href="#parameterize.TorsionDriveSims.create_non_H_bonded_torsion_drive_dir">create_non_H_bonded_torsion_drive_dir</a></code></li>
<li><code><a title="parameterize.TorsionDriveSims.create_non_H_torsion_drive_dir" href="#parameterize.TorsionDriveSims.create_non_H_torsion_drive_dir">create_non_H_torsion_drive_dir</a></code></li>
<li><code><a title="parameterize.TorsionDriveSims.create_torsion_drive_dir" href="#parameterize.TorsionDriveSims.create_torsion_drive_dir">create_torsion_drive_dir</a></code></li>
<li><code><a title="parameterize.TorsionDriveSims.run_torsion_sim" href="#parameterize.TorsionDriveSims.run_torsion_sim">run_torsion_sim</a></code></li>
<li><code><a title="parameterize.TorsionDriveSims.write_psi4_input" href="#parameterize.TorsionDriveSims.write_psi4_input">write_psi4_input</a></code></li>
<li><code><a title="parameterize.TorsionDriveSims.write_tor_params_txt" href="#parameterize.TorsionDriveSims.write_tor_params_txt">write_tor_params_txt</a></code></li>
<li><code><a title="parameterize.TorsionDriveSims.write_torsion_drive_run_file" href="#parameterize.TorsionDriveSims.write_torsion_drive_run_file">write_torsion_drive_run_file</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>