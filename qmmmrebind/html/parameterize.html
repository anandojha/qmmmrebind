<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>parameterize API documentation</title>
<meta name="description" content="QMMMReBind : Quantum Mechanics – Molecular Mechanics ( *QMMM* ) forcefield *Re*paramaterisation of the *Bind*ing site for the receptor-ligand complexes" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>parameterize</code></h1>
</header>
<section id="section-intro">
<p>QMMMReBind : Quantum Mechanics – Molecular Mechanics ( <em>QMMM</em> ) forcefield <em>Re</em>paramaterisation of the <em>Bind</em>ing site for the receptor-ligand complexes</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
QMMMReBind : Quantum Mechanics – Molecular Mechanics ( *QMMM* ) forcefield *Re*paramaterisation of the *Bind*ing site for the receptor-ligand complexes
&#34;&#34;&#34;

import openforcefield.typing.engines.smirnoff
from biopandas.pdb import PandasPdb
import matplotlib.pyplot as plt
from operator import itemgetter
import openforcefield.topology
from mendeleev import element
from simtk.openmm import app
from scipy import optimize
import subprocess as sp
from sys import stdout
import openforcefield
import pandas as pd
import numpy as np
import statistics
import itertools
import parmed
import pickle
import shutil
import simtk
import scipy
import time
import math
import sys
import re
import os
####################################################################################################################################################################################
element_list = [[&#39;1 &#39;, &#39;H &#39;, &#39;Hydrogen&#39;], [&#39;2 &#39;, &#39;He&#39;, &#39;Helium&#39;], [&#39;3 &#39;, &#39;Li&#39;, &#39;Lithium&#39;], [&#39;4 &#39;, &#39;Be&#39;, &#39;Beryllium&#39;], [&#39;5 &#39;, &#39;B &#39;, &#39;Boron&#39;], [&#39;6 &#39;, &#39;C &#39;, &#39;Carbon&#39;], [&#39;7 &#39;, &#39;N &#39;, &#39;Nitrogen&#39;], [&#39;8 &#39;, &#39;O &#39;, &#39;Oxygen&#39;], [&#39;9 &#39;, &#39;F &#39;, &#39;Fluorine&#39;], [&#39;10&#39;, &#39;Ne&#39;, &#39;Neon&#39;], [&#39;11&#39;, &#39;Na&#39;, &#39;Sodium&#39;], [&#39;12&#39;, &#39;Mg&#39;, &#39;Magnesium&#39;], [&#39;13&#39;, &#39;Al&#39;, &#39;Aluminum&#39;], [&#39;14&#39;, &#39;Si&#39;, &#39;Silicon&#39;], [&#39;15&#39;, &#39;P &#39;, &#39;Phosphorus&#39;], [&#39;16&#39;, &#39;S &#39;, &#39;Sulfur&#39;], [&#39;17&#39;, &#39;Cl&#39;, &#39;Chlorine&#39;], [&#39;18&#39;, &#39;Ar&#39;, &#39;Argon&#39;], [&#39;19&#39;, &#39;K &#39;, &#39;Potassium&#39;], [&#39;20&#39;, &#39;Ca&#39;, &#39;Calcium&#39;], [&#39;21&#39;, &#39;Sc&#39;, &#39;Scandium&#39;], [&#39;22&#39;, &#39;Ti&#39;, &#39;Titanium&#39;], [&#39;23&#39;, &#39;V &#39;, &#39;Vanadium&#39;], [&#39;24&#39;, &#39;Cr&#39;, &#39;Chromium&#39;], [&#39;25&#39;, &#39;Mn&#39;, &#39;Manganese&#39;], [&#39;26&#39;, &#39;Fe&#39;, &#39;Iron&#39;], [&#39;27&#39;, &#39;Co&#39;, &#39;Cobalt&#39;], [&#39;28&#39;, &#39;Ni&#39;, &#39;Nickel&#39;], [&#39;29&#39;, &#39;Cu&#39;, &#39;Copper&#39;], [&#39;30&#39;, &#39;Zn&#39;, &#39;Zinc&#39;], [&#39;31&#39;, &#39;Ga&#39;, &#39;Gallium&#39;], [&#39;32&#39;, &#39;Ge&#39;, &#39;Germanium&#39;], [&#39;33&#39;, &#39;As&#39;, &#39;Arsenic&#39;], [&#39;34&#39;, &#39;Se&#39;, &#39;Selenium&#39;], [&#39;35&#39;, &#39;Br&#39;, &#39;Bromine&#39;], [&#39;36&#39;, &#39;Kr&#39;, &#39;Krypton&#39;], [&#39;37&#39;, &#39;Rb&#39;, &#39;Rubidium&#39;], [&#39;38&#39;, &#39;Sr&#39;, &#39;Strontium&#39;], [&#39;39&#39;, &#39;Y &#39;, &#39;Yttrium&#39;], [&#39;40&#39;, &#39;Zr&#39;, &#39;Zirconium&#39;], [&#39;41&#39;, &#39;Nb&#39;, &#39;Niobium&#39;], [&#39;42&#39;, &#39;Mo&#39;, &#39;Molybdenum&#39;], [&#39;43&#39;, &#39;Tc&#39;, &#39;Technetium&#39;], [&#39;44&#39;, &#39;Ru&#39;, &#39;Ruthenium&#39;], [&#39;45&#39;, &#39;Rh&#39;, &#39;Rhodium&#39;], [&#39;46&#39;, &#39;Pd&#39;, &#39;Palladium&#39;], [&#39;47&#39;, &#39;Ag&#39;, &#39;Silver&#39;], [&#39;48&#39;, &#39;Cd&#39;, &#39;Cadmium&#39;], [&#39;49&#39;, &#39;In&#39;, &#39;Indium&#39;], [&#39;50&#39;, &#39;Sn&#39;, &#39;Tin&#39;], [&#39;51&#39;, &#39;Sb&#39;, &#39;Antimony&#39;], [&#39;52&#39;, &#39;Te&#39;, &#39;Tellurium&#39;], [&#39;53&#39;, &#39;I &#39;, &#39;Iodine&#39;], [&#39;54&#39;, &#39;Xe&#39;, &#39;Xenon&#39;], [&#39;55&#39;, &#39;Cs&#39;, &#39;Cesium&#39;], [&#39;56&#39;, &#39;Ba&#39;, &#39;Barium&#39;], [&#39;57&#39;, &#39;La&#39;, &#39;Lanthanum&#39;], [&#39;58&#39;, &#39;Ce&#39;, &#39;Cerium&#39;], [&#39;59&#39;, &#39;Pr&#39;, &#39;Praseodymium&#39;], [&#39;60&#39;, &#39;Nd&#39;, &#39;Neodymium&#39;], [&#39;61&#39;, &#39;Pm&#39;, &#39;Promethium&#39;], [&#39;62&#39;, &#39;Sm&#39;, &#39;Samarium&#39;], [&#39;63&#39;, &#39;Eu&#39;, &#39;Europium&#39;], [&#39;64&#39;, &#39;Gd&#39;, &#39;Gadolinium&#39;], [&#39;65&#39;, &#39;Tb&#39;, &#39;Terbium&#39;], [&#39;66&#39;, &#39;Dy&#39;, &#39;Dysprosium&#39;], [&#39;67&#39;, &#39;Ho&#39;, &#39;Holmium&#39;], [&#39;68&#39;, &#39;Er&#39;, &#39;Erbium&#39;], [&#39;69&#39;, &#39;Tm&#39;, &#39;Thulium&#39;], [&#39;70&#39;, &#39;Yb&#39;, &#39;Ytterbium&#39;], [&#39;71&#39;, &#39;Lu&#39;, &#39;Lutetium&#39;], [&#39;72&#39;, &#39;Hf&#39;, &#39;Hafnium&#39;], [&#39;73&#39;, &#39;Ta&#39;, &#39;Tantalum&#39;], [&#39;74&#39;, &#39;W &#39;, &#39;Tungsten&#39;], [&#39;75&#39;, &#39;Re&#39;, &#39;Rhenium&#39;], [&#39;76&#39;, &#39;Os&#39;, &#39;Osmium&#39;], [&#39;77&#39;, &#39;Ir&#39;, &#39;Iridium&#39;], [&#39;78&#39;, &#39;Pt&#39;, &#39;Platinum&#39;], [&#39;79&#39;, &#39;Au&#39;, &#39;Gold&#39;], [&#39;80&#39;, &#39;Hg&#39;, &#39;Mercury&#39;], [&#39;81&#39;, &#39;Tl&#39;, &#39;Thallium&#39;], [&#39;82&#39;, &#39;Pb&#39;, &#39;Lead&#39;], [&#39;83&#39;, &#39;Bi&#39;, &#39;Bismuth&#39;], [&#39;84&#39;, &#39;Po&#39;, &#39;Polonium&#39;], [&#39;85&#39;, &#39;At&#39;, &#39;Astatine&#39;], [&#39;86&#39;, &#39;Rn&#39;, &#39;Radon&#39;], [&#39;87&#39;, &#39;Fr&#39;, &#39;Francium&#39;], [&#39;88&#39;, &#39;Ra&#39;, &#39;Radium&#39;], [&#39;89&#39;, &#39;Ac&#39;, &#39;Actinium&#39;], [&#39;90&#39;, &#39;Th&#39;, &#39;Thorium&#39;], [&#39;91&#39;, &#39;Pa&#39;, &#39;Protactinium&#39;], [&#39;92&#39;, &#39;U &#39;, &#39;Uranium&#39;], [&#39;93&#39;, &#39;Np&#39;, &#39;Neptunium&#39;], [&#39;94&#39;, &#39;Pu&#39;, &#39;Plutonium&#39;], [&#39;95&#39;, &#39;Am&#39;, &#39;Americium&#39;], [&#39;96&#39;, &#39;Cm&#39;, &#39;Curium&#39;], [&#39;97&#39;, &#39;Bk&#39;, &#39;Berkelium&#39;], [&#39;98&#39;, &#39;Cf&#39;, &#39;Californium&#39;], [&#39;99&#39;, &#39;Es&#39;, &#39;Einsteinium&#39;]]
####################################################################################################################################################################################
def unit_vector_N(u_BC, u_AB):
    # Calculates unit normal vector which is perpendicular to plane ABC
    cross_product = np.cross(u_BC, u_AB)
    norm_u_N = np.linalg.norm(cross_product)
    u_N = cross_product / norm_u_N
    return u_N
####################################################################################################################################################################################
def copy_file(source, destination):
    shutil.copy(source, destination)
####################################################################################################################################################################################
def  u_PA_from_angles(atom_A, atom_B, atom_C, coords):
    # Gives the vector in the plane A,B,C and perpendicular to A to B
    diff_AB = coords[atom_B,:] - coords[atom_A,:]
    norm_diff_AB = np.linalg.norm(diff_AB)
    u_AB = diff_AB / norm_diff_AB
    diff_CB = coords[atom_B,:] - coords[atom_C,:]
    norm_diff_CB = np.linalg.norm(diff_CB)
    u_CB = diff_CB / norm_diff_CB
    u_N = unit_vector_N( u_CB, u_AB )
    u_PA = np.cross(u_N,  u_AB)
    norm_PA = np.linalg.norm(u_PA)
    u_PA = u_PA /norm_PA;
    return u_PA
####################################################################################################################################################################################
def force_angle_constant( atom_A, atom_B, atom_C, bond_lengths, eigenvalues, eigenvectors, coords, scaling_1, scaling_2 ):
    # Force Constant- Equation 14 of seminario calculation paper - gives force constant for angle (in kcal/mol/rad^2) and equilibrium angle in degrees
    # Vectors along bonds calculated
    diff_AB = coords[atom_B,:] - coords[atom_A,:]
    norm_diff_AB = np.linalg.norm(diff_AB)
    u_AB = diff_AB / norm_diff_AB
    diff_CB = coords[atom_B,:] - coords[atom_C,:]
    norm_diff_CB = np.linalg.norm(diff_CB)
    u_CB = diff_CB / norm_diff_CB
    # Bond lengths and eigenvalues found
    bond_length_AB = bond_lengths[atom_A,atom_B]
    eigenvalues_AB = eigenvalues[atom_A, atom_B, :]
    eigenvectors_AB = eigenvectors[0:3, 0:3, atom_A, atom_B]
    bond_length_BC = bond_lengths[atom_B,atom_C]
    eigenvalues_CB = eigenvalues[atom_C, atom_B,  :]
    eigenvectors_CB = eigenvectors[0:3, 0:3, atom_C, atom_B]
    # Normal vector to angle plane found
    u_N = unit_vector_N( u_CB, u_AB )
    u_PA = np.cross(u_N,  u_AB)
    norm_u_PA = np.linalg.norm(u_PA)
    u_PA = u_PA / norm_u_PA
    u_PC = np.cross(u_CB, u_N)
    norm_u_PC = np.linalg.norm(u_PC)
    u_PC = u_PC / norm_u_PC
    sum_first = 0 
    sum_second = 0
    # Projections of eigenvalues
    for i in range(0,3):
        eig_AB_i = eigenvectors_AB[:,i]
        eig_BC_i = eigenvectors_CB[:,i]
        sum_first = sum_first + ( eigenvalues_AB[i] * abs(dot_product(u_PA , eig_AB_i) ) ) 
        sum_second = sum_second +  ( eigenvalues_CB[i] * abs(dot_product(u_PC, eig_BC_i) ) ) 
    # Scaling due to additional angles - Modified Seminario Part
    sum_first = sum_first/scaling_1 
    sum_second = sum_second/scaling_2
    # Added as two springs in series
    k_theta = ( 1 / ( (bond_length_AB**2) * sum_first) ) + ( 1 / ( (bond_length_BC**2) * sum_second) ) 
    k_theta = 1/k_theta
    k_theta = - k_theta #Change to OPLS form
    k_theta = abs(k_theta * 0.5) #Change to OPLS form
    # Equilibrium Angle
    theta_0 = math.degrees(math.acos(np.dot(u_AB, u_CB)))
    # If the vectors u_CB and u_AB are linearly dependent u_N cannot be defined
    # This case is dealt with here
    if abs(sum((u_CB) - (u_AB))) &lt; 0.01 or ( abs(sum((u_CB) - (u_AB))) &gt; 1.99 and abs(sum((u_CB) - (u_AB))) &lt; 2.01):
        scaling_1 = 1 
        scaling_2 = 1
        [ k_theta, theta_0 ] = force_angle_constant_special_case( atom_A, atom_B, atom_C, bond_lengths, eigenvalues, eigenvectors, coords, scaling_1, scaling_2 )
    return k_theta, theta_0
####################################################################################################################################################################################
def dot_product(u_PA , eig_AB):
    x = 0     
    for i in range(0,3):
        x = x + u_PA[i] * eig_AB[i].conjugate()
    return x 
####################################################################################################################################################################################
def force_angle_constant_special_case( atom_A, atom_B, atom_C, bond_lengths, eigenvalues, eigenvectors, coords, scaling_1, scaling_2 ):
    # Force Constant- Equation 14 of seminario calculation paper - gives force constant for angle (in kcal/mol/rad^2) and equilibrium angle in degrees
    # Deals with cases when u_N cannot be defined and instead takes samples of u_N across a unit sphere. 
    # Vectors along bonds calculated
    diff_AB = coords[atom_B,:] - coords[atom_A,:]
    norm_diff_AB = np.linalg.norm(diff_AB)
    u_AB = diff_AB / norm_diff_AB
    diff_CB = coords[atom_B,:] - coords[atom_C,:]
    norm_diff_CB = np.linalg.norm(diff_CB)
    u_CB = diff_CB / norm_diff_CB
    # Bond lengths and eigenvalues found
    bond_length_AB = bond_lengths[atom_A,atom_B]
    eigenvalues_AB = eigenvalues[atom_A, atom_B, :]
    eigenvectors_AB = eigenvectors[0:3, 0:3, atom_A, atom_B]
    bond_length_BC = bond_lengths[atom_B,atom_C]
    eigenvalues_CB = eigenvalues[atom_C, atom_B,  :]
    eigenvectors_CB = eigenvectors[0:3, 0:3, atom_C, atom_B]
    k_theta_array = np.zeros((180, 360))
    # Find force constant with varying u_N (with vector uniformly sampled across a sphere)
    for theta in range(0,180):
        for phi in range(0,360):   
            r = 1
            u_N = [r * math.sin(math.radians(theta))*math.cos(math.radians(theta)),r * math.sin(math.radians(theta))*math.sin(math.radians(theta)), r*math.cos(math.radians(theta)) ]
            u_PA = np.cross(u_N,  u_AB)
            u_PA = u_PA / np.linalg.norm(u_PA)
            u_PC = np.cross(u_CB, u_N)
            u_PC = u_PC / np.linalg.norm(u_PC)
            sum_first = 0
            sum_second = 0
            # Projections of eigenvalues
            for i in range(0,3):
                eig_AB_i = eigenvectors_AB[:,i]
                eig_BC_i = eigenvectors_CB[:,i]
                sum_first = sum_first + ( eigenvalues_AB[i] * abs(dot_product(u_PA , eig_AB_i) ) ) 
                sum_second = sum_second +  ( eigenvalues_CB[i] * abs(dot_product(u_PC, eig_BC_i) ) ) 
            # Added as two springs in series
            k_theta_ij = ( 1 / ( (bond_length_AB**2) * sum_first) ) + ( 1 / ( (bond_length_BC**2) * sum_second) ) 
            k_theta_ij = 1/k_theta_ij
            k_theta_ij = - k_theta_ij #Change to OPLS form
            k_theta_ij = abs(k_theta_ij * 0.5) #Change to OPLS form
            k_theta_array[theta, phi] = k_theta_ij
    # Removes cases where u_N was linearly dependent of u_CB or u_AB
    # Force constant used is taken as the mean
    k_theta = np.mean(np.mean(k_theta_array))
    # Equilibrium Angle independent of u_N
    theta_0 = math.degrees(math.cos(np.dot(u_AB, u_CB)))
    return k_theta, theta_0
####################################################################################################################################################################################
def force_constant_bond(atom_A, atom_B, eigenvalues, eigenvectors, coords):
    # Force Constant - Equation 10 of Seminario paper - gives force constant for bond
    # Eigenvalues and eigenvectors calculated 
    eigenvalues_AB = eigenvalues[atom_A,atom_B,:]
    eigenvectors_AB = eigenvectors[:,:,atom_A,atom_B]
    # Vector along bond 
    diff_AB = np.array(coords[atom_B,:]) - np.array(coords[atom_A,:])
    norm_diff_AB = np.linalg.norm(diff_AB)
    unit_vectors_AB = diff_AB / norm_diff_AB
    k_AB = 0 
    # Projections of eigenvalues 
    for i in range(0,3):
        dot_product = abs(np.dot(unit_vectors_AB, eigenvectors_AB[:,i]))
        k_AB = k_AB + ( eigenvalues_AB[i] * dot_product )
    k_AB = -k_AB * 0.5 # Convert to OPLS form
    return k_AB
####################################################################################################################################################################################
def  u_PA_from_angles(atom_A, atom_B, atom_C, coords):
    # Gives the vector in the plane A,B,C and perpendicular to A to B
    diff_AB = coords[atom_B,:] - coords[atom_A,:]
    norm_diff_AB = np.linalg.norm(diff_AB)
    u_AB = diff_AB / norm_diff_AB
    diff_CB = coords[atom_B,:] - coords[atom_C,:]
    norm_diff_CB = np.linalg.norm(diff_CB)
    u_CB = diff_CB / norm_diff_CB
    u_N = unit_vector_N( u_CB, u_AB )
    u_PA = np.cross(u_N,  u_AB)
    norm_PA = np.linalg.norm(u_PA)
    u_PA = u_PA /norm_PA;
    return u_PA
####################################################################################################################################################################################
def reverse_list(lst): 
    reversed_list = lst[::-1] 
    return (reversed_list)
####################################################################################################################################################################################
def uniq(input_):
    output = []
    for x in input_:
        if x not in output:
            output.append(x)
    return output
####################################################################################################################################################################################
def search_in_file(file: str, word: str) -&gt; list:
    &#34;&#34;&#34;Search for the given string in file and return lines containing that string along with line numbers&#34;&#34;&#34;
    line_number = 0
    list_of_results = []
    with open(file, &#39;r&#39;) as f:
        for line in f:
            line_number += 1
            if word in line:
                list_of_results.append((line_number, line.rstrip()))
    return(list_of_results)
####################################################################################################################################################################################
def OPLS_LJ(system):
    forces = {system.getForce(index).__class__.__name__: system.getForce(index) for index in range(system.getNumForces())}
    nonbonded_force = forces[&#39;NonbondedForce&#39;]
    lorentz = simtk.openmm.openmm.CustomNonbondedForce(&#39;4*epsilon*((sigma/r)^12-(sigma/r)^6); sigma=sqrt(sigma1*sigma2); epsilon=sqrt(epsilon1*epsilon2)&#39;)
    lorentz.setNonbondedMethod(nonbonded_force.getNonbondedMethod())
    lorentz.addPerParticleParameter(&#39;sigma&#39;)
    lorentz.addPerParticleParameter(&#39;epsilon&#39;)
    lorentz.setCutoffDistance(nonbonded_force.getCutoffDistance())
    system.addForce(lorentz)
    LJset = {}
    for index in range(nonbonded_force.getNumParticles()):
        charge, sigma, epsilon = nonbonded_force.getParticleParameters(index)
        LJset[index] = (sigma, epsilon)
        lorentz.addParticle([sigma, epsilon])
        nonbonded_force.setParticleParameters(index, charge, sigma, epsilon * 0)
    for i in range(nonbonded_force.getNumExceptions()):
        (p1, p2, q, sig, eps) = nonbonded_force.getExceptionParameters(i)
        lorentz.addExclusion(p1, p2)
        if eps._value != 0.0:
            #print (p1,p2,sig,eps)
            sig14 = math.sqrt(LJset[p1][0].value_in_unit(simtk.unit.nanometer) * LJset[p2][0].value_in_unit(simtk.unit.nanometer))
            eps14 = math.sqrt(LJset[p1][1].value_in_unit(simtk.unit.kilojoule/simtk.unit.mole) * LJset[p2][1].value_in_unit(simtk.unit.kilojoule/simtk.unit.mole))
            nonbonded_force.setExceptionParameters(i, p1, p2, q, sig14, eps)
    return (system)
####################################################################################################################################################################################
def list_to_dict(lst):
    res_dct = {lst[i]: lst[i + 1] for i in range(0, len(lst), 2)}
    return (res_dct)
####################################################################################################################################################################################
def scale_list(list_):
    scaled_list = [i - min(list_) for i in list_]
    return (scaled_list)
####################################################################################################################################################################################
def list_kJ_kcal(list_):
    converted_list = [i / 4.184 for i in list_]
    return (converted_list)
####################################################################################################################################################################################
def list_hartree_kcal(list_):
    converted_list = [i * 627.5094 for i in list_]
    return (converted_list)
####################################################################################################################################################################################
def torsiondrive_input_to_xyz(psi_input_file, xyz_file): 
    with open (psi_input_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;molecule {&#34; in lines[i]:
            to_begin = int(i)   
        if &#34;set {&#34; in lines[i]:
            to_end = int(i)  
    xyz_lines = lines[to_begin + 2 : to_end - 1]
    with open(xyz_file, &#39;w&#39;) as f:
        f.write(str(len(xyz_lines)) + &#34;\n&#34;)
        f.write(xyz_file + &#34;\n&#34;)
        for i in xyz_lines:
            f.write(i)
####################################################################################################################################################################################
def xyz_to_pdb(xyz_file, coords_file, template_pdb, system_pdb):
    with open (xyz_file, &#34;r&#34;) as f:
        lines = f.readlines()
    needed_lines = lines[2:]
    with open(coords_file, &#39;w&#39;) as f:
        for i in needed_lines:
            f.write(i)
    df = pd.read_csv(coords_file, header = None, delimiter = r&#34;\s+&#34;)
    df.columns = [&#34;atom&#34;, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;]
    ppdb = PandasPdb()
    ppdb.read_pdb(template_pdb)
    ppdb.df[&#34;ATOM&#34;][&#34;x_coord&#34;] = df[&#34;x&#34;]
    ppdb.df[&#34;ATOM&#34;][&#34;y_coord&#34;] = df[&#34;y&#34;]
    ppdb.df[&#34;ATOM&#34;][&#34;z_coord&#34;] = df[&#34;z&#34;]  
    ppdb.to_pdb(system_pdb)  
####################################################################################################################################################################################
def generate_xml_from_pdb_sdf(system_pdb, system_sdf, system_xml):
    &#34;&#34;&#34;
    This function generates an openforcefield xml file from the pdb file
    &#34;&#34;&#34;
    command = &#34;babel -ipdb &#34; + system_pdb + &#34; -osdf &#34; + system_sdf
    os.system(command)
    off_molecule = openforcefield.topology.Molecule(system_sdf)
    force_field = openforcefield.typing.engines.smirnoff.ForceField(&#39;openff_unconstrained-1.0.0.offxml&#39;)
    system = force_field.create_openmm_system(off_molecule.to_topology())
    pdbfile = simtk.openmm.app.PDBFile(system_pdb)
    structure = parmed.openmm.load_topology(pdbfile.topology, system, xyz = pdbfile.positions)
    with open(system_xml, &#39;w&#39;) as f:
        f.write(simtk.openmm.XmlSerializer.serialize(system)) 
####################################################################################################################################################################################        
def generate_xml_from_charged_pdb_sdf(system_pdb, system_init_sdf, system_sdf, num_charge_atoms, index_charge_atom_1, charge_atom_1, system_xml):
    &#34;&#34;&#34;
    This function generates an openforcefield xml file from the pdb file via SDF file and openforcefield.
    &#34;&#34;&#34;
    command = &#34;babel -ipdb &#34; + system_pdb + &#34; -osdf &#34; + system_init_sdf
    os.system(command)
    with open(system_init_sdf, &#39;r&#39;) as f1 :
        filedata = f1.readlines()
        filedata = filedata[:-2]
    with open(system_sdf, &#34;w+&#34;) as out:
        for i in filedata:
            out.write(i)
        line_1 = &#34;M  CHG  &#34; + str(num_charge_atoms) + &#34;   &#34; + str(index_charge_atom_1)   + &#34;   &#34; + str(charge_atom_1) + &#34;\n&#34; 
        line_2 = &#34;M  END&#34; + &#34;\n&#34;
        line_3 = &#34;$$$$&#34;
        out.write(line_1)
        out.write(line_2)
        out.write(line_3)
    off_molecule = openforcefield.topology.Molecule(system_sdf)
    force_field = openforcefield.typing.engines.smirnoff.ForceField(&#39;openff_unconstrained-1.0.0.offxml&#39;)
    system = force_field.create_openmm_system(off_molecule.to_topology())
    pdbfile = simtk.openmm.app.PDBFile(system_pdb)
    structure = parmed.openmm.load_topology(pdbfile.topology, system, xyz = pdbfile.positions)
    with open(system_xml, &#39;w&#39;) as f:
        f.write(simtk.openmm.XmlSerializer.serialize(system)) 
####################################################################################################################################################################################
def get_dihedrals(qm_scan_file):
    with open(qm_scan_file, &#34;r&#34;) as f:
        lines = f.readlines()
    energy_dihedral_lines = []
    for i in range(len(lines)):
        if &#34;Dihedral&#34; in lines[i]:
            energy_dihedral_lines.append(lines[i])
    dihedrals = []
    for i in energy_dihedral_lines:
        energy_dihedral = i
        energy_dihedral = re.findall(r&#39;[-+]?\d+[.]?\d*&#39;, energy_dihedral)
        dihedral = float(energy_dihedral[0])
        dihedrals.append(dihedral)
    return(dihedrals)
####################################################################################################################################################################################
def get_qm_energies(qm_scan_file):
    with open(qm_scan_file, &#34;r&#34;) as f:
        lines = f.readlines()
    energy_dihedral_lines = []
    for i in range(len(lines)):
        if &#34;Dihedral&#34; in lines[i]:
            energy_dihedral_lines.append(lines[i])
    qm_energies = []
    for i in energy_dihedral_lines:
        energy_dihedral = i 
        energy_dihedral = re.findall(r&#39;[-+]?\d+[.]?\d*&#39;, energy_dihedral)
        energy = float(energy_dihedral[1])
        qm_energies.append(energy)
    return(qm_energies)
####################################################################################################################################################################################
def generate_mm_pdbs(qm_scan_file, template_pdb):
    with open (qm_scan_file, &#34;r&#34;) as f:
        lines = f.readlines()
    energy_dihedral_lines = []
    for i in range(len(lines)):
        if &#34;Dihedral&#34; in lines[i]:
            energy_dihedral_lines.append(lines[i])
    dihedrals = []
    for i in energy_dihedral_lines:
        energy_dihedral = i 
        energy_dihedral = re.findall(r&#39;[-+]?\d+[.]?\d*&#39;, energy_dihedral)
        dihedral = float(energy_dihedral[0])
        dihedrals.append(dihedral)
    lines_markers = []
    for i in range(len(lines)):
        if &#34;Dihedral&#34; in lines[i]:
            lines_markers.append(i)
    lines_markers.append(len(lines) + 1)
    for i in range(len(lines_markers) - 1):
        #pdb_file_to_write = str(dihedrals[i]) + &#34;.pdb&#34;
        if dihedrals[i] &gt; 0 :
            pdb_file_to_write = &#34;plus_&#34; + str(abs(dihedrals[i])) + &#34;.pdb&#34;
        if dihedrals[i] &lt; 0 :
            pdb_file_to_write = &#34;minus_&#34; + str(abs(dihedrals[i])) + &#34;.pdb&#34;        
        to_begin = lines_markers[i]
        to_end = lines_markers[i+1]
        lines_to_write = lines[to_begin + 1:to_end - 1]
        x_coords = []
        y_coords = []
        z_coords = []
        for i in lines_to_write:
            coordinates = i 
            coordinates = re.findall(r&#39;[-+]?\d+[.]?\d*&#39;, coordinates)
            x = float(coordinates[0])
            y = float(coordinates[1])
            z = float(coordinates[2])
            x_coords.append(x)
            y_coords.append(y)
            z_coords.append(z)
        ppdb = PandasPdb()
        ppdb.read_pdb(template_pdb)
        ppdb.df[&#34;ATOM&#34;][&#34;x_coord&#34;] = x_coords
        ppdb.df[&#34;ATOM&#34;][&#34;y_coord&#34;] = y_coords
        ppdb.df[&#34;ATOM&#34;][&#34;z_coord&#34;] = z_coords    
        ppdb.to_pdb(pdb_file_to_write)  
####################################################################################################################################################################################
def remove_mm_files(qm_scan_file):
    mm_pdb_list = []
    for i in get_dihedrals(qm_scan_file):
        if i &gt; 0 :
            pdb_file = &#34;plus_&#34; + str(abs(i)) + &#34;.pdb&#34;
        if i &lt; 0 :
            pdb_file = &#34;minus_&#34; + str(abs(i)) + &#34;.pdb&#34;  
        mm_pdb_list.append(pdb_file)
    for i in mm_pdb_list:
        command = &#34;rm -rf  &#34; + i 
        os.system(command) 
        command = &#34;rm -rf  &#34; + i[:-4] + &#34;.inpcrd&#34;
        os.system(command) 
        command = &#34;rm -rf  &#34; + i[:-4] + &#34;.prmtop&#34;
        os.system(command) 
####################################################################################################################################################################################
def get_non_torsion_mm_energy(system_pdb, load_topology, system_xml):
    system_prmtop = system_pdb[:-4] + &#34;.prmtop&#34;
    system_inpcrd = system_pdb[:-4] + &#34;.inpcrd&#34;
    if load_topology == &#34;parmed&#34;:
        openmm_system = parmed.openmm.load_topology(parmed.load_file(system_pdb, structure=True).topology, parmed.load_file(system_xml))
    if load_topology == &#34;openmm&#34;:
        openmm_system = parmed.openmm.load_topology(simtk.openmm.app.PDBFile(system_pdb).topology, parmed.load_file(system_xml))
    openmm_system.save(system_prmtop, overwrite=True)
    openmm_system.coordinates = parmed.load_file(system_pdb, structure=True).coordinates
    openmm_system.save(system_inpcrd, overwrite=True)
    parm = parmed.load_file(system_prmtop, system_inpcrd)
    prmtop_energy_decomposition = parmed.openmm.energy_decomposition_system(parm, parm.createSystem())
    #print(prmtop_energy_decomposition)
    prmtop_energy_decomposition_value_no_torsion =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                                     list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                                     list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
    return(sum(prmtop_energy_decomposition_value_no_torsion))    
####################################################################################################################################################################################
def get_mm_potential_energies(qm_scan_file, load_topology, system_xml):
    mm_pdb_list = []
    for i in get_dihedrals(qm_scan_file):
        if i &gt; 0 :
            pdb_file = &#34;plus_&#34; + str(abs(i)) + &#34;.pdb&#34;
        if i &lt; 0 :
            pdb_file = &#34;minus_&#34; + str(abs(i)) + &#34;.pdb&#34;  
        mm_pdb_list.append(pdb_file)
    for i in mm_pdb_list:
        mm_pdb_file = i
    mm_potential_energies = []
    for i in mm_pdb_list:
        mm_pdb_file = i
        mm_energy = get_non_torsion_mm_energy(system_pdb = i, load_topology = load_topology, system_xml = system_xml)
        mm_potential_energies.append(mm_energy)
    return(mm_potential_energies)
####################################################################################################################################################################################
def list_diff(list_1, list_2):
    diff_list = []
    zipped_list = zip(list_1, list_2)
    for list1_i, list2_i in zipped_list:
        diff_list.append(list1_i-list2_i)
    return(diff_list)
####################################################################################################################################################################################
def dihedral_energy (x, k1, k2, k3, k4 = 0):
    energy_1 = k1 * (1 + np.cos (1 * x * 0.01745))
    energy_2 = k2 * (1 - np.cos (2 * x * 0.01745))
    energy_3 = k3 * (1 + np.cos (3 * x * 0.01745))
    energy_4 = k4 * (1 - np.cos (4 * x *0.01745))
    dihedral_energy = energy_1 + energy_2 + energy_3 + energy_4
    return (dihedral_energy)
####################################################################################################################################################################################
def error_function(delta_qm, delta_mm):
    squared_error = np.square(np.subtract(delta_qm, delta_mm))
    mean_squared_error = squared_error.mean()
    root_mean_squared_error = math.sqrt(mean_squared_error)
    return (root_mean_squared_error)
####################################################################################################################################################################################
def error_function_boltzmann(delta_qm, delta_mm, T):
    kb = 3.297623483* 10**(-24) # in cal/K
    delta_qm_boltzmann_weighted = [np.exp(-i / (kb * T)) for i in delta_qm]
    squared_error = np.square(np.subtract(delta_qm, delta_mm)) * delta_qm_boltzmann_weighted
    mean_squared_error = squared_error.mean()
    root_mean_squared_error = math.sqrt(mean_squared_error)
    return (root_mean_squared_error)
####################################################################################################################################################################################
def gen_init_guess(qm_scan_file, load_topology, system_xml):
    x = get_dihedrals(qm_scan_file)
    y  = scale_list(list_ = get_mm_potential_energies(qm_scan_file = qm_scan_file, load_topology = load_topology, system_xml = system_xml))
    init_vals = [0.0, 0.0, 0.0, 0.0]
    k_init_guess, covar = scipy.optimize.curve_fit(dihedral_energy, x, y, p0 = init_vals)
    for i in range(len(k_init_guess)):
        if k_init_guess[i] &lt; 0:
            k_init_guess[i] = 0
    return(k_init_guess)
####################################################################################################################################################################################
def objective_function(k_array, x, delta_qm):
    delta_mm = dihedral_energy(x, k1 = k_array[0], k2 = k_array[1], k3 = k_array[2],  k4 = k_array[3])    
    loss_function = error_function(delta_qm, delta_mm)
    return(loss_function)
####################################################################################################################################################################################
def fit_params(qm_scan_file, load_topology, system_xml, method):
    k_guess = gen_init_guess(qm_scan_file = qm_scan_file, load_topology = load_topology, system_xml = system_xml)
    x_data = np.array(get_dihedrals(qm_scan_file))
    delta_qm = np.array(scale_list(list_hartree_kcal(list_ = get_qm_energies(qm_scan_file)))) 
    optimise = scipy.optimize.minimize(objective_function, k_guess, args=(x_data,delta_qm), method = method, bounds = [(0.00, None), (0.00, None), (0.00, None), (0.00, None)])
    return(optimise.x)
####################################################################################################################################################################################
def get_tor_params(qm_scan_file, template_pdb, load_topology, system_xml, method):
    qm_e = get_qm_energies(qm_scan_file = qm_scan_file)
    qm_e_kcal = list_hartree_kcal(qm_e)
    delta_qm = scale_list(qm_e_kcal)
    generate_mm_pdbs(qm_scan_file = qm_scan_file, template_pdb = template_pdb)
    mm_pe_no_torsion_kcal = get_mm_potential_energies(qm_scan_file = qm_scan_file, load_topology = load_topology, system_xml = system_xml)
    delta_mm = scale_list(mm_pe_no_torsion_kcal)  
    opt_param = fit_params(qm_scan_file = qm_scan_file, load_topology = load_topology, system_xml = system_xml, method = method)
    return(opt_param)
####################################################################################################################################################################################
def get_torsional_lines(template_pdb, system_xml, qm_scan_file, load_topology, method, dihedral_text_file):
    opt_param = get_tor_params(qm_scan_file = qm_scan_file, template_pdb = template_pdb, load_topology = load_topology, system_xml = system_xml, method = method)
    dihedral_text = open(dihedral_text_file, &#39;r&#39;)
    dihedral_text_lines = dihedral_text.readlines()
    atom_numbers = dihedral_text_lines[-1]
    atom_index_from_1 = [int(re.findall(r&#39;\d+&#39;, atom_numbers)[0]), int(re.findall(r&#39;\d+&#39;, atom_numbers)[1]), int(re.findall(r&#39;\d+&#39;, atom_numbers)[2]), int(re.findall(r&#39;\d+&#39;, atom_numbers)[3])]
    atom_index = [i -1 for i in atom_index_from_1]
    atom_index_lines = &#34; &#34; + &#34;p1=&#34; + &#39;&#34;&#39; + str(atom_index[0]) + &#39;&#34;&#39; + &#34; &#34; +  &#34;p2=&#34; + &#39;&#34;&#39; + str(atom_index[1]) + &#39;&#34;&#39; + &#34; &#34; +  &#34;p3=&#34; + &#39;&#34;&#39; + str(atom_index[2]) + &#39;&#34;&#39; + &#34; &#34; +  &#34;p4=&#34; + &#39;&#34;&#39; + str(atom_index[3]) + &#39;&#34;&#39; + &#34; &#34;  
    tor_lines = []
    for i in range(len(opt_param)):
        line_to_append = &#34;                &#34; + &#34;&lt;Torsion &#34; + &#34;k=&#34; + &#39;&#34;&#39; + str(round(opt_param[i], 8)) + &#39;&#34;&#39; + atom_index_lines + &#34;periodicity=&#34; + &#39;&#34;&#39; + str(i+1) + &#39;&#34;&#39; + &#34; &#34; + &#34;phase=&#34; + &#39;&#34;&#39; + &#34;0&#34; + &#39;&#34;&#39; + &#34;/&gt;&#34;
        #print(line_to_append)
        tor_lines.append(line_to_append)
    return(tor_lines)
####################################################################################################################################################################################
class PrepareQMMM:
 
    def __init__(self, init_pdb, distance, num_residues, guest_resname, cleaned_pdb = &#34;system.pdb&#34;, guest_init_pdb = &#34;guest_init.pdb&#34;, host_pdb = &#34;host.pdb&#34;, guest_pdb = &#34;guest_init_II.pdb&#34;, guest_xyz = &#34;guest_coord.txt&#34;, residue_list = &#34;residue_list.txt&#34;, host_qm_atoms = &#34;host_qm.txt&#34;, host_mm_atoms = &#34;host_mm.txt&#34;, host_qm_pdb = &#34;host_qm.pdb&#34;, host_mm_pdb = &#34;host_mm.pdb&#34;, qm_pdb = &#34;qm.pdb&#34;, mm_pdb = &#34;mm.pdb&#34;, host_mm_region_I_atoms = &#34;host_mm_region_I.txt&#34;, host_mm_region_II_atoms = &#34;host_mm_region_II.txt&#34;, host_mm_region_I_pdb = &#34;host_mm_region_I.pdb&#34;, host_mm_region_II_pdb = &#34;host_mm_region_II.pdb&#34;):
        self.init_pdb = init_pdb
        self.distance = distance
        self.num_residues = num_residues
        self.guest_resname = guest_resname
        self.cleaned_pdb = cleaned_pdb
        self.guest_init_pdb = guest_init_pdb
        self.host_pdb = host_pdb
        self.guest_pdb = guest_pdb
        self.guest_xyz  = guest_xyz
        self.residue_list = residue_list
        self.host_qm_atoms = host_qm_atoms
        self.host_mm_atoms = host_mm_atoms
        self.host_qm_pdb = host_qm_pdb
        self.host_mm_pdb = host_mm_pdb
        self.qm_pdb = qm_pdb
        self.mm_pdb = mm_pdb
        self.host_mm_region_I_atoms = host_mm_region_I_atoms
        self.host_mm_region_II_atoms = host_mm_region_II_atoms
        self.host_mm_region_I_pdb = host_mm_region_I_pdb
        self.host_mm_region_II_pdb = host_mm_region_II_pdb

    def clean_up(self):   
        &#34;&#34;&#34;
        This function removes everything from the initial pdb file except the host and guest molecules from the system and saves a pdb file.
        &#34;&#34;&#34;
        ions = [&#34;Na+&#34;, &#34;Cs+&#34;, &#34;K+&#34;,&#34;Li+&#34;, &#34;Rb+&#34;, &#34;Cl-&#34;, &#34;Br-&#34;, &#34;F-&#34;, &#34;I-&#34;, &#34;Ca2&#34;]
        intermediate_file_1 = self.cleaned_pdb[:-4] + &#34;_intermediate_1.pdb&#34;
        intermediate_file_2 = self.cleaned_pdb[:-4] + &#34;_intermediate_2.pdb&#34;
        command = &#34;pdb4amber -i &#34; + self.init_pdb + &#34; -o &#34; + intermediate_file_1 + &#34; --noter --dry&#34;
        os.system(command)
        to_delete = intermediate_file_1[:-4] + &#34;_nonprot.pdb&#34; , intermediate_file_1[:-4] + &#34;_renum.txt&#34;, intermediate_file_1[:-4] + &#34;_sslink&#34;, intermediate_file_1[:-4] + &#34;_water.pdb&#34;   
        os.system(&#34;rm -rf &#34; + to_delete[0] + &#34; &#34; + to_delete[1] + &#34; &#34; + to_delete[2] + &#34; &#34; + to_delete[3])  
        with open(intermediate_file_1) as f1, open(intermediate_file_2, &#39;w&#39;) as f2:
            for line in f1:
                if not any(ion in line for ion in ions):
                    f2.write(line)                
        with open(intermediate_file_2, &#39;r&#39;) as f1 :
            filedata = f1.read()
        filedata = filedata.replace(&#39;HETATM&#39;, &#39;ATOM  &#39;)
        with open(self.cleaned_pdb, &#39;w&#39;) as f2:
            f2.write(filedata)
        command = &#34;rm -rf &#34; + intermediate_file_1 + &#34; &#34; + intermediate_file_2
        os.system(command)
    
    def create_host_guest(self):   
        &#34;&#34;&#34;
        This function creates separate host and guest pdb files.
        &#34;&#34;&#34;
        with open(self.cleaned_pdb) as f1, open(self.host_pdb, &#39;w&#39;) as f2:
            for line in f1:
                if not self.guest_resname in line and not &#34;CRYST1&#34; in line:
                    f2.write(line)           
        with open(self.cleaned_pdb) as f1, open(self.guest_init_pdb, &#39;w&#39;) as f2:
            for line in f1:
                if self.guest_resname in line or &#34;END&#34; in line:
                    f2.write(line)
                    
    def realign_guest(self):   
        &#34;&#34;&#34;
        This function realigns the atom numbers in the initial guest pdb file given the assumption that the original pdb file had the host molecule followed by the guest molecule.
        &#34;&#34;&#34;
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_init_pdb)
        to_substract = min(ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;]) - 1 
        ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] - to_substract
        intermediate_file_1 = self.guest_pdb[:-4] + &#34;_intermediate_1.pdb&#34;
        intermediate_file_2 = self.guest_pdb[:-4] + &#34;_intermediate_2.pdb&#34;
        ppdb.to_pdb(path = intermediate_file_1)
        command = &#34;pdb4amber -i &#34; + intermediate_file_1 +  &#34; -o &#34; + intermediate_file_2
        os.system(command)
        to_delete = intermediate_file_2[:-4] + &#34;_nonprot.pdb&#34; , intermediate_file_2[:-4] + &#34;_renum.txt&#34;, intermediate_file_2[:-4] + &#34;_sslink&#34;
        os.system(&#34;rm -rf &#34; + to_delete[0] + &#34; &#34; + to_delete[1] + &#34; &#34; + to_delete[2])  
        with open(intermediate_file_2, &#39;r&#39;) as f1 :
            filedata = f1.read()
        filedata = filedata.replace(&#39;HETATM&#39;, &#39;ATOM  &#39;)
        with open(self.guest_pdb, &#39;w&#39;) as f2:
            f2.write(filedata)
        command = &#34;rm -rf &#34; + intermediate_file_1 + &#34; &#34; + intermediate_file_2
        os.system(command)
        
    def get_guest_coord(self):   
        &#34;&#34;&#34;
        This function saves a list of xyz coordinates from the pdb file.
        &#34;&#34;&#34;
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_pdb)
        xyz = ppdb.df[&#39;ATOM&#39;][[&#34;x_coord&#34;,&#34;y_coord&#34;,&#34;z_coord&#34;]]
        xyz_to_list = xyz.values.tolist()
        np.savetxt(self.guest_xyz, xyz_to_list)
        
    def get_qm_resids(self):  
        &#34;&#34;&#34;
        This function saves a list of residue numbers of the residues in the host molecule surrounding the guest within a mentioned distance from any of the atom in the guest molecule.
        &#34;&#34;&#34;
        guest_coord_list = np.loadtxt(self.guest_xyz)
        host_atom_list = []
        for i in range(len(guest_coord_list)):
            reference_point = guest_coord_list[i]
            ppdb = PandasPdb()
            ppdb.read_pdb(self.host_pdb)
            distances = ppdb.distance(xyz=reference_point, records=(&#39;ATOM&#39;))
            all_within_distance = ppdb.df[&#39;ATOM&#39;][distances &lt; float(self.distance)]
            host_df = all_within_distance[&#34;atom_number&#34;]
            host_list = host_df.values.tolist()
            host_atom_list.append(host_list)
        host_atom_list = list(itertools.chain(*host_atom_list))
        host_atom_list = set(host_atom_list)
        host_atom_list = list(host_atom_list)
        host_atom_list.sort() 
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        df = ppdb.df[&#39;ATOM&#39;][[&#39;atom_number&#39;,&#39;residue_number&#39;,&#39;residue_name&#39;]]
        index_list = []
        for i in host_atom_list:
            indices = np.where(df[&#34;atom_number&#34;] == i)
            indices = list(indices)[0]
            indices = list(indices)
            index_list.append(indices)
        index_list = list(itertools.chain.from_iterable(index_list))
        df1 = df.iloc[index_list,] 
        resid_num = list(df1.residue_number.unique())
        np.savetxt(self.residue_list, resid_num)
        
    def get_host_qm_mm_atoms(self):  
        &#34;&#34;&#34;
        This function saves a list of atom numbers of the residues in the host molecule surrounding the guest within a certain mentioned distance from any of the atom in the guest molecule.
        &#34;&#34;&#34;
        resid_num = np.loadtxt(self.residue_list)
        #approximated_res_list = [int(i) for i in resid_num]
        approximated_res_list = []
        for i in range(int(statistics.median(resid_num)) - int(int(self.num_residues)/2), int(statistics.median(resid_num)) + int(int(self.num_residues)/2)):
            approximated_res_list.append(i)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        df = ppdb.df[&#39;ATOM&#39;][[&#39;atom_number&#39;,&#39;residue_number&#39;,&#39;residue_name&#39;]]
        host_index_nested_list = []
        for i in approximated_res_list:
            indices = np.where(df[&#34;residue_number&#34;] == i)
            indices = list(indices)[0]
            indices = list(indices)
            host_index_nested_list.append(indices)  
        host_index_list = list(itertools.chain.from_iterable(host_index_nested_list))
        df_atom = df.iloc[host_index_list] 
        df_atom_number = df_atom[&#39;atom_number&#39;]
        host_atom_list = df_atom_number.values.tolist()
        selected_atoms = []
        selected_atoms.extend(host_atom_list)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        len_atoms = []
        for i in range(len(ppdb.df[&#39;ATOM&#39;])):
            len_atoms.append(i+1)
        non_selected_atoms = list(set(len_atoms).difference(selected_atoms))
        if len(non_selected_atoms) + len(selected_atoms) == len(len_atoms):
            print(&#34;Sum of the selected and non-selected region equals the length of list of total atoms&#34;)
        else:
            print(&#34;Error&#34;)
        np.savetxt(self.host_qm_atoms, selected_atoms)  
        np.savetxt(self.host_mm_atoms, non_selected_atoms) 
        
    def save_host_pdbs(self):  
        &#34;&#34;&#34;
        This function saves a host pdb file of selected region and another host pdb file non-selected region. 
        &#34;&#34;&#34;
        selected_atoms = np.loadtxt(self.host_qm_atoms)
        selected_atoms = [int(i) for i in selected_atoms]
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        for i in selected_atoms:
            ppdb.df[&#39;ATOM&#39;] = ppdb.df[&#39;ATOM&#39;][ppdb.df[&#39;ATOM&#39;][&#39;atom_number&#39;] != i]
        ppdb.to_pdb(path = self.host_mm_pdb, records = None, gz = False, append_newline = True)
        non_selected_atoms = np.loadtxt(self.host_mm_atoms)
        non_selected_atoms = [int(i) for i in non_selected_atoms]
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        for i in non_selected_atoms:
            ppdb.df[&#39;ATOM&#39;] = ppdb.df[&#39;ATOM&#39;][ppdb.df[&#39;ATOM&#39;][&#39;atom_number&#39;] != i]
        ppdb.to_pdb(path = self.host_qm_pdb, records = None, gz = False, append_newline = True)

    def get_host_mm_region_atoms(self):  
        &#34;&#34;&#34;
        This function divides the host MM region into two sections, i.e. one preceding the QM region and one successing the QM region.
        &#34;&#34;&#34;
        resid_num = np.loadtxt(self.residue_list)
        approximated_res_list = []
        for i in range(int(statistics.median(resid_num)) - int(int(self.num_residues)/2), int(statistics.median(resid_num)) + int(int(self.num_residues)/2)):
            approximated_res_list.append(i)
        #print(approximated_res_list)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        df = ppdb.df[&#39;ATOM&#39;][[&#39;residue_number&#39;]]
        res_list = list(set(df[&#39;residue_number&#39;].to_list()))
        res_mm_list = list(set(res_list).difference(approximated_res_list))
        #print(res_mm_list)
        res_mm_region_I_list = []
        for i in res_mm_list:
            for j in approximated_res_list:
                if i &lt; j:
                    res_mm_region_I_list.append(i)
        res_mm_region_I_list = list(set(res_mm_region_I_list))
        #print(res_mm_region_I_list)
        res_mm_region_II_list = list(set(res_mm_list).difference(res_mm_region_I_list))
        #print(res_mm_region_II_list)
        ppdb.read_pdb(self.host_mm_pdb)
        df = ppdb.df[&#39;ATOM&#39;][[&#39;atom_number&#39;,&#39;residue_number&#39;,&#39;residue_name&#39;]]
        mm_region_I_index_nested_list = []
        for i in res_mm_region_I_list:
            indices = np.where(df[&#34;residue_number&#34;] == i)
            indices = list(indices)[0]
            indices = list(indices)
            mm_region_I_index_nested_list.append(indices)  
        mm_region_I_index_list = list(itertools.chain.from_iterable(mm_region_I_index_nested_list))
        df_atom = df.iloc[mm_region_I_index_list] 
        df_atom_number = df_atom[&#39;atom_number&#39;]
        mm_region_I_atom_list = df_atom_number.values.tolist()
        mm_region_I_atoms = []
        mm_region_I_atoms.extend(mm_region_I_atom_list)
        mm_region_II_index_nested_list = []
        for i in res_mm_region_II_list:
            indices = np.where(df[&#34;residue_number&#34;] == i)
            indices = list(indices)[0]
            indices = list(indices)
            mm_region_II_index_nested_list.append(indices)  
        mm_region_II_index_list = list(itertools.chain.from_iterable(mm_region_II_index_nested_list))
        df_atom = df.iloc[mm_region_II_index_list] 
        df_atom_number = df_atom[&#39;atom_number&#39;]
        mm_region_II_atom_list = df_atom_number.values.tolist()
        mm_region_II_atoms = []
        mm_region_II_atoms.extend(mm_region_II_atom_list)
        ppdb.read_pdb(self.host_mm_pdb)
        len_atoms = []
        for i in range(len(ppdb.df[&#39;ATOM&#39;])):
            len_atoms.append(i+1)
        if len(mm_region_I_atoms) + len(mm_region_II_atoms) == len(len_atoms):
            print(&#34;Sum of the MM region I atoms and  MM region II atoms equals the length of list of total MM atoms&#34;)
        else:
            print(&#34;Error&#34;)
        np.savetxt(self.host_mm_region_I_atoms, mm_region_I_atoms)  
        np.savetxt(self.host_mm_region_II_atoms, mm_region_II_atoms) 

    def save_host_mm_regions_pdbs(self):  
        &#34;&#34;&#34;
        This function saves two pdb files, one pdb preceding the QM region and one pdb file succeeding the QM region.
        &#34;&#34;&#34;
        mm_region_I_atoms = np.loadtxt(self.host_mm_region_I_atoms)
        mm_region_I_atoms = [int(i) for i in mm_region_I_atoms]
        mm_region_II_atoms = np.loadtxt(self.host_mm_region_II_atoms)
        mm_region_II_atoms = [int(i) for i in mm_region_II_atoms]
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_mm_pdb)
        for i in mm_region_II_atoms:
            ppdb.df[&#39;ATOM&#39;] = ppdb.df[&#39;ATOM&#39;][ppdb.df[&#39;ATOM&#39;][&#39;atom_number&#39;] != i]
        ppdb.to_pdb(path = self.host_mm_region_I_pdb, records = None, gz = False, append_newline = True)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_mm_pdb)
        for i in mm_region_I_atoms:
            ppdb.df[&#39;ATOM&#39;] = ppdb.df[&#39;ATOM&#39;][ppdb.df[&#39;ATOM&#39;][&#39;atom_number&#39;] != i]
        ppdb.to_pdb(path = self.host_mm_region_II_pdb, records = None, gz = False, append_newline = True)        
        
    def get_qm_mm_regions(self):  
        &#34;&#34;&#34;
        This function saves a qm region comprising of the guest molecule and the selected atoms of the host molecule and a mm region comprising of the unselected atoms of the host molecule. When merging two pdb files, all lines beginning from &#34;ATOM&#34; will be selected and it would end with the &#34;END&#34;
        &#34;&#34;&#34;
        with open(self.host_qm_pdb) as f1, open(self.qm_pdb, &#39;w&#39;) as f2:
            for line in f1:
                if &#34;ATOM&#34; in line:
                    f2.write(line)  
        with open(self.guest_pdb) as f1, open(self.qm_pdb, &#39;a&#39;) as f2:
            for line in f1:
                if &#34;ATOM&#34; in line:
                    f2.write(line) 
        with open(self.qm_pdb, &#39;a&#39;) as f:
            f.write(&#34;END&#34;)
        with open(self.host_mm_pdb) as f1, open(self.mm_pdb, &#39;w&#39;) as f2:
            for line in f1:
                if &#34;ATOM&#34; in line:
                    f2.write(line)  
        with open(self.mm_pdb, &#39;a&#39;) as f:
            f.write(&#34;END&#34;)  

####################################################################################################################################################################################
class PrepareGaussianGuest:
    
    def __init__(self, charge, multiplicity, guest_pdb = &#34;guest_init_II.pdb&#34;, n_processors = 12, memory = 50, functional = &#34;B3LYP&#34;, basis_set = &#34;6-31G&#34;, optimisation = &#34;OPT&#34;, frequency = &#34;FREQ&#34;, add_keywords_I = &#34;Integral=(Grid=UltraFine)&#34;, add_keywords_II = &#34;Pop(MK,ReadRadii)&#34;, add_keywords_III = &#34;IOp(6/33=2,6/42=6)&#34;, gauss_out_file = &#34;guest.out&#34;, fchk_out_file = &#34;guest_fchk.out&#34;):
        self.charge = charge
        self.multiplicity = multiplicity
        self.guest_pdb = guest_pdb
        self.n_processors = n_processors
        self.memory = memory
        self.functional = functional
        self.basis_set  = basis_set
        self.optimisation = optimisation
        self.frequency = frequency
        self.gauss_out_file = gauss_out_file
        self.fchk_out_file = fchk_out_file
        self.add_keywords_I = add_keywords_I
        self.add_keywords_II = add_keywords_II
        self.add_keywords_III = add_keywords_III
        
    def write_input(self):   
        &#34;&#34;&#34;
        This function prints out the commands section of the gaussian input file.
        &#34;&#34;&#34;
        command_line_1 = &#34;%Chk = &#34; + self.guest_pdb[:-4] + &#34;.chk&#34; 
        command_line_2 = &#34;%Mem = &#34; + str(self.memory) + &#34;GB&#34;
        command_line_3 = &#34;%NProcShared = &#34; + str(self.n_processors)
        command_line_4 = &#34;# &#34; + self.functional + &#34; &#34; + self.basis_set + &#34; &#34; + self.optimisation + &#34; &#34; + self.frequency + &#34; &#34; + self.add_keywords_I + &#34; &#34; + self.add_keywords_II + &#34; &#34; + self.add_keywords_III
        command_line_5 = &#34; &#34;
        command_line_6 = self.guest_pdb[:-4] + &#34; &#34;  + &#34;gaussian input file&#34;
        command_line_7 = &#34; &#34;
        command_line_8 = str(self.charge) + &#34; &#34;  + str(self.multiplicity)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_pdb)
        df = ppdb.df[&#39;ATOM&#39;]
        df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
        df_1.columns = [&#39;atom&#39;]
        df_2 = df[[&#39;x_coord&#39;, &#39;y_coord&#39;, &#39;z_coord&#39;]]
        df_merged = pd.concat([df_1, df_2], axis=1)
        command_line_9 = df_merged.to_string(header = False, index = False)
        command_line_10 = &#34; &#34;
        command = [command_line_1, command_line_2, command_line_3, command_line_4, 
                   command_line_5, command_line_6, command_line_7, command_line_8, 
                   command_line_9, command_line_10]
        commands = &#39;\n&#39;.join(command)
        with open(self.guest_pdb[:-4] + &#34;.com&#34;, &#34;w&#34;) as f:
            f.write(commands)
            
    def run_gaussian(self):   
        &#34;&#34;&#34;
        This function runs the gaussian QM calculation.
        &#34;&#34;&#34;
        execute_command = &#34;g16&#34; + &#34; &lt; &#34; + self.guest_pdb[:-4] + &#34;.com&#34;  + &#34; &gt; &#34;  + self.guest_pdb[:-4] + &#34;.log&#34; 
        with open(self.gauss_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell = True, stdout = f, stderr = sp.STDOUT)
        
    def get_fchk(self):   
        &#34;&#34;&#34;
        This function converts the checkpoint file file into the formatted chechkpoint file.
        &#34;&#34;&#34;
        execute_command = &#34;formchk&#34;+ &#34; &#34; + self.guest_pdb[:-4] + &#34;.chk&#34; + &#34; &#34; + self.guest_pdb[:-4] + &#34;.fchk&#34;
        with open(self.fchk_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell = True, stdout = f, stderr = sp.STDOUT)
####################################################################################################################################################################################
class PrepareGaussianHostGuest:

    def __init__(self, charge, multiplicity, guest_pdb = &#34;guest_init_II.pdb&#34;, host_qm_pdb = &#34;host_qm.pdb&#34;, n_processors = 12, memory = 50, functional = &#34;B3LYP&#34;, basis_set = &#34;6-31G&#34;, optimisation = &#34;&#34;, frequency = &#34;&#34;, add_keywords_I = &#34;Integral=(Grid=UltraFine)&#34;, add_keywords_II = &#34;Pop(MK,ReadRadii)&#34;, add_keywords_III = &#34;IOp(6/33=2,6/42=6)&#34;, gauss_system_out_file = &#34;system_qm.out&#34;, fchk_system_out_file = &#34;system_qm_fchk.out&#34;, host_guest_input = &#34;host_guest.com&#34;, qm_guest_charge_parameter_file = &#34;guest_qm_surround_charges.txt&#34;, qm_host_charge_parameter_file = &#34;host_qm_surround_charges.txt&#34;, qm_guest_atom_charge_parameter_file = &#34;guest_qm_atom_surround_charges.txt&#34;):
        self.charge = charge
        self.multiplicity = multiplicity
        self.guest_pdb = guest_pdb
        self.host_qm_pdb = host_qm_pdb
        self.n_processors = n_processors
        self.memory = memory
        self.functional = functional
        self.basis_set  = basis_set
        self.optimisation = optimisation
        self.frequency = frequency
        self.add_keywords_I = add_keywords_I
        self.add_keywords_II = add_keywords_II
        self.add_keywords_III = add_keywords_III
        self.gauss_system_out_file = gauss_system_out_file
        self.fchk_system_out_file = fchk_system_out_file
        self.host_guest_input = host_guest_input
        self.qm_guest_charge_parameter_file = qm_guest_charge_parameter_file
        self.qm_host_charge_parameter_file = qm_host_charge_parameter_file
        self.qm_guest_atom_charge_parameter_file = qm_guest_atom_charge_parameter_file
        
    def write_input(self):   
        &#34;&#34;&#34;
        This function prints out the commands section of the gaussian input file.
        &#34;&#34;&#34;
        command_line_1 = &#34;%Chk = &#34; + self.host_guest_input[:-4] + &#34;.chk&#34; 
        command_line_2 = &#34;%Mem = &#34; + str(self.memory) + &#34;GB&#34;
        command_line_3 = &#34;%NProcShared = &#34; + str(self.n_processors)
        command_line_4 = &#34;# &#34; + self.functional + &#34; &#34; + self.basis_set + &#34; &#34; + self.optimisation + &#34; &#34; + self.frequency + &#34; &#34; + self.add_keywords_I + &#34; &#34; + self.add_keywords_II + &#34; &#34; + self.add_keywords_III
        command_line_5 = &#34; &#34;
        command_line_6 = &#34;Gaussian Input File&#34;
        command_line_7 = &#34; &#34;
        command_line_8 = str(self.charge) + &#34; &#34;  + str(self.multiplicity)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_pdb)
        df = ppdb.df[&#39;ATOM&#39;]
        df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
        df_1.columns = [&#39;atom&#39;]
        df_3 = df[[&#39;x_coord&#39;, &#39;y_coord&#39;, &#39;z_coord&#39;]]
        df_2 = pd.Series([&#34;0&#34;] * len(df), name=&#39;decide_freeze&#39;) 
        df_merged_1 = pd.concat([df_1, df_2, df_3], axis=1)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_qm_pdb)
        df = ppdb.df[&#39;ATOM&#39;]
        df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
        df_1.columns = [&#39;atom&#39;]
        df_3 = df[[&#39;x_coord&#39;, &#39;y_coord&#39;, &#39;z_coord&#39;]]
        df_2 = pd.Series([&#34;0&#34;] * len(df), name=&#39;decide_freeze&#39;) 
        df_merged_2 = pd.concat([df_1, df_2, df_3], axis=1)    
        df_merged = pd.concat([df_merged_1, df_merged_2], axis=0)
        command_line_9 = df_merged.to_string(header = False, index = False)
        command_line_10 = &#34; &#34;
        command = [command_line_1, command_line_2, command_line_3, command_line_4, 
                   command_line_5, command_line_6, command_line_7, command_line_8, 
                   command_line_9, command_line_10]
        commands = &#39;\n&#39;.join(command)
       
        with open(self.host_guest_input, &#34;w&#34;) as f:
            f.write(commands)
           
    def run_gaussian(self):   
        &#34;&#34;&#34;
        This function runs the gaussian QM calculation.
        &#34;&#34;&#34;
        execute_command = &#34;g16&#34; + &#34; &lt; &#34; + self.host_guest_input + &#34; &gt; &#34;  + self.host_guest_input[:-4] + &#34;.log&#34; 
        with open(self.gauss_system_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell = True, stdout = f, stderr = sp.STDOUT)
            
    def get_fchk(self):   
        &#34;&#34;&#34;
        This function converts the checkpoint file file into the formatted chechkpoint file.
        &#34;&#34;&#34;
        execute_command = &#34;formchk&#34;+ &#34; &#34; + self.host_guest_input[:-4] + &#34;.chk&#34; + &#34; &#34; + self.host_guest_input[:-4] + &#34;.fchk&#34;
        with open(self.fchk_system_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell = True, stdout = f, stderr = sp.STDOUT)

    def get_qm_host_guest_charges(self):
        &#34;&#34;&#34;This function extracts charges and saves them separately for the host and guest&#34;&#34;&#34;
        log_file = self.host_guest_input[:-4] + &#34;.log&#34;
        with open (log_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Fitting point charges to electrostatic potential&#34; in lines[i]:
                to_begin = int(i)   
            if &#34; Sum of ESP charges =&#34; in lines[i]:
                to_end = int(i)  
        charges = lines[to_begin + 4: to_end]
        charge_list = []
        for i in range(len(charges)):
            charge_list.append(charges[i].strip().split())
        charge_list_value = []
        atom_list = []
        for i in range(len(charge_list)):
            charge_list_value.append(charge_list[i][2])
            atom_list.append(charge_list[i][1])
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_pdb)
        df_guest = ppdb.df[&#39;ATOM&#39;]
        number_guest_atoms = df_guest.shape[0]
        data_tuples = list(zip(atom_list,charge_list_value))
        df_charge = pd.DataFrame(data_tuples, columns=[&#39;Atom&#39;,&#39;Charge&#39;])
        number_host_atoms = df_charge.shape[0] - number_guest_atoms
        df_charge_guest = df_charge.head(number_guest_atoms)
        df_charge_host = df_charge.tail(number_host_atoms)
        df_charge_only_guest = df_charge_guest[&#34;Charge&#34;]
        df_charge_guest.to_csv (self.qm_guest_charge_parameter_file, index = False, header = False, sep = &#39; &#39;)
        df_charge_host.to_csv (self.qm_host_charge_parameter_file, index = False, header = False, sep = &#39; &#39;)
        df_charge_only_guest.to_csv (self.qm_guest_atom_charge_parameter_file, index = False, header = False, sep = &#39; &#39;)
####################################################################################################################################################################################
class ParameterizeGuest:
    
    def __init__(self, vibrational_scaling, xyz_file = &#34;guest_coords.xyz&#34;, coordinate_file = &#34;guest_coordinates.txt&#34;, unprocessed_hessian_file = &#34;guest_unprocessed_hessian.txt&#34;, bond_list_file = &#34;guest_bond_list.txt&#34;, angle_list_file = &#34;guest_angle_list.txt&#34;, hessian_file = &#34;guest_hessian.txt&#34;, atom_names_file = &#34;guest_atom_names.txt&#34;, bond_parameter_file = &#34;guest_bonds.txt&#34;, angle_parameter_file = &#34;guest_angles.txt&#34;, charge_parameter_file = &#34;guest_charges.txt&#34;, guest_pdb = &#34;guest_init_II.pdb&#34;, proper_dihedral_file = &#34;proper_dihedrals.txt&#34;):
        self.vibrational_scaling = vibrational_scaling
        self.xyz_file = xyz_file
        self.coordinate_file = coordinate_file
        self.unprocessed_hessian_file = unprocessed_hessian_file
        self.bond_list_file = bond_list_file
        self.angle_list_file = angle_list_file
        self.hessian_file = hessian_file
        self.atom_names_file = atom_names_file
        self.bond_parameter_file = bond_parameter_file
        self.angle_parameter_file = angle_parameter_file
        self.charge_parameter_file = charge_parameter_file
        self.guest_pdb = guest_pdb
        self.proper_dihedral_file = proper_dihedral_file
        
    def get_xyz(self):   
        &#34;&#34;&#34;
        This function saves a xyz file from the formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
        with open (fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
                no_coordinates = int(no_coordinates[0])
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                to_begin = int(i)     
        cartesian_coords = lines[to_begin + 1:to_begin + 1 + int(math.ceil(no_coordinates/5))]
        cartesian_list = []
        for i in range(len(cartesian_coords)):
            cartesian_list.append(cartesian_coords[i].strip().split())
        coordinates_list = [item for sublist in cartesian_list for item in sublist]
        list_coords = [float(x)*float(0.529) for x in coordinates_list]
        for i in range(len(lines)):
            if &#34;Atomic numbers&#34; in lines[i]:
                to_begin = int(i) 
            if &#34;Nuclear charges&#34; in lines[i]:
                to_end = int(i)    
        atomic_numbers = lines[to_begin + 1:to_end]
        atom_numbers = []
        for i in range(len(atomic_numbers)):
            atom_numbers.append(atomic_numbers[i].strip().split())
        numbers = [item for sublist in atom_numbers for item in sublist]
        N = int(no_coordinates/3)
        # Opens the new xyz file 
        file = open(self.xyz_file, &#34;w&#34;)
        file.write(str(N) + &#39;\n \n&#39;)
        coords = np.zeros((N,3))
        n = 0
        names = []   
        # Gives name for atomic number
        for x in range(0,len(numbers)):
            names.append(element_list[int(numbers[x]) - 1][1]) 
        # Print coordinates to new input_coords.xyz file
        for i in range(0, N):
            for j in range(0,3):
                coords[i][j] = list_coords[n]
                n = n + 1
            file.write(names[i] + str(round(coords[i][0],3)) + &#39; &#39; + str(round(coords[i][1],3)) + &#39; &#39; + str(round(coords[i][2], 3)) + &#39;\n&#39;)
        file.close()
        np.savetxt(self.coordinate_file, coords, fmt=&#39;%s&#39;)  
        
    def get_unprocessed_hessian(self):   
        &#34;&#34;&#34;
        This function saves a text file of the unprocessed hessian from the formatted checkpoint file.
        &#34;&#34;&#34;    
        fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
        with open (fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Cartesian Force Constants&#34; in lines[i]:
                no_hessian = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
                no_hessian = int(no_hessian[0])
        for i in range(len(lines)):
            if &#34;Cartesian Force Constants&#34; in lines[i]:
                to_begin = int(i)     
        hessian = lines[to_begin + 1:to_begin + 1 + int(math.ceil(no_hessian/5))]
        hessian_list = []
        for i in range(len(hessian)):
            hessian_list.append(hessian[i].strip().split())
        unprocessed_Hessian = [item for sublist in hessian_list for item in sublist]
        np.savetxt(self.unprocessed_hessian_file, unprocessed_Hessian, fmt=&#39;%s&#39;)
        
    def get_bond_angles(self):   
        &#34;&#34;&#34;
        This function saves a text file of the bonds and angles from the gaussian log file.
        &#34;&#34;&#34; 
        log_file = self.guest_pdb[:-4] + &#34;.log&#34;
        fid = open(log_file, &#34;r&#34;)
        tline = fid.readline()
        bond_list = []
        angle_list = []
        n = 1
        n_bond = 1
        n_angle = 1
        tmp = &#39;R&#39; # States if bond or angle
        B = []
        # Finds the bond and angles from the .log file
        while tline:
            tline = fid.readline()
            # Line starts at point when bond and angle list occurs
            if len(tline) &gt; 80 and tline[0:81].strip() == &#39;! Name  Definition              Value          Derivative Info.                !&#39;:
                tline = fid.readline()
                tline = fid.readline()
                # Stops when all bond and angles recorded 
                while ( ( tmp[0] == &#39;R&#39; ) or (tmp[0] == &#39;A&#39;) ):
                    line = tline.split()
                    tmp = line[1]
                    # Bond or angles listed as string
                    list_terms = line[2][2:-1]
                    # Bond List 
                    if ( tmp[0] == &#39;R&#39; ): 
                        x = list_terms.split(&#39;,&#39;)
                        # Subtraction due to python array indexing at 0
                        x = [(int(i) - 1 ) for i in x]
                        bond_list.append(x)
                        # Angle List 
                    if (tmp[0] == &#39;A&#39; ): 
                        x = list_terms.split(&#39;,&#39;)
                        # Subtraction due to python array indexing at 0
                        x = [(int(i) - 1 ) for i in x]
                        angle_list.append(x)
                    tline = fid.readline()
                # Leave loop
                tline = -1
        np.savetxt(self.bond_list_file, bond_list, fmt=&#39;%s&#39;)
        np.savetxt(self.angle_list_file, angle_list, fmt=&#39;%s&#39;)
        
    def get_hessian(self):
        &#34;&#34;&#34;
        This function extracts hessian from the unprocessed hessian and saves into a new file.
        &#34;&#34;&#34;       
        unprocessed_Hessian = np.loadtxt(self.unprocessed_hessian_file) 
        fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;     
        with open (fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
                no_coordinates = int(no_coordinates[0])
        N = int(no_coordinates/3)    
        length_hessian = 3 * N
        hessian = np.zeros((length_hessian, length_hessian))
        m = 0
        # Write the hessian in a 2D array format 
        for i in range (0,(length_hessian)):
            for j in range (0,(i + 1)):
                hessian[i][j] = unprocessed_Hessian[m]
                hessian[j][i] = unprocessed_Hessian[m]
                m = m + 1
        hessian = (hessian * (627.509391))/ (0.529**2)  # Change from Hartree/bohr to kcal/mol/ang
        np.savetxt(self.hessian_file, hessian, fmt=&#39;%s&#39;)

    def get_atom_names(self):
        &#34;&#34;&#34;
        This function saves a list of atom names from the formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
        with open (fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()    
        for i in range(len(lines)):
            if &#34;Atomic numbers&#34; in lines[i]:
                to_begin = int(i) 
            if &#34;Nuclear charges&#34; in lines[i]:
                to_end = int(i) 
        atomic_numbers = lines[to_begin + 1:to_end]
        atom_numbers = []
        for i in range(len(atomic_numbers)):
            atom_numbers.append(atomic_numbers[i].strip().split())
        numbers = [item for sublist in atom_numbers for item in sublist]
        names = []   
        # Gives name for atomic number
        for x in range(0,len(numbers)):
            names.append(element_list[int(numbers[x]) - 1][1]) 
        atom_names = []
        for i in range(0,len(names)):
            atom_names.append(names[i].strip() + str(i + 1))
        np.savetxt(self.atom_names_file, atom_names, fmt =&#39;%s&#39;)
        
    def get_bond_angle_params(self):  
        &#34;&#34;&#34;
        This function saves the bond and angle parameter files obtained from the formatted checkpoint file. 
        &#34;&#34;&#34;
        fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
        with open (fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
                no_coordinates = int(no_coordinates[0])    
        N = int(no_coordinates/3)
        coords = np.loadtxt(self.coordinate_file)
        hessian = np.loadtxt(self.hessian_file)
        bond_list = np.loadtxt(self.bond_list_file, dtype = int)
        atom_names = np.loadtxt(self.atom_names_file, dtype = str) 
        # Find bond lengths
        bond_lengths = np.zeros((N, N))
        for i in range (0,N):
            for j in range(0,N):
                diff_i_j = np.array(coords[i,:]) - np.array(coords[j,:])
                bond_lengths[i][j] =  np.linalg.norm(diff_i_j)
        eigenvectors = np.empty((3, 3, N, N), dtype=complex)
        eigenvalues = np.empty((N, N, 3), dtype=complex)
        partial_hessian = np.zeros((3, 3))
        for i in range(0,N):
            for j in range(0,N):
                partial_hessian = hessian[(i * 3):((i + 1)*3),(j * 3):((j + 1)*3)]
                [a, b] = np.linalg.eig(partial_hessian)
                eigenvalues[i,j,:] = (a)
                eigenvectors[:,:,i,j] = (b)
        # Modified Seminario method to find the bond parameters and print them to file
        file_bond = open(self.bond_parameter_file, &#39;w&#39;)
        k_b = np.zeros(len(bond_list))
        bond_length_list = np.zeros(len(bond_list))
        unique_values_bonds = [] # Used to find average values 
        for i in range(0, len(bond_list)):
            AB = force_constant_bond(bond_list[i][0], bond_list[i][1],eigenvalues, eigenvectors, coords)
            BA = force_constant_bond(bond_list[i][1], bond_list[i][0],eigenvalues, eigenvectors, coords)
            # Order of bonds sometimes causes slight differences, find the mean
            k_b[i] = np.real(( AB + BA ) /2); 
            # Vibrational_scaling takes into account DFT deficities/ anharmocity   
            vibrational_scaling_squared = self.vibrational_scaling**2        
            k_b[i] = k_b[i] * vibrational_scaling_squared
            bond_length_list[i] =  bond_lengths[bond_list[i][0]][bond_list[i][1]]
            file_bond.write(atom_names[bond_list[i][0]] + &#39;-&#39; + atom_names[bond_list[i][1]] + &#39;  &#39;)
            file_bond.write(str(&#34;%#.5g&#34; % k_b[i])+ &#39;   &#39; + str(&#34;%#.4g&#34; % bond_length_list[i]) +  &#39;   &#39; + str(bond_list[i][0] + 1) +  &#39;   &#39; + str(bond_list[i][1] + 1))
            file_bond.write(&#39;\n&#39;)
            unique_values_bonds.append([atom_names[bond_list[i][0]], atom_names[bond_list[i][1]], k_b[i], bond_length_list[i], 1 ])
        file_bond.close()
        angle_list = np.loadtxt(self.angle_list_file, dtype = int)
        # Modified Seminario method to find the angle parameters and print them to file
        file_angle = open(self.angle_parameter_file, &#39;w&#39;)
        k_theta = np.zeros(len(angle_list))
        theta_0 = np.zeros(len(angle_list))
        unique_values_angles = [] # Used to find average values
        # Modified Seminario part goes here ...
        # Connectivity information for Modified Seminario Method
        central_atoms_angles = []
        # A structure is created with the index giving the central atom of the angle, an array then lists the angles with that central atom. 
        # i.e. central_atoms_angles{3} contains an array of angles with central atom 3
        for i in range(0, len(coords)):
            central_atoms_angles.append([])
            for j in range(0, len(angle_list)):
                if i == angle_list[j][1]:
                    # For angle ABC, atoms A C are written to array
                    AC_array = [angle_list[j][0],  angle_list[j][2], j]
                    central_atoms_angles[i].append(AC_array)
                    # For angle ABC, atoms C A are written to array
                    CA_array = [angle_list[j][2],  angle_list[j][0], j]
                    central_atoms_angles[i].append(CA_array)
        # Sort rows by atom number
        for i in range(0, len(coords)):
            central_atoms_angles[i] = sorted(central_atoms_angles[i], key=itemgetter(0))
        # Find normals u_PA for each angle
        unit_PA_all_angles = []
        for i in range(0,len(central_atoms_angles)):
            unit_PA_all_angles.append([])
            for j in range(0, len(central_atoms_angles[i])):
                # For the angle at central_atoms_angles[i][j,:] the corresponding u_PA value is found for the plane ABC and bond AB, where ABC corresponds to the order of the arguements. This is why the reverse order was also added
                unit_PA_all_angles[i].append(u_PA_from_angles(central_atoms_angles[i][j][0], i, central_atoms_angles[i][j][1], coords))
        # Finds the contributing factors from the other angle terms scaling_factor_all_angles = cell(max(max(angle_list))); %This array will contain scaling factor and angle list position
        scaling_factor_all_angles = []
        for i in range(0,len(central_atoms_angles)):
            scaling_factor_all_angles.append([])
            for j in range(0,len(central_atoms_angles[i])):
                n = 1
                m = 1
                angles_around = 0 
                additional_contributions = 0 
                scaling_factor_all_angles[i].append([0,0]) 
                # Position in angle list
                scaling_factor_all_angles[i][j][1] =  central_atoms_angles[i][j][2] 
                # Goes through the list of angles with the same central atom and computes the term need for the modified Seminario method    
                # Forwards directions, finds the same bonds with the central atom i  
                while( ( (j + n ) &lt; len(central_atoms_angles[i]) ) and central_atoms_angles[i][j][0] == central_atoms_angles[i][j+n][0] ):
                    additional_contributions = additional_contributions + (abs(np.dot(unit_PA_all_angles[i][j][:], unit_PA_all_angles[i][j + n][:])))**2 
                    n = n + 1
                    angles_around = angles_around + 1
                 # Backwards direction, finds the same bonds with the central atom i   
                while( ( (j - m ) &gt;= 0 ) and central_atoms_angles[i][j][0] == central_atoms_angles[i][j-m][0] ):
                    additional_contributions = additional_contributions + (abs(np.dot(unit_PA_all_angles[i][j][:], unit_PA_all_angles[i][j - m][:] ) ) )**2
                    m = m + 1
                    angles_around =  angles_around + 1
                if (n != 1 or m != 1):
                    # Finds the mean value of the additional contribution to change to normal Seminario method comment out + part 
                    scaling_factor_all_angles[i][j][0] = 1 + ( additional_contributions / (m  + n - 2) )  
                else:
                    scaling_factor_all_angles[i][j][0] = 1
        scaling_factors_angles_list = []
        for i in range(0,len(angle_list) ):
            scaling_factors_angles_list.append([]) 
        # Orders the scaling factors according to the angle list
        for i in range(0,len(central_atoms_angles)):
            for j in range(0,len(central_atoms_angles[i]) ):
                scaling_factors_angles_list[scaling_factor_all_angles[i][j][1]].append(scaling_factor_all_angles[i][j][0]) 
        # Finds the angle force constants with the scaling factors included for each angle
        for i in range(0,len(angle_list) ):
            # Ensures that there is no difference when the ordering is changed 
            [AB_k_theta, AB_theta_0] = force_angle_constant( angle_list[i][0], angle_list[i][1], angle_list[i][2], bond_lengths, eigenvalues, eigenvectors, coords, scaling_factors_angles_list[i][0], scaling_factors_angles_list[i][1] ) 
            [BA_k_theta, BA_theta_0] = force_angle_constant( angle_list[i][2], angle_list[i][1], angle_list[i][0], bond_lengths, eigenvalues, eigenvectors, coords, scaling_factors_angles_list[i][1], scaling_factors_angles_list[i][0] ) 
            k_theta[i] = (AB_k_theta + BA_k_theta ) / 2
            theta_0[i] = (AB_theta_0 +  BA_theta_0 ) / 2
            # Vibrational_scaling takes into account DFT deficities/ anharmonicity 
            k_theta[i] =  k_theta[i] * vibrational_scaling_squared
            file_angle.write(atom_names[angle_list[i][0]] + &#39;-&#39; + atom_names[angle_list[i][1] ] + &#39;-&#39; + atom_names[angle_list[i][2]] + &#39;  &#39; )
            file_angle.write(str(&#34;%#.4g&#34; % k_theta[i]) + &#39;   &#39; + str(&#34;%#.4g&#34; % theta_0[i]) + &#39;   &#39; + str(angle_list[i][0] + 1)  + &#39;   &#39; + str(angle_list[i][1] + 1) + &#39;   &#39; + str(angle_list[i][2] + 1))
            file_angle.write(&#39;\n&#39;)
            unique_values_angles.append([atom_names[angle_list[i][0]], atom_names[angle_list[i][1]], atom_names[angle_list[i][2]], k_theta[i], theta_0[i], 1 ])
        file_angle.close()
        
    def get_charges(self):
        &#34;&#34;&#34;
        This function saves the charges in a text file obtained from the Gaussian log file. 
        &#34;&#34;&#34;
        log_file = self.guest_pdb[:-4] + &#34;.log&#34;
        with open (log_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Fitting point charges to electrostatic potential&#34; in lines[i]:
                to_begin = int(i)   
            if &#34; Sum of ESP charges =&#34; in lines[i]:
                to_end = int(i)  
        charges = lines[to_begin + 4: to_end]
        charge_list = []
        for i in range(len(charges)):
            charge_list.append(charges[i].strip().split())
        charge_list_value = []
        atom_list = []
        for i in range(len(charge_list)):
            charge_list_value.append(charge_list[i][2])
            atom_list.append(charge_list[i][1])
        data_tuples = list(zip(atom_list,charge_list_value))
        df_charge = pd.DataFrame(data_tuples, columns=[&#39;Atom&#39;,&#39;Charge&#39;])
        df_charge.to_csv (self.charge_parameter_file, index = False, header = False, sep = &#39; &#39;)
        
    def get_proper_dihedrals(self):
        &#34;&#34;&#34;
        This function saves proper dihedral angles of the guest molecule in a text file.
        &#34;&#34;&#34;
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_pdb)
        no_atoms = len(ppdb.df[&#34;ATOM&#34;])
        atom_index_list = []
        for i in range(no_atoms):
            atom_index_list.append(i+1)
        possible_dihedrals = []
        for dihed in itertools.permutations(atom_index_list, 4):
            possible_dihedrals.append(dihed)
        df_bonds = pd.read_csv(self.bond_parameter_file, header = None, delimiter = r&#34;\s+&#34;)
        df_bonds.columns = [&#34;bond&#34;, &#34;k_bond&#34;, &#34;bond_length&#34;, &#34;bond_1&#34;, &#34;bond_2&#34;]
        bond1 = df_bonds[&#34;bond_1&#34;].values.tolist()
        bond2 = df_bonds[&#34;bond_2&#34;].values.tolist()
        bond_list_list = []
        for i in range(len(bond1)):
            args = (bond1[i],bond2[i])
            bond_list_list.append(list(args))   
        reverse_bond_list_list = []
        for bonds in bond_list_list:
            reverse_bond_list_list.append(reverse_list(bonds))
        bond_lists = bond_list_list + reverse_bond_list_list
        proper_dihed_repeated  = []
        for i in range(len(possible_dihedrals)):
            dihed_frag = [possible_dihedrals[i][0],possible_dihedrals[i][1]], [possible_dihedrals[i][1],possible_dihedrals[i][2]], [possible_dihedrals[i][2],possible_dihedrals[i][3]]
            a = [dihed_frag[0] in bond_lists,dihed_frag[1] in bond_lists,dihed_frag[2] in bond_lists]
            if a == [True, True, True] :
                proper_dihed_repeated.append(possible_dihedrals[i])
        
        len_repeated_dihed_list = len(proper_dihed_repeated)
        proper_dihedrals = proper_dihed_repeated
        for x in proper_dihedrals:
            z = x[::-1]
            if z in proper_dihedrals:
                proper_dihedrals.remove(z)
        len_non_repeated_dihed_list = len(proper_dihedrals)
        #print(len_repeated_dihed_list == len_non_repeated_dihed_list * 2)  
        np.savetxt(self.proper_dihedral_file, proper_dihedrals, fmt=&#39;%s&#39;)
        #return(proper_dihedrals)
####################################################################################################################################################################################
class PrepareGaussianHost:
  
    def __init__(self, charge, multiplicity, host_qm_pdb = &#34;host_qm.pdb&#34;, n_processors = 12, memory = 50, functional = &#34;B3LYP&#34;, basis_set = &#34;6-31G&#34;, optimisation = &#34;OPT&#34;, frequency = &#34;FREQ&#34;, add_keywords_I = &#34;Integral=(Grid=UltraFine)&#34;, add_keywords_II = &#34;Pop(MK,ReadRadii)&#34;, add_keywords_III = &#34;IOp(6/33=2,6/42=6)&#34;, gauss_out_file = &#34;host_qm.out&#34;, fchk_out_file = &#34;host_qm_fchk.out&#34;):
        self.charge = charge
        self.multiplicity = multiplicity
        self.host_qm_pdb = host_qm_pdb
        self.n_processors = n_processors
        self.memory = memory
        self.functional = functional
        self.basis_set  = basis_set
        self.optimisation = optimisation
        self.frequency = frequency
        self.gauss_out_file = gauss_out_file
        self.fchk_out_file = fchk_out_file
        self.add_keywords_I = add_keywords_I
        self.add_keywords_II = add_keywords_II
        self.add_keywords_III = add_keywords_III
        
    def write_input(self):   
        &#34;&#34;&#34;
        This function prints out the commands section of the gaussian input file.
        &#34;&#34;&#34;
        command_line_1 = &#34;%Chk = &#34; + self.host_qm_pdb[:-4] + &#34;.chk&#34; 
        command_line_2 = &#34;%Mem = &#34; + str(self.memory) + &#34;GB&#34;
        command_line_3 = &#34;%NProcShared = &#34; + str(self.n_processors)
        command_line_4 = &#34;# &#34; + self.functional + &#34; &#34; + self.basis_set + &#34; &#34; + self.optimisation + &#34; &#34; + self.frequency + &#34; &#34; + self.add_keywords_I + &#34; &#34; + self.add_keywords_II + &#34; &#34; + self.add_keywords_III
        command_line_5 = &#34; &#34;
        command_line_6 = self.host_qm_pdb[:-4] + &#34; &#34;  + &#34;gaussian input file&#34;
        command_line_7 = &#34; &#34;
        command_line_8 = str(self.charge) + &#34; &#34;  + str(self.multiplicity)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_qm_pdb)
        df = ppdb.df[&#39;ATOM&#39;]
        df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
        df_1.columns = [&#39;atom&#39;]
        df_2 = df[[&#39;x_coord&#39;, &#39;y_coord&#39;, &#39;z_coord&#39;]]
        df_merged = pd.concat([df_1, df_2], axis=1)
        command_line_9 = df_merged.to_string(header = False, index = False)
        command_line_10 = &#34; &#34;
        command = [command_line_1, command_line_2, command_line_3, command_line_4, 
                   command_line_5, command_line_6, command_line_7, command_line_8, 
                   command_line_9, command_line_10]
        commands = &#39;\n&#39;.join(command)
        with open(self.host_qm_pdb[:-4] + &#34;.com&#34;, &#34;w&#34;) as f:
            f.write(commands)
            
    def run_gaussian(self):   
        &#34;&#34;&#34;
        This function runs the gaussian QM calculation.
        &#34;&#34;&#34;
        execute_command = &#34;g16&#34; + &#34; &lt; &#34; + self.host_qm_pdb[:-4] + &#34;.com&#34;  + &#34; &gt; &#34;  + self.host_qm_pdb[:-4] + &#34;.log&#34; 
        with open(self.gauss_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell = True, stdout = f, stderr = sp.STDOUT)
        
    def get_fchk(self):   
        &#34;&#34;&#34;
        This function converts the checkpoint file file into the formatted chechkpoint file.
        &#34;&#34;&#34;
        execute_command = &#34;formchk&#34;+ &#34; &#34; + self.host_qm_pdb[:-4] + &#34;.chk&#34; + &#34; &#34; + self.host_qm_pdb[:-4] + &#34;.fchk&#34;
        with open(self.fchk_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell = True, stdout = f, stderr = sp.STDOUT)
####################################################################################################################################################################################
class ParameterizeHost:

    def __init__(self, vibrational_scaling, xyz_file = &#34;host_qm_coords.xyz&#34;, coordinate_file = &#34;host_qm_coordinates.txt&#34;, unprocessed_hessian_file = &#34;host_qm_unprocessed_hessian.txt&#34;, bond_list_file = &#34;host_qm_bond_list.txt&#34;, angle_list_file = &#34;host_qm_angle_list.txt&#34;, hessian_file = &#34;host_qm_hessian.txt&#34;, atom_names_file = &#34;host_qm_atom_names.txt&#34;, bond_parameter_file = &#34;host_qm_bonds.txt&#34;, angle_parameter_file = &#34;host_qm_angles.txt&#34;, charge_parameter_file = &#34;host_qm_surround_charges.txt&#34;, host_qm_pdb = &#34;host_qm.pdb&#34;):
        self.vibrational_scaling = vibrational_scaling
        self.xyz_file = xyz_file
        self.coordinate_file = coordinate_file
        self.unprocessed_hessian_file = unprocessed_hessian_file
        self.bond_list_file = bond_list_file
        self.angle_list_file = angle_list_file
        self.hessian_file = hessian_file
        self.atom_names_file = atom_names_file
        self.bond_parameter_file = bond_parameter_file
        self.angle_parameter_file = angle_parameter_file
        self.charge_parameter_file = charge_parameter_file
        self.host_qm_pdb = host_qm_pdb

    def get_xyz(self):   
        &#34;&#34;&#34;
        This function saves a xyz file from the formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
        with open (fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
                no_coordinates = int(no_coordinates[0])
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                to_begin = int(i)     
        cartesian_coords = lines[to_begin + 1:to_begin + 1 + int(math.ceil(no_coordinates/5))]
        cartesian_list = []
        for i in range(len(cartesian_coords)):
            cartesian_list.append(cartesian_coords[i].strip().split())
        coordinates_list = [item for sublist in cartesian_list for item in sublist]
        list_coords = [float(x)*float(0.529) for x in coordinates_list]
        for i in range(len(lines)):
            if &#34;Atomic numbers&#34; in lines[i]:
                to_begin = int(i) 
            if &#34;Nuclear charges&#34; in lines[i]:
                to_end = int(i)    
        atomic_numbers = lines[to_begin + 1:to_end]
        atom_numbers = []
        for i in range(len(atomic_numbers)):
            atom_numbers.append(atomic_numbers[i].strip().split())
        numbers = [item for sublist in atom_numbers for item in sublist]
        N = int(no_coordinates/3)
        # Opens the new xyz file 
        file = open(self.xyz_file, &#34;w&#34;)
        file.write(str(N) + &#39;\n \n&#39;)
        coords = np.zeros((N,3))
        n = 0
        names = []   
        # Gives name for atomic number
        for x in range(0,len(numbers)):
            names.append(element_list[int(numbers[x]) - 1][1]) 
        # Print coordinates to new input_coords.xyz file
        for i in range(0, N):
            for j in range(0,3):
                coords[i][j] = list_coords[n]
                n = n + 1
            file.write(names[i] + str(round(coords[i][0],3)) + &#39; &#39; + str(round(coords[i][1],3)) + &#39; &#39; + str(round(coords[i][2], 3)) + &#39;\n&#39;)
        file.close()
        np.savetxt(self.coordinate_file, coords, fmt=&#39;%s&#39;)  
        
    def get_unprocessed_hessian(self):   
        &#34;&#34;&#34;
        This function saves a text file of the unprocessed hessian from the formatted checkpoint file.
        &#34;&#34;&#34;    
        fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
        with open (fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Cartesian Force Constants&#34; in lines[i]:
                no_hessian = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
                no_hessian = int(no_hessian[0])
        for i in range(len(lines)):
            if &#34;Cartesian Force Constants&#34; in lines[i]:
                to_begin = int(i)     
        hessian = lines[to_begin + 1:to_begin + 1 + int(math.ceil(no_hessian/5))]
        hessian_list = []
        for i in range(len(hessian)):
            hessian_list.append(hessian[i].strip().split())
        unprocessed_Hessian = [item for sublist in hessian_list for item in sublist]
        np.savetxt(self.unprocessed_hessian_file, unprocessed_Hessian, fmt=&#39;%s&#39;)
        
    def get_bond_angles(self):   
        &#34;&#34;&#34;
        This function saves a text file of the bonds and angles from the gaussian log file.
        &#34;&#34;&#34; 
        log_file = self.host_qm_pdb[:-4] + &#34;.log&#34;
        fid = open(log_file, &#34;r&#34;)
        tline = fid.readline()
        bond_list = []
        angle_list = []
        n = 1
        n_bond = 1
        n_angle = 1
        tmp = &#39;R&#39; # States if bond or angle
        B = []
        # Finds the bond and angles from the .log file
        while tline:
            tline = fid.readline()
            # Line starts at point when bond and angle list occurs
            if len(tline) &gt; 80 and tline[0:81].strip() == &#39;! Name  Definition              Value          Derivative Info.                !&#39;:
                tline = fid.readline()
                tline = fid.readline()
                # Stops when all bond and angles recorded 
                while ( ( tmp[0] == &#39;R&#39; ) or (tmp[0] == &#39;A&#39;) ):
                    line = tline.split()
                    tmp = line[1]
                    # Bond or angles listed as string
                    list_terms = line[2][2:-1]
                    # Bond List 
                    if ( tmp[0] == &#39;R&#39; ): 
                        x = list_terms.split(&#39;,&#39;)
                        # Subtraction due to python array indexing at 0
                        x = [(int(i) - 1 ) for i in x]
                        bond_list.append(x)
                        # Angle List 
                    if (tmp[0] == &#39;A&#39; ): 
                        x = list_terms.split(&#39;,&#39;)
                        # Subtraction due to python array indexing at 0
                        x = [(int(i) - 1 ) for i in x]
                        angle_list.append(x)
                    tline = fid.readline()
                # Leave loop
                tline = -1
        np.savetxt(self.bond_list_file, bond_list, fmt=&#39;%s&#39;)
        np.savetxt(self.angle_list_file, angle_list, fmt=&#39;%s&#39;)
        
    def get_hessian(self):
        &#34;&#34;&#34;
        This function extracts hessian from the unprocessed hessian and saves into a new file.
        &#34;&#34;&#34;       
        unprocessed_Hessian = np.loadtxt(self.unprocessed_hessian_file) 
        fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;     
        with open (fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
                no_coordinates = int(no_coordinates[0])
        N = int(no_coordinates/3)    
        length_hessian = 3 * N
        hessian = np.zeros((length_hessian, length_hessian))
        m = 0
        # Write the hessian in a 2D array format 
        for i in range (0,(length_hessian)):
            for j in range (0,(i + 1)):
                hessian[i][j] = unprocessed_Hessian[m]
                hessian[j][i] = unprocessed_Hessian[m]
                m = m + 1
        hessian = (hessian * (627.509391))/ (0.529**2)  # Change from Hartree/bohr to kcal/mol/ang
        np.savetxt(self.hessian_file, hessian, fmt=&#39;%s&#39;)

    def get_atom_names(self):
        &#34;&#34;&#34;
        This function saves a list of atom names from the formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
        with open (fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()    
        for i in range(len(lines)):
            if &#34;Atomic numbers&#34; in lines[i]:
                to_begin = int(i) 
            if &#34;Nuclear charges&#34; in lines[i]:
                to_end = int(i) 
        atomic_numbers = lines[to_begin + 1:to_end]
        atom_numbers = []
        for i in range(len(atomic_numbers)):
            atom_numbers.append(atomic_numbers[i].strip().split())
        numbers = [item for sublist in atom_numbers for item in sublist]
        names = []   
        # Gives name for atomic number
        for x in range(0,len(numbers)):
            names.append(element_list[int(numbers[x]) - 1][1]) 
        atom_names = []
        for i in range(0,len(names)):
            atom_names.append(names[i].strip() + str(i + 1))
        np.savetxt(self.atom_names_file, atom_names, fmt =&#39;%s&#39;)
        
    def get_bond_angle_params(self):  
        &#34;&#34;&#34;
        This function saves the bond and angle parameter files obtained from the formatted checkpoint file. 
        &#34;&#34;&#34;
        fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
        with open (fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
                no_coordinates = int(no_coordinates[0])    
        N = int(no_coordinates/3)
        coords = np.loadtxt(self.coordinate_file)
        hessian = np.loadtxt(self.hessian_file)
        bond_list = np.loadtxt(self.bond_list_file, dtype = int)
        atom_names = np.loadtxt(self.atom_names_file, dtype = str) 
        # Find bond lengths
        bond_lengths = np.zeros((N, N))
        for i in range (0,N):
            for j in range(0,N):
                diff_i_j = np.array(coords[i,:]) - np.array(coords[j,:])
                bond_lengths[i][j] =  np.linalg.norm(diff_i_j)
        eigenvectors = np.empty((3, 3, N, N), dtype=complex)
        eigenvalues = np.empty((N, N, 3), dtype=complex)
        partial_hessian = np.zeros((3, 3))
        for i in range(0,N):
            for j in range(0,N):
                partial_hessian = hessian[(i * 3):((i + 1)*3),(j * 3):((j + 1)*3)]
                [a, b] = np.linalg.eig(partial_hessian)
                eigenvalues[i,j,:] = (a)
                eigenvectors[:,:,i,j] = (b)
        # Modified Seminario method to find the bond parameters and print them to file
        file_bond = open(self.bond_parameter_file, &#39;w&#39;)
        k_b = np.zeros(len(bond_list))
        bond_length_list = np.zeros(len(bond_list))
        unique_values_bonds = [] # Used to find average values 
        for i in range(0, len(bond_list)):
            AB = force_constant_bond(bond_list[i][0], bond_list[i][1],eigenvalues, eigenvectors, coords)
            BA = force_constant_bond(bond_list[i][1], bond_list[i][0],eigenvalues, eigenvectors, coords)
            # Order of bonds sometimes causes slight differences, find the mean
            k_b[i] = np.real(( AB + BA ) /2); 
            # Vibrational_scaling takes into account DFT deficities/ anharmocity   
            vibrational_scaling_squared = self.vibrational_scaling**2        
            k_b[i] = k_b[i] * vibrational_scaling_squared
            bond_length_list[i] =  bond_lengths[bond_list[i][0]][bond_list[i][1]]
            file_bond.write(atom_names[bond_list[i][0]] + &#39;-&#39; + atom_names[bond_list[i][1]] + &#39;  &#39;)
            file_bond.write(str(&#34;%#.5g&#34; % k_b[i])+ &#39;   &#39; + str(&#34;%#.4g&#34; % bond_length_list[i]) +  &#39;   &#39; + str(bond_list[i][0] + 1) +  &#39;   &#39; + str(bond_list[i][1] + 1))
            file_bond.write(&#39;\n&#39;)
            unique_values_bonds.append([atom_names[bond_list[i][0]], atom_names[bond_list[i][1]], k_b[i], bond_length_list[i], 1 ])
        file_bond.close()
        angle_list = np.loadtxt(self.angle_list_file, dtype = int)
        # Modified Seminario method to find the angle parameters and print them to file
        file_angle = open(self.angle_parameter_file, &#39;w&#39;)
        k_theta = np.zeros(len(angle_list))
        theta_0 = np.zeros(len(angle_list))
        unique_values_angles = [] # Used to find average values
        # Modified Seminario part goes here ...
        # Connectivity information for Modified Seminario Method
        central_atoms_angles = []
        # A structure is created with the index giving the central atom of the angle, an array then lists the angles with that central atom. 
        # i.e. central_atoms_angles{3} contains an array of angles with central atom 3
        for i in range(0, len(coords)):
            central_atoms_angles.append([])
            for j in range(0, len(angle_list)):
                if i == angle_list[j][1]:
                    # For angle ABC, atoms A C are written to array
                    AC_array = [angle_list[j][0],  angle_list[j][2], j]
                    central_atoms_angles[i].append(AC_array)
                    # For angle ABC, atoms C A are written to array
                    CA_array = [angle_list[j][2],  angle_list[j][0], j]
                    central_atoms_angles[i].append(CA_array)
        # Sort rows by atom number
        for i in range(0, len(coords)):
            central_atoms_angles[i] = sorted(central_atoms_angles[i], key=itemgetter(0))
        # Find normals u_PA for each angle
        unit_PA_all_angles = []
        for i in range(0,len(central_atoms_angles)):
            unit_PA_all_angles.append([])
            for j in range(0, len(central_atoms_angles[i])):
                # For the angle at central_atoms_angles[i][j,:] the corresponding u_PA value is found for the plane ABC and bond AB, where ABC corresponds to the order of the arguements. This is why the reverse order was also added
                unit_PA_all_angles[i].append(u_PA_from_angles(central_atoms_angles[i][j][0], i, central_atoms_angles[i][j][1], coords))
        # Finds the contributing factors from the other angle terms scaling_factor_all_angles = cell(max(max(angle_list))); %This array will contain scaling factor and angle list position
        scaling_factor_all_angles = []
        for i in range(0,len(central_atoms_angles)):
            scaling_factor_all_angles.append([])
            for j in range(0,len(central_atoms_angles[i])):
                n = 1
                m = 1
                angles_around = 0 
                additional_contributions = 0 
                scaling_factor_all_angles[i].append([0,0]) 
                # Position in angle list
                scaling_factor_all_angles[i][j][1] =  central_atoms_angles[i][j][2] 
                # Goes through the list of angles with the same central atom and computes the term need for the modified Seminario method    
                # Forwards directions, finds the same bonds with the central atom i  
                while( ( (j + n ) &lt; len(central_atoms_angles[i]) ) and central_atoms_angles[i][j][0] == central_atoms_angles[i][j+n][0] ):
                    additional_contributions = additional_contributions + (abs(np.dot(unit_PA_all_angles[i][j][:], unit_PA_all_angles[i][j + n][:])))**2 
                    n = n + 1
                    angles_around = angles_around + 1
                 # Backwards direction, finds the same bonds with the central atom i   
                while( ( (j - m ) &gt;= 0 ) and central_atoms_angles[i][j][0] == central_atoms_angles[i][j-m][0] ):
                    additional_contributions = additional_contributions + (abs(np.dot(unit_PA_all_angles[i][j][:], unit_PA_all_angles[i][j - m][:] ) ) )**2
                    m = m + 1
                    angles_around =  angles_around + 1
                if (n != 1 or m != 1):
                    # Finds the mean value of the additional contribution to change to normal Seminario method comment out + part 
                    scaling_factor_all_angles[i][j][0] = 1 + ( additional_contributions / (m  + n - 2) )  
                else:
                    scaling_factor_all_angles[i][j][0] = 1
        scaling_factors_angles_list = []
        for i in range(0,len(angle_list) ):
            scaling_factors_angles_list.append([]) 
        # Orders the scaling factors according to the angle list
        for i in range(0,len(central_atoms_angles)):
            for j in range(0,len(central_atoms_angles[i]) ):
                scaling_factors_angles_list[scaling_factor_all_angles[i][j][1]].append(scaling_factor_all_angles[i][j][0]) 
        # Finds the angle force constants with the scaling factors included for each angle
        for i in range(0,len(angle_list) ):
            # Ensures that there is no difference when the ordering is changed 
            [AB_k_theta, AB_theta_0] = force_angle_constant( angle_list[i][0], angle_list[i][1], angle_list[i][2], bond_lengths, eigenvalues, eigenvectors, coords, scaling_factors_angles_list[i][0], scaling_factors_angles_list[i][1] ) 
            [BA_k_theta, BA_theta_0] = force_angle_constant( angle_list[i][2], angle_list[i][1], angle_list[i][0], bond_lengths, eigenvalues, eigenvectors, coords, scaling_factors_angles_list[i][1], scaling_factors_angles_list[i][0] ) 
            k_theta[i] = (AB_k_theta + BA_k_theta ) / 2
            theta_0[i] = (AB_theta_0 +  BA_theta_0 ) / 2
            # Vibrational_scaling takes into account DFT deficities/ anharmonicity 
            k_theta[i] =  k_theta[i] * vibrational_scaling_squared
            file_angle.write(atom_names[angle_list[i][0]] + &#39;-&#39; + atom_names[angle_list[i][1] ] + &#39;-&#39; + atom_names[angle_list[i][2]] + &#39;  &#39; )
            file_angle.write(str(&#34;%#.4g&#34; % k_theta[i]) + &#39;   &#39; + str(&#34;%#.4g&#34; % theta_0[i]) + &#39;   &#39; + str(angle_list[i][0] + 1)  + &#39;   &#39; + str(angle_list[i][1] + 1) + &#39;   &#39; + str(angle_list[i][2] + 1))
            file_angle.write(&#39;\n&#39;)
            unique_values_angles.append([atom_names[angle_list[i][0]], atom_names[angle_list[i][1]], atom_names[angle_list[i][2]], k_theta[i], theta_0[i], 1 ])
        file_angle.close()
        
    def get_charges(self):
        &#34;&#34;&#34;
        This function saves the charges in a text file obtained from the Gaussian log file. 
        &#34;&#34;&#34;
        log_file = self.host_qm_pdb[:-4] + &#34;.log&#34;
        with open (log_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Fitting point charges to electrostatic potential&#34; in lines[i]:
                to_begin = int(i)   
            if &#34; Sum of ESP charges =&#34; in lines[i]:
                to_end = int(i)  
        charges = lines[to_begin + 4: to_end]
        charge_list = []
        for i in range(len(charges)):
            charge_list.append(charges[i].strip().split())
        charge_list_value = []
        atom_list = []
        for i in range(len(charge_list)):
            charge_list_value.append(charge_list[i][2])
            atom_list.append(charge_list[i][1])
        data_tuples = list(zip(atom_list,charge_list_value))
        df_charge = pd.DataFrame(data_tuples, columns=[&#39;Atom&#39;,&#39;Charge&#39;])
        df_charge.to_csv (self.charge_parameter_file, index = False, header = False, sep = &#39; &#39;)
####################################################################################################################################################################################
class GuestAmberXMLAmber:

    def __init__(self, charge, num_charge_atoms, charge_atom_1, index_charge_atom_1, system_pdb = &#34;guest_init_II.pdb&#34;, system_mol2 = &#34;guest.mol2&#34;, system_in = &#34;guest.in&#34;, system_frcmod = &#34;guest.frcmod&#34;, prmtop_system = &#34;guest.prmtop&#34;, inpcrd_system = &#34;guest.inpcrd&#34;, system_leap = &#34;guest.leap&#34;, system_xml = &#34;guest_init.xml&#34;,  system_smi =  &#34;guest.smi&#34;,  system_sdf =  &#34;guest.sdf&#34;, system_init_sdf = &#34;guest_init.sdf&#34;, index_charge_atom_2 = &#34; &#34;, charge_atom_2 = &#34; &#34;, charge_parameter_file = &#34;guest_charges.txt&#34;, system_qm_pdb = &#34;guest_init_II.pdb&#34;, bond_parameter_file = &#34;guest_bonds.txt&#34;, angle_parameter_file = &#34;guest_angles.txt&#34;, system_qm_params_file = &#34;guest_qm_params.txt&#34;, reparameterised_intermediate_system_xml_file = &#34;guest_intermediate_reparameterised.xml&#34;, system_xml_non_bonded_file = &#34;guest_xml_non_bonded.txt&#34;, system_xml_non_bonded_reparams_file = &#34;guest_xml_non_bonded_reparams.txt&#34;, reparameterised_system_xml_file = &#34;guest_reparameterised.xml&#34;, non_reparameterised_system_xml_file = &#34;guest_init.xml&#34;, prmtop_system_non_params = &#34;guest_non_params.prmtop&#34;, inpcrd_system_non_params = &#34;guest_non_params.inpcrd&#34;, prmtop_system_params = &#34;guest_params.prmtop&#34;, inpcrd_system_params = &#34;guest_params.inpcrd&#34;, load_topology = &#34;openmm&#34;):   
        self.charge = charge
        self.num_charge_atoms = num_charge_atoms
        self.charge_atom_1 = charge_atom_1
        self.index_charge_atom_1 = index_charge_atom_1
        self.system_pdb = system_pdb
        self.system_mol2 = system_mol2
        self.system_in = system_in
        self.system_frcmod = system_frcmod
        self.prmtop_system = prmtop_system
        self.inpcrd_system = inpcrd_system
        self.system_leap = system_leap
        self.system_xml = system_xml
        self.system_smi = system_smi
        self.system_sdf = system_sdf
        self.system_init_sdf = system_init_sdf
        self.index_charge_atom_2 = index_charge_atom_2
        self.charge_atom_2 = charge_atom_2
        self.charge_parameter_file = charge_parameter_file
        self.system_qm_pdb = system_qm_pdb
        self.bond_parameter_file = bond_parameter_file
        self.angle_parameter_file = angle_parameter_file
        self.system_qm_params_file = system_qm_params_file
        self.reparameterised_intermediate_system_xml_file  = reparameterised_intermediate_system_xml_file
        self.system_xml_non_bonded_file = system_xml_non_bonded_file
        self.system_xml_non_bonded_reparams_file = system_xml_non_bonded_reparams_file
        self.reparameterised_system_xml_file = reparameterised_system_xml_file
        self.non_reparameterised_system_xml_file = non_reparameterised_system_xml_file
        self.prmtop_system_non_params = prmtop_system_non_params
        self.inpcrd_system_non_params = inpcrd_system_non_params
        self.prmtop_system_params = prmtop_system_params
        self.inpcrd_system_params = inpcrd_system_params
        self.load_topology = load_topology

    def generate_xml_antechamber(self):
        &#34;&#34;&#34;
        This function generates an xml file from the pdb file through antechamber
        &#34;&#34;&#34;
        command = &#34;babel -ipdb &#34; +  self.system_pdb + &#34; -omol2 &#34; +  self.system_mol2
        os.system(command)
        command = &#34;antechamber -i &#34; + self.system_mol2 +  &#34; -fi mol2 -o &#34; + self.system_in + &#34; -fo prepi -c bcc -nc &#34; + str(self.charge)
        os.system(command)
        command = &#34;parmchk2 -i &#34; + self.system_in + &#34; -o &#34; + self.system_frcmod + &#34; -f prepi -a Y&#34;
        os.system(command)
        os.system(&#34;rm -rf ANTECHAMBER* leap.log sqm* ATOMTYPE.INF PREP.INF NEWPDB.PDB&#34;)
        line_1 = &#34;loadamberprep &#34; + self.system_in
        line_2 = &#34;loadamberparams &#34; + self.system_frcmod
        line_3 = &#34;pdb = loadpdb &#34; + self.system_pdb
        line_4 = &#34;saveamberparm pdb &#34; + self.prmtop_system + &#34; &#34; + self.inpcrd_system
        line_5 = &#34;quit&#34;
        with open(self.system_leap, &#39;w&#39;) as f:
            f.write(&#34;    &#34; + &#34;\n&#34;)
            f.write(line_1 + &#34;\n&#34;)
            f.write(line_2 + &#34;\n&#34;)
            f.write(line_3 + &#34;\n&#34;)
            f.write(line_4 + &#34;\n&#34;)
            f.write(line_5 + &#34;\n&#34;)
        command = &#34;tleap -f &#34; + self.system_leap
        os.system(command)
        parm = parmed.load_file(self.prmtop_system, self.inpcrd_system)
        system = parm.createSystem()
        with open(self.system_xml, &#39;w&#39;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system)) 

    def generate_xml_from_pdb_smi(self):
        &#34;&#34;&#34;
        This function generates an openforcefield xml file from the pdb file
        &#34;&#34;&#34;
        off_molecule = openforcefield.topology.Molecule(self.system_smi)
        force_field = openforcefield.typing.engines.smirnoff.ForceField(&#39;openff_unconstrained-1.0.0.offxml&#39;)
        system = force_field.create_openmm_system(off_molecule.to_topology())
        pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
        structure = parmed.openmm.load_topology(pdbfile.topology, system, xyz = pdbfile.positions)
        with open(self.system_xml, &#39;w&#39;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))   

    def generate_xml_from_pdb_sdf(self):
        &#34;&#34;&#34;
        This function generates an openforcefield xml file from the pdb file
        &#34;&#34;&#34;
        command = &#34;babel -ipdb &#34; + self.system_pdb + &#34; -osdf &#34; + self.system_sdf
        os.system(command)
        off_molecule = openforcefield.topology.Molecule(self.system_sdf)
        force_field = openforcefield.typing.engines.smirnoff.ForceField(&#39;openff_unconstrained-1.0.0.offxml&#39;)
        system = force_field.create_openmm_system(off_molecule.to_topology())
        pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
        structure = parmed.openmm.load_topology(pdbfile.topology, system, xyz = pdbfile.positions)
        with open(self.system_xml, &#39;w&#39;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))    

    def generate_xml_from_charged_pdb_sdf(self):
        &#34;&#34;&#34;
        This function generates an openforcefield xml file from the pdb file via SDF file and openforcefield.
        &#34;&#34;&#34;
        command = &#34;babel -ipdb &#34; + self.system_pdb + &#34; -osdf &#34; + self.system_init_sdf
        os.system(command)
        with open(self.system_init_sdf, &#39;r&#39;) as f1 :
            filedata = f1.readlines()
            filedata = filedata[:-2]
        with open(self.system_sdf, &#34;w+&#34;) as out:
            for i in filedata:
                out.write(i)
            line_1 = &#34;M  CHG  &#34; + str(self.num_charge_atoms) + &#34;   &#34; + str(self.index_charge_atom_1)   + &#34;   &#34; + str(self.charge_atom_1) + &#34;\n&#34; 
            line_2 = &#34;M  END&#34; + &#34;\n&#34;
            line_3 = &#34;$$$$&#34;
            out.write(line_1)
            out.write(line_2)
            out.write(line_3)
        off_molecule = openforcefield.topology.Molecule(self.system_sdf)
        force_field = openforcefield.typing.engines.smirnoff.ForceField(&#39;openff_unconstrained-1.0.0.offxml&#39;)
        system = force_field.create_openmm_system(off_molecule.to_topology())
        pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
        structure = parmed.openmm.load_topology(pdbfile.topology, system, xyz = pdbfile.positions)
        with open(self.system_xml, &#39;w&#39;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))  

    def generate_xml_from_doubly_charged_pdb_sdf(self):
        &#34;&#34;&#34;
        This function generates an openforcefield xml file from the pdb file via SDF file and openforcefield.
        &#34;&#34;&#34;
        command = &#34;babel -ipdb &#34; + self.system_pdb + &#34; -osdf &#34; + self.system_init_sdf
        os.system(command)
        with open(self.system_init_sdf, &#39;r&#39;) as f1 :
            filedata = f1.readlines()
            filedata = filedata[:-2]
        with open(self.system_sdf, &#34;w+&#34;) as out:
            for i in filedata:
                out.write(i)
            line_1 = &#34;M  CHG  &#34; + str(self.num_charge_atoms) + &#34;   &#34; + str(self.index_charge_atom_1)   + &#34;   &#34; + str(self.charge_atom_1) + &#34;   &#34; + str(self.index_charge_atom_2)   + &#34;   &#34; + str(self.charge_atom_2) + &#34;\n&#34; 
            line_2 = &#34;M  END&#34; + &#34;\n&#34;
            line_3 = &#34;$$$$&#34;
            out.write(line_1)
            out.write(line_2)
            out.write(line_3)
        off_molecule = openforcefield.topology.Molecule(self.system_sdf)
        force_field = openforcefield.typing.engines.smirnoff.ForceField(&#39;openff_unconstrained-1.0.0.offxml&#39;)
        system = force_field.create_openmm_system(off_molecule.to_topology())
        pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
        structure = parmed.openmm.load_topology(pdbfile.topology, system, xyz = pdbfile.positions)
        with open(self.system_xml, &#39;w&#39;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))      
    
    def write_system_params(self):
        &#34;&#34;&#34;
        This function saves the parameters obtained from the QM log files in a text file. 
        &#34;&#34;&#34;
        # Charges from QM files
        df_charges = pd.read_csv(self.charge_parameter_file, header = None, delimiter = r&#34;\s+&#34;)
        df_charges.columns = [&#34;atom&#34;, &#34;charges&#34;]
        qm_charges = df_charges[&#34;charges&#34;].values.tolist()
        qm_charges = [round(num, 6) for num in qm_charges]
        #print(qm_charges)
        # Bond Parameters from QM files
        ppdb = PandasPdb()
        ppdb.read_pdb(self.system_qm_pdb)
        atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
        atom_name_list = [i - 1 for i in atom_name_list]
        #print(atom_name_list)
        df = pd.read_csv(self.bond_parameter_file, header = None, delimiter = r&#34;\s+&#34;)
        df.columns = [&#34;bond&#34;, &#34;k_bond&#34;, &#34;bond_length&#34;, &#34;bond_1&#34;, &#34;bond_2&#34;]
        #print(df.head())
        bond_1_list = df[&#34;bond_1&#34;].values.tolist()
        bond_1_list = [x - 1 + min(atom_name_list) for x in bond_1_list]
        bond_2_list = df[&#34;bond_2&#34;].values.tolist()
        bond_2_list = [x - 1 + min(atom_name_list) for x in bond_2_list]
        #print(bond_1_list)
        #print(bond_2_list)
        k_bond_list = df[&#34;k_bond&#34;].values.tolist()
        k_bond_list = [i* 1000.00 for i in k_bond_list]
        k_bond_list = [round(num, 10) for num in k_bond_list]
        #print(k_bond_list)
        bond_length_list = df[&#34;bond_length&#34;].values.tolist()
        bond_length_list = [i/10.00 for i in bond_length_list]
        bond_length_list = [round(num, 6) for num in bond_length_list]
        #print(bond_length_list)
        # Angle Parameters from QM files
        ppdb = PandasPdb()
        ppdb.read_pdb(self.system_qm_pdb)
        atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
        atom_name_list = [i - 1 for i in atom_name_list]
        #print(atom_name_list)
        df = pd.read_csv(self.angle_parameter_file, header = None, delimiter = r&#34;\s+&#34;)
        df.columns = [&#34;angle&#34;, &#34;k_angle&#34;, &#34;angle_degrees&#34;, &#34;angle_1&#34;, &#34;angle_2&#34;, &#34;angle_3&#34;]
        #print(df.head())
        angle_1_list = df[&#34;angle_1&#34;].values.tolist()
        angle_1_list = [x - 1 + min(atom_name_list) for x in angle_1_list]
        #print(angle_1_list)
        angle_2_list = df[&#34;angle_2&#34;].values.tolist()
        angle_2_list = [x - 1 + min(atom_name_list) for x in angle_2_list]
        #print(angle_2_list)
        angle_3_list = df[&#34;angle_3&#34;].values.tolist()
        angle_3_list = [x - 1 + min(atom_name_list) for x in angle_3_list]
        #print(angle_3_list)
        k_angle_list = df[&#34;k_angle&#34;].values.tolist()
        k_angle_list = [round(num, 6) for num in k_angle_list]
        #print(k_angle_list)
        angle_list = df[&#34;angle_degrees&#34;].values.tolist()
        angle_list = [(i * math.pi)/180.00 for i in angle_list]
        angle_list = [round(num, 6) for num in angle_list]
        #print(angle_list)
        xml = open(self.system_qm_params_file, &#34;w&#34;)
        xml.write(&#34;Begin writing the Bond Parameters&#34; + &#34;\n&#34;)
        for i in range(len(k_bond_list)):
            xml.write(&#34;                                &#34; + &#34;&lt;Bond&#34;  + &#34; &#34; 
                               + &#34;d=&#34; + &#39;&#34;&#39; + str(bond_length_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;k=&#34; + &#39;&#34;&#39; + str(k_bond_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;p1=&#34; + &#39;&#34;&#39; + str(bond_1_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;p2=&#34; + &#39;&#34;&#39; + str(bond_2_list[i]) + &#39;&#34;&#39;  
                               + &#34;/&gt;&#34;  + &#34;\n&#34;)  
        xml.write(&#34;Finish writing the Bond Parameters&#34; + &#34;\n&#34;)
        xml.write(&#34;Begin writing the Angle Parameters&#34; + &#34;\n&#34;)
        for i in range(len(k_angle_list)):
            xml.write(&#34;                                &#34; + &#34;&lt;Angle&#34; + &#34; &#34; 
                               + &#34;a=&#34; + &#39;&#34;&#39; + str(angle_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;k=&#34; + &#39;&#34;&#39; + str(k_angle_list[i])  + &#39;&#34;&#39; + &#34; &#34;
                               + &#34;p1=&#34; + &#39;&#34;&#39; + str(angle_1_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;p2=&#34; + &#39;&#34;&#39; + str(angle_2_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;p3=&#34; + &#39;&#34;&#39; + str(angle_3_list[i]) + &#39;&#34;&#39; 
                               + &#34;/&gt;&#34;  + &#34;\n&#34;)
        xml.write(&#34;Finish writing the Angle Parameters&#34; + &#34;\n&#34;)    
        xml.write(&#34;Begin writing the Charge Parameters&#34; + &#34;\n&#34;)
        for i in range(len(qm_charges)):
            xml.write(&#34;&lt;Particle&#34; + &#34; &#34; 
                              + &#34;q=&#34; + &#39;&#34;&#39; + str(qm_charges[i]) + &#39;&#34;&#39; + &#34; &#34; 
                              + &#34;eps=&#34; + &#39;&#34;&#39; + str(0.00) + &#39;&#34;&#39; + &#34; &#34; 
                              + &#34;sig=&#34; + &#39;&#34;&#39; + str(0.00) + &#39;&#34;&#39; + &#34; &#34;   
                              + &#34;atom=&#34; + &#39;&#34;&#39; + str(atom_name_list[i]) + &#39;&#34;&#39; 
                              + &#34;/&gt;&#34;  + &#34;\n&#34;)
        xml.write(&#34;Finish writing the Charge Parameters&#34; + &#34;\n&#34;)    
        xml.close()
    
    def write_reparameterised_system_xml(self):
        # Bond Parameters
        f_params = open(self.system_qm_params_file, &#39;r&#39;)
        lines_params = f_params.readlines()
        # Bond Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Bond Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Bond Parameters&#34; in lines_params[i]:
                to_end = int(i)  
        bond_params = lines_params[to_begin + 1:to_end]
        index_search_replace_bond = []
        for i in bond_params:
            bond_line_to_replace = i
            #print(bond_line_to_replace)
            atom_number_list = [re.findall(&#39;\d*\.?\d+&#39;, i)[3], re.findall(&#39;\d*\.?\d+&#39;, i)[5]]
            #print(atom_number_list)
            comb_1 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_2 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_list_bond = [comb_1, comb_2]
            #print(comb_list_bond)
            list_search_bond = [search_in_file(file = self.system_xml, word = comb_1),search_in_file(file = self.system_xml, word = comb_2)]
            #print(list_search_bond)
            for j in range(len(list_search_bond)):
                if list_search_bond[j] != []:
                    to_add = (list_search_bond[j],i)
                    #print(to_add)
                    index_search_replace_bond.append(to_add)
        # Angle Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Angle Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Angle Parameters&#34; in lines_params[i]:
                to_end = int(i)  
        angle_params = lines_params[to_begin + 1:to_end]
        index_search_replace_angle = []
        for i in angle_params:
            angle_line_to_replace = i
            #print(angle_line_to_replace)
        index_search_replace_angle = []
        for i in angle_params:
            angle_line_to_replace = i
            #print(angle_line_to_replace)
            atom_number_list = [re.findall(&#39;\d*\.?\d+&#39;, i)[3], re.findall(&#39;\d*\.?\d+&#39;, i)[5], re.findall(&#39;\d*\.?\d+&#39;, i)[7]]
            #print(atom_number_list)
            comb_1 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_2 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_3 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_4 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_5 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_6 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_list_angle = [comb_1, comb_2, comb_3, comb_4, comb_5, comb_6]
            #print(comb_list_angle)    
            list_search_angle = [search_in_file(file = self.system_xml, word = comb_1), 
                                 search_in_file(file = self.system_xml, word = comb_2),
                                 search_in_file(file = self.system_xml, word = comb_3),
                                 search_in_file(file = self.system_xml, word = comb_4),
                                 search_in_file(file = self.system_xml, word = comb_5),
                                 search_in_file(file = self.system_xml, word = comb_6)]
            #print(list_search_angle)
            for j in range(len(list_search_angle)):
                if list_search_angle[j] != []:
                    to_add = (list_search_angle[j],i)
                    #print(to_add)
                    index_search_replace_angle.append(to_add)   
        f_org = open(self.system_xml)
        lines = f_org.readlines()
        for i in range(len(index_search_replace_bond)):
            line_number = index_search_replace_bond[i][0][0][0] - 1
            line_to_replace = index_search_replace_bond[i][0][0][1]
            line_to_replace_with = index_search_replace_bond[i][1]
            lines[line_number] = line_to_replace_with 
        for i in range(len(index_search_replace_angle)):
            line_number = index_search_replace_angle[i][0][0][0] - 1
            line_to_replace = index_search_replace_angle[i][0][0][1]
            line_to_replace_with = index_search_replace_angle[i][1]
            lines[line_number] = line_to_replace_with 
        f_cop = open(self.reparameterised_intermediate_system_xml_file, &#34;w&#34;)
        for i in lines:
            f_cop.write(i)
        f_cop.close()

        f_params = open(self.system_qm_params_file)
        lines_params = f_params.readlines()
        # Charge Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Charge Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Charge Parameters&#34; in lines_params[i]:
                to_end = int(i)  
        charge_params = lines_params[to_begin + 1:to_end]
        non_bonded_index = []
        for k in charge_params:
            non_bonded_index.append(int(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,k)[3]))
        charge_for_index = []
        for k in charge_params:
            charge_for_index.append(float(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,k)[0]))

        xml_off = open(self.system_xml) 
        xml_off_lines = xml_off.readlines() 
        for i in range(len(xml_off_lines)):
            if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
                to_begin = int(i)
            if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
                to_end = int(i)  
        nonbond_params = xml_off_lines[to_begin + 4 : to_end - 1]   
        #print(len(nonbond_params))
        f_non_bonded = open(self.system_xml_non_bonded_file, &#34;w&#34;) 
        for x in nonbond_params:
            f_non_bonded.write(x)

        f_non_bonded = open(self.system_xml_non_bonded_file)
        lines_non_bonded = f_non_bonded.readlines()
        #print(len(lines_non_bonded))
        lines_non_bonded_to_write = []
        for i in range(len(non_bonded_index)) :
            line_ = lines_non_bonded[non_bonded_index[i]]
            #print(line_)
            eps = float(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,line_)[0])
            sig = float(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,line_)[2])
            line_to_replace =     &#34;                                &#34; + &#34;&lt;Particle &#34; + &#34;eps=&#34; + &#39;&#34;&#39; + str(eps) + &#39;&#34;&#39; + &#34; &#34; + &#34;q=&#34; + &#39;&#34;&#39; + str(charge_for_index[i]) + &#39;&#34;&#39; + &#34; &#34; + &#34;sig=&#34; + &#39;&#34;&#39; + str(sig) + &#39;&#34;&#39; + &#34;/&gt;&#34; 
            lines_non_bonded_to_write.append(line_to_replace)
        data_ = list(zip(non_bonded_index,lines_non_bonded_to_write))

        df_non_bonded_params = pd.DataFrame(data_, columns=[&#39;line_index&#39;,&#39;line&#39;])
        #print(df_non_bonded_params.head())
        f_non_bonded_ = open(self.system_xml_non_bonded_file)
        lines_non_bonded_ = f_non_bonded_.readlines()
        for i in range(len(lines_non_bonded_)):
            if i in non_bonded_index:
                lines_non_bonded_[i] = (df_non_bonded_params.loc[df_non_bonded_params.line_index == i, &#39;line&#39;].values[0]) + &#34;\n&#34;
        #print(len(lines_non_bonded_))    
        f_write_non_bonded_reparams = open(self.system_xml_non_bonded_reparams_file, &#34;w&#34;) 
        for p in range(len(lines_non_bonded_)):
            f_write_non_bonded_reparams.write(lines_non_bonded_[p]) 
        f_write_non_bonded_reparams.close()
        f_ = open(self.system_xml_non_bonded_reparams_file)
        lines_ = f_.readlines()
        print(len(lines_) == len(lines_non_bonded))

        xml_off = open(self.reparameterised_intermediate_system_xml_file) 
        xml_off_lines = xml_off.readlines() 
        for i in range(len(xml_off_lines)):
            if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
                to_begin = int(i)
            if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
                to_end = int(i)  

        lines_before_params = xml_off_lines[ : to_begin + 4]
        f__ = open(self.system_xml_non_bonded_reparams_file)
        lines_params_non_bonded = f__.readlines()
        lines_after_params = xml_off_lines[to_end -1 : ]
        f_reparams_xml = open(self.reparameterised_system_xml_file, &#34;w&#34;) 
        for x in lines_before_params:
            f_reparams_xml.write(x)
        for x in lines_params_non_bonded:
            f_reparams_xml.write(x)
        for x in lines_after_params:
            f_reparams_xml.write(x)
        f_reparams_xml.close()
        
    def save_amber_params(self):

        if self.load_topology == &#34;parmed&#34;:
            openmm_system = parmed.openmm.load_topology(parmed.load_file(self.system_pdb, structure=True).topology, parmed.load_file(self.non_reparameterised_system_xml_file))
        if self.load_topology == &#34;openmm&#34;:
            openmm_system = parmed.openmm.load_topology(simtk.openmm.app.PDBFile(self.system_pdb).topology, parmed.load_file(self.non_reparameterised_system_xml_file))
        openmm_system.save(self.prmtop_system_non_params, overwrite=True)
        openmm_system.coordinates = parmed.load_file(self.system_pdb, structure=True).coordinates
        openmm_system.save(self.inpcrd_system_non_params, overwrite=True)
        parm = parmed.load_file(self.prmtop_system_non_params, self.inpcrd_system_non_params)

        xml_energy_decomposition = parmed.openmm.energy_decomposition_system(openmm_system, parmed.load_file(self.non_reparameterised_system_xml_file))
        xml_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        xml_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_xml = pd.DataFrame(list(zip(xml_energy_decomposition_list, xml_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_xml_non_params&#39;])
        df_energy_xml = df_energy_xml.set_index(&#39;Energy_term&#39;)

        prmtop_energy_decomposition = parmed.openmm.energy_decomposition_system(parm, parm.createSystem())
        prmtop_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        prmtop_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_prmtop = pd.DataFrame(list(zip(prmtop_energy_decomposition_list, prmtop_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_prmtop_non_params&#39;])
        df_energy_prmtop = df_energy_prmtop.set_index(&#39;Energy_term&#39;)

        df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
        print(df_compare)

        if self.load_topology == &#34;parmed&#34;:
            openmm_system = parmed.openmm.load_topology(parmed.load_file(self.system_pdb, structure=True).topology, parmed.load_file(self.reparameterised_system_xml_file))
        if self.load_topology == &#34;openmm&#34;:
            openmm_system = parmed.openmm.load_topology(simtk.openmm.app.PDBFile(self.system_pdb).topology, parmed.load_file(self.reparameterised_system_xml_file))
        openmm_system.save(self.prmtop_system_params, overwrite=True)
        openmm_system.coordinates = parmed.load_file(self.system_pdb, structure=True).coordinates
        openmm_system.save(self.inpcrd_system_params, overwrite=True)
        parm = parmed.load_file(self.prmtop_system_params, self.inpcrd_system_params)

        xml_energy_decomposition = parmed.openmm.energy_decomposition_system(openmm_system, parmed.load_file(self.reparameterised_system_xml_file))
        xml_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        xml_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_xml = pd.DataFrame(list(zip(xml_energy_decomposition_list, xml_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_xml_params&#39;])
        df_energy_xml = df_energy_xml.set_index(&#39;Energy_term&#39;)

        prmtop_energy_decomposition = parmed.openmm.energy_decomposition_system(parm, parm.createSystem())
        prmtop_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        prmtop_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_prmtop = pd.DataFrame(list(zip(prmtop_energy_decomposition_list, prmtop_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_prmtop_params&#39;])
        df_energy_prmtop = df_energy_prmtop.set_index(&#39;Energy_term&#39;)

        df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
        print(df_compare)
        
    def analyze_diff_energies(self):
        parm_non_params = parmed.load_file(self.prmtop_system_non_params, self.inpcrd_system_non_params)
        prmtop_energy_decomposition_non_params = parmed.openmm.energy_decomposition_system(parm_non_params, parm_non_params.createSystem())
        prmtop_energy_decomposition_non_params_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        prmtop_energy_decomposition_non_params_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_non_params = pd.DataFrame(list(zip(prmtop_energy_decomposition_non_params_list, prmtop_energy_decomposition_non_params_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_parm_non_params&#39;])
        df_energy_non_params = df_energy_non_params.set_index(&#39;Energy_term&#39;)
        #print(df_energy_non_params)
        parm_params = parmed.load_file(self.prmtop_system_params, self.inpcrd_system_params)
        prmtop_energy_decomposition_params = parmed.openmm.energy_decomposition_system(parm_params, parm_params.createSystem())
        prmtop_energy_decomposition_params_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        prmtop_energy_decomposition_params_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_params = pd.DataFrame(list(zip(prmtop_energy_decomposition_params_list, prmtop_energy_decomposition_params_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_parm_params&#39;])
        df_energy_params = df_energy_params.set_index(&#39;Energy_term&#39;)
        #print(df_energy_params)
        df_compare = pd.concat([df_energy_non_params, df_energy_params], axis=1)
        df_compare[&#39;Energy_difference&#39;] = df_compare[&#39;Energy_parm_non_params&#39;].sub(df_compare[&#39;Energy_parm_params&#39;], axis = 0)
        print(df_compare)
####################################################################################################################################################################################
class HostAmberXMLAmber:

    def __init__(self, system_pdb = &#34;host.pdb&#34;, system_xml = &#34;host.xml&#34;, sim_output = &#34;sim_output.pdb&#34;, sim_steps = 1000, charge_parameter_file = &#34;host_qm_surround_charges.txt&#34;, system_qm_pdb = &#34;host_qm.pdb&#34;, bond_parameter_file = &#34;host_qm_bonds.txt&#34;, angle_parameter_file = &#34;host_qm_angles.txt&#34;, system_qm_params_file = &#34;host_qm_params.txt&#34;, reparameterised_intermediate_system_xml_file = &#34;host_intermediate_reparameterised.xml&#34;, system_xml_non_bonded_file = &#34;host_xml_non_bonded.txt&#34;, system_xml_non_bonded_reparams_file = &#34;host_xml_non_bonded_reparams.txt&#34;, reparameterised_system_xml_file = &#34;host_reparameterised.xml&#34;, non_reparameterised_system_xml_file = &#34;host.xml&#34;, prmtop_system_non_params = &#34;host_non_params.prmtop&#34;, inpcrd_system_non_params = &#34;host_non_params.inpcrd&#34;, prmtop_system_params = &#34;host_params.prmtop&#34;, inpcrd_system_params = &#34;host_params.inpcrd&#34;, load_topology = &#34;openmm&#34;):   
        self.system_pdb = system_pdb
        self.system_xml = system_xml
        self.sim_output = sim_output
        self.sim_steps = sim_steps
        self.charge_parameter_file = charge_parameter_file
        self.system_qm_pdb = system_qm_pdb
        self.bond_parameter_file = bond_parameter_file
        self.angle_parameter_file = angle_parameter_file
        self.system_qm_params_file = system_qm_params_file
        self.reparameterised_intermediate_system_xml_file  = reparameterised_intermediate_system_xml_file
        self.system_xml_non_bonded_file = system_xml_non_bonded_file
        self.system_xml_non_bonded_reparams_file = system_xml_non_bonded_reparams_file
        self.reparameterised_system_xml_file = reparameterised_system_xml_file
        self.non_reparameterised_system_xml_file = non_reparameterised_system_xml_file
        self.prmtop_system_non_params = prmtop_system_non_params
        self.inpcrd_system_non_params = inpcrd_system_non_params
        self.prmtop_system_params = prmtop_system_params
        self.inpcrd_system_params = inpcrd_system_params
        self.load_topology = load_topology
        
    def serialize_system(self):        
        pdb = simtk.openmm.app.PDBFile(self.system_pdb)
        forcefield = simtk.openmm.app.ForceField(&#39;amber14-all.xml&#39;)
        system = forcefield.createSystem(pdb.topology)
        integrator = simtk.openmm.LangevinIntegrator(300 * simtk.unit.kelvin, 1 / simtk.unit.picosecond, 0.002 * simtk.unit.picoseconds)
        simulation = simtk.openmm.app.Simulation(pdb.topology, system, integrator)
        simulation.context.setPositions(pdb.positions)
        simulation.minimizeEnergy()
        state = simulation.context.getState(getEnergy=True)
        energy = state.getPotentialEnergy()
        print(energy)
        simulation.reporters.append(simtk.openmm.app.PDBReporter(self.sim_output, self.sim_steps/10))
        simulation.reporters.append(simtk.openmm.app.StateDataReporter(stdout, reportInterval = int(self.sim_steps/10), step = True, potentialEnergy = True, temperature = True))
        simulation.step(self.sim_steps)
        command = &#34;rm -rf &#34; + self.sim_output
        os.system(command)
        with open(self.system_xml, &#39;w&#39;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))
    
    def write_system_params(self):
        &#34;&#34;&#34;
        This function saves the parameters obtained from the QM log files in a text file. 
        &#34;&#34;&#34;
        # Charges from QM files
        df_charges = pd.read_csv(self.charge_parameter_file, header = None, delimiter = r&#34;\s+&#34;)
        df_charges.columns = [&#34;atom&#34;, &#34;charges&#34;]
        qm_charges = df_charges[&#34;charges&#34;].values.tolist()
        qm_charges = [round(num, 6) for num in qm_charges]
        #print(qm_charges)
        # Bond Parameters from QM files
        ppdb = PandasPdb()
        ppdb.read_pdb(self.system_qm_pdb)
        atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
        atom_name_list = [i - 1 for i in atom_name_list]
        #print(atom_name_list)
        df = pd.read_csv(self.bond_parameter_file, header = None, delimiter = r&#34;\s+&#34;)
        df.columns = [&#34;bond&#34;, &#34;k_bond&#34;, &#34;bond_length&#34;, &#34;bond_1&#34;, &#34;bond_2&#34;]
        #print(df.head())
        bond_1_list = df[&#34;bond_1&#34;].values.tolist()
        bond_1_list = [x - 1 + min(atom_name_list) for x in bond_1_list]
        bond_2_list = df[&#34;bond_2&#34;].values.tolist()
        bond_2_list = [x - 1 + min(atom_name_list) for x in bond_2_list]
        #print(bond_1_list)
        #print(bond_2_list)
        k_bond_list = df[&#34;k_bond&#34;].values.tolist()
        k_bond_list = [i* 1000.00 for i in k_bond_list]
        k_bond_list = [round(num, 10) for num in k_bond_list]
        #print(k_bond_list)
        bond_length_list = df[&#34;bond_length&#34;].values.tolist()
        bond_length_list = [i/10.00 for i in bond_length_list]
        bond_length_list = [round(num, 6) for num in bond_length_list]
        #print(bond_length_list)
        # Angle Parameters from QM files
        ppdb = PandasPdb()
        ppdb.read_pdb(self.system_qm_pdb)
        atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
        atom_name_list = [i - 1 for i in atom_name_list]
        #print(atom_name_list)
        df = pd.read_csv(self.angle_parameter_file, header = None, delimiter = r&#34;\s+&#34;)
        df.columns = [&#34;angle&#34;, &#34;k_angle&#34;, &#34;angle_degrees&#34;, &#34;angle_1&#34;, &#34;angle_2&#34;, &#34;angle_3&#34;]
        #print(df.head())
        angle_1_list = df[&#34;angle_1&#34;].values.tolist()
        angle_1_list = [x - 1 + min(atom_name_list) for x in angle_1_list]
        #print(angle_1_list)
        angle_2_list = df[&#34;angle_2&#34;].values.tolist()
        angle_2_list = [x - 1 + min(atom_name_list) for x in angle_2_list]
        #print(angle_2_list)
        angle_3_list = df[&#34;angle_3&#34;].values.tolist()
        angle_3_list = [x - 1 + min(atom_name_list) for x in angle_3_list]
        #print(angle_3_list)
        k_angle_list = df[&#34;k_angle&#34;].values.tolist()
        k_angle_list = [round(num, 6) for num in k_angle_list]
        #print(k_angle_list)
        angle_list = df[&#34;angle_degrees&#34;].values.tolist()
        angle_list = [(i * math.pi)/180.00 for i in angle_list]
        angle_list = [round(num, 6) for num in angle_list]
        #print(angle_list)
        xml = open(self.system_qm_params_file, &#34;w&#34;)
        xml.write(&#34;Begin writing the Bond Parameters&#34; + &#34;\n&#34;)
        for i in range(len(k_bond_list)):
            xml.write(&#34;                                &#34; + &#34;&lt;Bond&#34;  + &#34; &#34; 
                               + &#34;d=&#34; + &#39;&#34;&#39; + str(bond_length_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;k=&#34; + &#39;&#34;&#39; + str(k_bond_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;p1=&#34; + &#39;&#34;&#39; + str(bond_1_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;p2=&#34; + &#39;&#34;&#39; + str(bond_2_list[i]) + &#39;&#34;&#39;  
                               + &#34;/&gt;&#34;  + &#34;\n&#34;)  
        xml.write(&#34;Finish writing the Bond Parameters&#34; + &#34;\n&#34;)
        xml.write(&#34;Begin writing the Angle Parameters&#34; + &#34;\n&#34;)
        for i in range(len(k_angle_list)):
            xml.write(&#34;                                &#34; + &#34;&lt;Angle&#34; + &#34; &#34; 
                               + &#34;a=&#34; + &#39;&#34;&#39; + str(angle_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;k=&#34; + &#39;&#34;&#39; + str(k_angle_list[i])  + &#39;&#34;&#39; + &#34; &#34;
                               + &#34;p1=&#34; + &#39;&#34;&#39; + str(angle_1_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;p2=&#34; + &#39;&#34;&#39; + str(angle_2_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;p3=&#34; + &#39;&#34;&#39; + str(angle_3_list[i]) + &#39;&#34;&#39; 
                               + &#34;/&gt;&#34;  + &#34;\n&#34;)
        xml.write(&#34;Finish writing the Angle Parameters&#34; + &#34;\n&#34;)    
        xml.write(&#34;Begin writing the Charge Parameters&#34; + &#34;\n&#34;)
        for i in range(len(qm_charges)):
            xml.write(&#34;&lt;Particle&#34; + &#34; &#34; 
                              + &#34;q=&#34; + &#39;&#34;&#39; + str(qm_charges[i]) + &#39;&#34;&#39; + &#34; &#34; 
                              + &#34;eps=&#34; + &#39;&#34;&#39; + str(0.00) + &#39;&#34;&#39; + &#34; &#34; 
                              + &#34;sig=&#34; + &#39;&#34;&#39; + str(0.00) + &#39;&#34;&#39; + &#34; &#34;   
                              + &#34;atom=&#34; + &#39;&#34;&#39; + str(atom_name_list[i]) + &#39;&#34;&#39; 
                              + &#34;/&gt;&#34;  + &#34;\n&#34;)
        xml.write(&#34;Finish writing the Charge Parameters&#34; + &#34;\n&#34;)    
        xml.close()
    
    def write_reparameterised_system_xml(self):
        # Bond Parameters
        f_params = open(self.system_qm_params_file, &#39;r&#39;)
        lines_params = f_params.readlines()
        # Bond Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Bond Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Bond Parameters&#34; in lines_params[i]:
                to_end = int(i)  
        bond_params = lines_params[to_begin + 1:to_end]
        index_search_replace_bond = []
        for i in bond_params:
            bond_line_to_replace = i
            #print(bond_line_to_replace)
            atom_number_list = [re.findall(&#39;\d*\.?\d+&#39;, i)[3], re.findall(&#39;\d*\.?\d+&#39;, i)[5]]
            #print(atom_number_list)
            comb_1 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_2 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_list_bond = [comb_1, comb_2]
            #print(comb_list_bond)
            list_search_bond = [search_in_file(file = self.system_xml, word = comb_1),search_in_file(file = self.system_xml, word = comb_2)]
            #print(list_search_bond)
            for j in range(len(list_search_bond)):
                if list_search_bond[j] != []:
                    to_add = (list_search_bond[j],i)
                    #print(to_add)
                    index_search_replace_bond.append(to_add)
        # Angle Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Angle Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Angle Parameters&#34; in lines_params[i]:
                to_end = int(i)  
        angle_params = lines_params[to_begin + 1:to_end]
        index_search_replace_angle = []
        for i in angle_params:
            angle_line_to_replace = i
            #print(angle_line_to_replace)
        index_search_replace_angle = []
        for i in angle_params:
            angle_line_to_replace = i
            #print(angle_line_to_replace)
            atom_number_list = [re.findall(&#39;\d*\.?\d+&#39;, i)[3], re.findall(&#39;\d*\.?\d+&#39;, i)[5], re.findall(&#39;\d*\.?\d+&#39;, i)[7]]
            #print(atom_number_list)
            comb_1 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_2 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_3 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_4 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_5 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_6 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_list_angle = [comb_1, comb_2, comb_3, comb_4, comb_5, comb_6]
            #print(comb_list_angle)    
            list_search_angle = [search_in_file(file = self.system_xml, word = comb_1), 
                                 search_in_file(file = self.system_xml, word = comb_2),
                                 search_in_file(file = self.system_xml, word = comb_3),
                                 search_in_file(file = self.system_xml, word = comb_4),
                                 search_in_file(file = self.system_xml, word = comb_5),
                                 search_in_file(file = self.system_xml, word = comb_6)]
            #print(list_search_angle)
            for j in range(len(list_search_angle)):
                if list_search_angle[j] != []:
                    to_add = (list_search_angle[j],i)
                    #print(to_add)
                    index_search_replace_angle.append(to_add)   
        f_org = open(self.system_xml)
        lines = f_org.readlines()
        for i in range(len(index_search_replace_bond)):
            line_number = index_search_replace_bond[i][0][0][0] - 1
            line_to_replace = index_search_replace_bond[i][0][0][1]
            line_to_replace_with = index_search_replace_bond[i][1]
            lines[line_number] = line_to_replace_with 
        for i in range(len(index_search_replace_angle)):
            line_number = index_search_replace_angle[i][0][0][0] - 1
            line_to_replace = index_search_replace_angle[i][0][0][1]
            line_to_replace_with = index_search_replace_angle[i][1]
            lines[line_number] = line_to_replace_with 
        f_cop = open(self.reparameterised_intermediate_system_xml_file, &#34;w&#34;)
        for i in lines:
            f_cop.write(i)
        f_cop.close()

        f_params = open(self.system_qm_params_file)
        lines_params = f_params.readlines()
        # Charge Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Charge Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Charge Parameters&#34; in lines_params[i]:
                to_end = int(i)  
        charge_params = lines_params[to_begin + 1:to_end]
        non_bonded_index = []
        for k in charge_params:
            non_bonded_index.append(int(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,k)[3]))
        charge_for_index = []
        for k in charge_params:
            charge_for_index.append(float(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,k)[0]))

        xml_off = open(self.system_xml) 
        xml_off_lines = xml_off.readlines() 
        for i in range(len(xml_off_lines)):
            if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
                to_begin = int(i)
            if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
                to_end = int(i)  
        nonbond_params = xml_off_lines[to_begin + 4 : to_end - 1]   
        #print(len(nonbond_params))
        f_non_bonded = open(self.system_xml_non_bonded_file, &#34;w&#34;) 
        for x in nonbond_params:
            f_non_bonded.write(x)

        f_non_bonded = open(self.system_xml_non_bonded_file)
        lines_non_bonded = f_non_bonded.readlines()
        #print(len(lines_non_bonded))
        lines_non_bonded_to_write = []
        for i in range(len(non_bonded_index)) :
            line_ = lines_non_bonded[non_bonded_index[i]]
            #print(line_)
            eps = float(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,line_)[0])
            sig = float(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,line_)[2])
            line_to_replace =     &#34;                                &#34; + &#34;&lt;Particle &#34; + &#34;eps=&#34; + &#39;&#34;&#39; + str(eps) + &#39;&#34;&#39; + &#34; &#34; + &#34;q=&#34; + &#39;&#34;&#39; + str(charge_for_index[i]) + &#39;&#34;&#39; + &#34; &#34; + &#34;sig=&#34; + &#39;&#34;&#39; + str(sig) + &#39;&#34;&#39; + &#34;/&gt;&#34; 
            lines_non_bonded_to_write.append(line_to_replace)
        data_ = list(zip(non_bonded_index,lines_non_bonded_to_write))

        df_non_bonded_params = pd.DataFrame(data_, columns=[&#39;line_index&#39;,&#39;line&#39;])
        #print(df_non_bonded_params.head())
        f_non_bonded_ = open(self.system_xml_non_bonded_file)
        lines_non_bonded_ = f_non_bonded_.readlines()
        for i in range(len(lines_non_bonded_)):
            if i in non_bonded_index:
                lines_non_bonded_[i] = (df_non_bonded_params.loc[df_non_bonded_params.line_index == i, &#39;line&#39;].values[0]) + &#34;\n&#34;
        #print(len(lines_non_bonded_))    
        f_write_non_bonded_reparams = open(self.system_xml_non_bonded_reparams_file, &#34;w&#34;) 
        for p in range(len(lines_non_bonded_)):
            f_write_non_bonded_reparams.write(lines_non_bonded_[p]) 
        f_write_non_bonded_reparams.close()
        f_ = open(self.system_xml_non_bonded_reparams_file)
        lines_ = f_.readlines()
        print(len(lines_) == len(lines_non_bonded))

        xml_off = open(self.reparameterised_intermediate_system_xml_file) 
        xml_off_lines = xml_off.readlines() 
        for i in range(len(xml_off_lines)):
            if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
                to_begin = int(i)
            if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
                to_end = int(i)  

        lines_before_params = xml_off_lines[ : to_begin + 4]
        f__ = open(self.system_xml_non_bonded_reparams_file)
        lines_params_non_bonded = f__.readlines()
        lines_after_params = xml_off_lines[to_end -1 : ]
        f_reparams_xml = open(self.reparameterised_system_xml_file, &#34;w&#34;) 
        for x in lines_before_params:
            f_reparams_xml.write(x)
        for x in lines_params_non_bonded:
            f_reparams_xml.write(x)
        for x in lines_after_params:
            f_reparams_xml.write(x)
        f_reparams_xml.close()
        
    def save_amber_params(self):

        if self.load_topology == &#34;parmed&#34;:
            openmm_system = parmed.openmm.load_topology(parmed.load_file(self.system_pdb, structure=True).topology, parmed.load_file(self.non_reparameterised_system_xml_file))
        if self.load_topology == &#34;openmm&#34;:
            openmm_system = parmed.openmm.load_topology(simtk.openmm.app.PDBFile(self.system_pdb).topology, parmed.load_file(self.non_reparameterised_system_xml_file))
        openmm_system.save(self.prmtop_system_non_params, overwrite=True)
        openmm_system.coordinates = parmed.load_file(self.system_pdb, structure=True).coordinates
        openmm_system.save(self.inpcrd_system_non_params, overwrite=True)
        parm = parmed.load_file(self.prmtop_system_non_params, self.inpcrd_system_non_params)

        xml_energy_decomposition = parmed.openmm.energy_decomposition_system(openmm_system, parmed.load_file(self.non_reparameterised_system_xml_file))
        xml_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        xml_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_xml = pd.DataFrame(list(zip(xml_energy_decomposition_list, xml_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_xml_non_params&#39;])
        df_energy_xml = df_energy_xml.set_index(&#39;Energy_term&#39;)

        prmtop_energy_decomposition = parmed.openmm.energy_decomposition_system(parm, parm.createSystem())
        prmtop_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        prmtop_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_prmtop = pd.DataFrame(list(zip(prmtop_energy_decomposition_list, prmtop_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_prmtop_non_params&#39;])
        df_energy_prmtop = df_energy_prmtop.set_index(&#39;Energy_term&#39;)

        df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
        print(df_compare)

        if self.load_topology == &#34;parmed&#34;:
            openmm_system = parmed.openmm.load_topology(parmed.load_file(self.system_pdb, structure=True).topology, parmed.load_file(self.reparameterised_system_xml_file))
        if self.load_topology == &#34;openmm&#34;:
            openmm_system = parmed.openmm.load_topology(simtk.openmm.app.PDBFile(self.system_pdb).topology, parmed.load_file(self.reparameterised_system_xml_file))
        openmm_system.save(self.prmtop_system_params, overwrite=True)
        openmm_system.coordinates = parmed.load_file(self.system_pdb, structure=True).coordinates
        openmm_system.save(self.inpcrd_system_params, overwrite=True)
        parm = parmed.load_file(self.prmtop_system_params, self.inpcrd_system_params)

        xml_energy_decomposition = parmed.openmm.energy_decomposition_system(openmm_system, parmed.load_file(self.reparameterised_system_xml_file))
        xml_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        xml_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_xml = pd.DataFrame(list(zip(xml_energy_decomposition_list, xml_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_xml_params&#39;])
        df_energy_xml = df_energy_xml.set_index(&#39;Energy_term&#39;)

        prmtop_energy_decomposition = parmed.openmm.energy_decomposition_system(parm, parm.createSystem())
        prmtop_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        prmtop_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_prmtop = pd.DataFrame(list(zip(prmtop_energy_decomposition_list, prmtop_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_prmtop_params&#39;])
        df_energy_prmtop = df_energy_prmtop.set_index(&#39;Energy_term&#39;)

        df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
        print(df_compare)
        
    def analyze_diff_energies(self):
        parm_non_params = parmed.load_file(self.prmtop_system_non_params, self.inpcrd_system_non_params)
        prmtop_energy_decomposition_non_params = parmed.openmm.energy_decomposition_system(parm_non_params, parm_non_params.createSystem())
        prmtop_energy_decomposition_non_params_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        prmtop_energy_decomposition_non_params_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_non_params = pd.DataFrame(list(zip(prmtop_energy_decomposition_non_params_list, prmtop_energy_decomposition_non_params_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_parm_non_params&#39;])
        df_energy_non_params = df_energy_non_params.set_index(&#39;Energy_term&#39;)
        #print(df_energy_non_params)
        parm_params = parmed.load_file(self.prmtop_system_params, self.inpcrd_system_params)
        prmtop_energy_decomposition_params = parmed.openmm.energy_decomposition_system(parm_params, parm_params.createSystem())
        prmtop_energy_decomposition_params_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        prmtop_energy_decomposition_params_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_params = pd.DataFrame(list(zip(prmtop_energy_decomposition_params_list, prmtop_energy_decomposition_params_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_parm_params&#39;])
        df_energy_params = df_energy_params.set_index(&#39;Energy_term&#39;)
        #print(df_energy_params)
        df_compare = pd.concat([df_energy_non_params, df_energy_params], axis=1)
        df_compare[&#39;Energy_difference&#39;] = df_compare[&#39;Energy_parm_non_params&#39;].sub(df_compare[&#39;Energy_parm_params&#39;], axis = 0)
        print(df_compare)
####################################################################################################################################################################################
class RunOpenMMSims:

    def __init__(self, system_prmtop, system_inpcrd, system_pdb, system_output =  &#34;sim_output.pdb&#34;, sim_steps = 1000):   
        self.system_prmtop = system_prmtop
        self.system_inpcrd = system_inpcrd
        self.system_pdb = system_pdb
        self.system_output = system_output
        self.sim_steps = sim_steps

    def run_openmm_prmtop_inpcrd(self):
        print(&#34;Running OpenMM simulation for &#34; +  self.system_prmtop + &#34; and &#34; + self.system_inpcrd)
        prmtop = simtk.openmm.app.AmberPrmtopFile(self.system_prmtop)
        inpcrd = simtk.openmm.app.AmberInpcrdFile(self.system_inpcrd)
        system = prmtop.createSystem()
        integrator = simtk.openmm.LangevinIntegrator(300 * simtk.unit.kelvin, 1 / simtk.unit.picosecond, 0.002 * simtk.unit.picoseconds)
        simulation = simtk.openmm.app.Simulation(prmtop.topology, system, integrator)
        simulation.context.setPositions(inpcrd.positions)
        if inpcrd.boxVectors is not None:
            simulation.context.setPeriodicBoxVectors(*inpcrd.boxVectors)
        simulation.minimizeEnergy()
        simulation.reporters.append(simtk.openmm.app.PDBReporter(self.system_output, self.sim_steps/10))
        simulation.reporters.append(simtk.openmm.app.StateDataReporter(stdout, reportInterval = int(self.sim_steps/10), step = True, potentialEnergy = True, temperature = True))  
        simulation.step(self.sim_steps)
        command = &#34;rm -rf &#34; + self.system_output
        os.system(command) 

    def run_openmm_prmtop_pdb(self):
        print(&#34;Running OpenMM simulation for &#34; +  self.system_prmtop + &#34; and &#34; + self.system_pdb)
        pdb = simtk.openmm.app.PDBFile(self.system_pdb)
        prmtop = simtk.openmm.app.AmberPrmtopFile(self.system_prmtop)
        system = prmtop.createSystem()
        integrator = simtk.openmm.LangevinIntegrator(300 * simtk.unit.kelvin, 1/simtk.unit.picosecond, 0.002 * simtk.unit.picoseconds)
        simulation = simtk.openmm.app.Simulation(prmtop.topology, system, integrator)
        simulation.context.setPositions(pdb.positions)
        simulation.minimizeEnergy()
        simulation.reporters.append(simtk.openmm.app.PDBReporter(self.system_output, self.sim_steps/10))
        simulation.reporters.append(simtk.openmm.app.StateDataReporter(stdout, reportInterval = int(self.sim_steps/10), step = True, potentialEnergy = True, temperature = True))  
        simulation.step(self.sim_steps)
        command = &#34;rm -rf &#34; + self.system_output
        os.system(command)  
####################################################################################################################################################################################
class MergeHostGuestTopology:

    def __init__(self, host_prmtop, guest_prmtop, host_inpcrd, guest_inpcrd, system_prmtop, system_inpcrd):  
        self.host_prmtop = host_prmtop
        self.guest_prmtop = guest_prmtop
        self.host_inpcrd = host_inpcrd
        self.guest_inpcrd = guest_inpcrd
        self.system_prmtop = system_prmtop 
        self.system_inpcrd = system_inpcrd 

    def merge_topology_files(self):
        print(&#34;Merging the &#34; + self.host_prmtop + &#34; &#34; + self.guest_prmtop + &#34; files&#34;)
        print(&#34;Merging the &#34; + self.host_inpcrd + &#34; &#34; + self.guest_inpcrd + &#34; files&#34;)
        host_system = parmed.load_file(self.host_prmtop, xyz = self.host_inpcrd)
        guest_system = parmed.load_file(self.guest_prmtop, xyz = self.guest_inpcrd)
        system = host_system + guest_system
        system.save(self.system_prmtop, overwrite = True)
        system.save(self.system_inpcrd, overwrite = True)
####################################################################################################################################################################################
class TorsionDriveSims:

    def __init__(self, charge, multiplicity, reparameterised_system_xml_file = &#34;guest_reparameterised.xml&#34;, torsion_xml_file = &#34;guest_torsion_xml.txt&#34;, xyz_file = &#34;guest_coords.xyz&#34;, psi_input_file = &#34;torsion_drive_input.dat&#34;, memory = 50, basis_set = &#34;STO-3G&#34;, functional = &#34;BLYP&#34;, iterations = 2000, method_torsion_drive = &#34;native_opt&#34;, system_bonds_file = &#34;guest_bonds.txt&#34;, tor_dir = &#34;torsion_dir&#34;, dihedral_text_file = &#34;dihedrals.txt&#34;, template_pdb = &#34;guest_init_II.pdb&#34;, torsion_drive_run_file = &#34;run_command&#34;, dihedral_interval = 15, engine = &#34;psi4&#34;, energy_threshold = 0.001):  
        self.charge = charge
        self.multiplicity = multiplicity
        self.reparameterised_system_xml_file = reparameterised_system_xml_file
        self.torsion_xml_file = torsion_xml_file
        self.xyz_file = xyz_file
        self.psi_input_file = psi_input_file
        self.memory = memory
        self.basis_set = basis_set
        self.functional = functional
        self.iterations = iterations
        self.method_torsion_drive = method_torsion_drive
        self.system_bonds_file = system_bonds_file
        self.tor_dir = tor_dir
        self.dihedral_text_file = dihedral_text_file
        self.template_pdb = template_pdb
        self.torsion_drive_run_file = torsion_drive_run_file
        self.dihedral_interval = dihedral_interval
        self.engine = engine
        self.energy_threshold = energy_threshold

    def write_torsion_drive_run_file(self):
        if self.method_torsion_drive == &#34;geometric&#34;:
            torsion_command = &#34;torsiondrive-launch&#34; + &#34; &#34; + self.psi_input_file + &#34; &#34; + self.dihedral_text_file + &#34; &#34; + &#34;-g&#34; + &#34; &#34; + str(self.dihedral_interval) + &#34; &#34; + &#34;-e&#34; + &#34; &#34; + self.engine + &#34; &#34; + &#34;--energy_thresh&#34; + &#34; &#34; + str(self.energy_threshold) + &#34; &#34; + &#34;-v&#34;
        if self.method_torsion_drive == &#34;native_opt&#34;:
            torsion_command = &#34;torsiondrive-launch&#34; + &#34; &#34; + self.psi_input_file + &#34; &#34; + self.dihedral_text_file + &#34; &#34; + &#34;-g&#34; + &#34; &#34; + str(self.dihedral_interval) + &#34; &#34; + &#34;-e&#34; + &#34; &#34; + self.engine + &#34; &#34; + &#34;--energy_thresh&#34; + &#34; &#34; + str(self.energy_threshold) + &#34; &#34; + &#34;--&#34; + self.method_torsion_drive + &#34; &#34; + &#34;-v&#34;
        print(torsion_command)
        with open(self.torsion_drive_run_file, &#34;w&#34;) as f: 
            f.write(torsion_command) 

    def write_tor_params_txt(self):
        xml_off = open(self.reparameterised_system_xml_file, &#39;r&#39;) 
        xml_off_lines = xml_off.readlines() 
        for i in range(len(xml_off_lines)):
            if &#34;&lt;Torsions&gt;&#34; in xml_off_lines[i]:
                to_begin = int(i)
            if &#34;&lt;/Torsions&gt;&#34; in xml_off_lines[i]:
                to_end = int(i)  
        torsion_params = xml_off_lines[to_begin + 1:to_end]

        k_list_off = []
        for i in range(len(torsion_params)):
            k_list_off.append(float(re.findall(&#39;\d*\.?\d+&#39;,torsion_params[i])[0]))
        k_list_off = [round(num, 10) for num in k_list_off]
        #print(k_list_off)
        p1 = []
        for i in range(len(torsion_params)):
            p1.append(int(re.findall(&#39;\d*\.?\d+&#39;,torsion_params[i])[2]))
        p1 = [i + 1 for i in p1]
        #print(p1)
        p2 = []
        for i in range(len(torsion_params)):
            p2.append(int(re.findall(&#39;\d*\.?\d+&#39;,torsion_params[i])[4]))
        p2 = [i + 1 for i in p2]
        #print(p2)
        p3 = []
        for i in range(len(torsion_params)):
            p3.append(int(re.findall(&#39;\d*\.?\d+&#39;,torsion_params[i])[6]))
        p3 = [i + 1 for i in p3]
        #print(p3)
        p4 = []
        for i in range(len(torsion_params)):
            p4.append(int(re.findall(&#39;\d*\.?\d+&#39;,torsion_params[i])[8]))
        p4 = [i + 1 for i in p4]
        #print(p4)
        periodicity = []
        for i in range(len(torsion_params)):
            periodicity.append(int(re.findall(&#39;\d*\.?\d+&#39;,torsion_params[i])[9]))
        #print(periodicity)
        phase = []
        for i in range(len(torsion_params)):
            phase.append(float(re.findall(&#39;\d*\.?\d+&#39;,torsion_params[i])[10]))
        phase = [round(num, 8) for num in phase]
        #print(phase)
        data_tuples = list(zip(k_list_off, p1, p2, p3, p4, periodicity, phase))
        df_tor = pd.DataFrame(data_tuples, columns=[&#39;k&#39;,&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;,&#39;p4&#39;,&#39;periodicity&#39;,&#39;phase&#39;])
        #print(df_tor.head())
        df_tor.to_csv (self.torsion_xml_file, index = False, header = False, sep = &#39; &#39;)

    def write_psi4_input(self):
        xyz_lines = open(self.xyz_file, &#39;r&#39;).readlines()[2:]
        with open(self.psi_input_file, &#34;w&#34;) as f: 
            f.write(&#34;memory&#34; + &#34; &#34; + str(self.memory)  + &#34; &#34; + &#34;GB&#34; + &#34;\n&#34;) 
            f.write(&#34;molecule&#34; + &#34; &#34; + &#34;{&#34; + &#34;\n&#34;)
            f.write(str(self.charge) + &#34; &#34; + str(self.multiplicity) + &#34;\n&#34;)
            for line in xyz_lines:
                f.write(line)
            f.write(&#34;}&#34; + &#34;\n&#34;)
            f.write(&#34;set&#34;  + &#34; &#34; + &#34;{&#34; + &#34;\n&#34;)
            f.write(&#34;basis&#34; + &#34; &#34; + self.basis_set + &#34;\n&#34;)
            if self.method_torsion_drive == &#34;native_opt&#34; :        
                f.write(&#34;GEOM_MAXITER&#34; + &#34; &#34; + str(self.iterations) + &#34;\n&#34;)
            f.write(&#34;}&#34; + &#34;\n&#34;)
            if self.method_torsion_drive == &#34;native_opt&#34; :
                f.write(&#34;optimize&#34; + &#34;(&#34; + &#34;&#39;&#34; + self.functional + &#34;&#39;&#34;&#34;)&#34; + &#34;\n&#34;)  
            if self.method_torsion_drive == &#34;geometric&#34; :
                f.write(&#34;gradient&#34; + &#34;(&#34; + &#34;&#39;&#34; + self.functional + &#34;&#39;&#34;&#34;)&#34; + &#34;\n&#34;) 

    def create_torsion_drive_dir(self):
        df_tor = pd.read_csv(self.torsion_xml_file, header = None, delimiter = r&#34;\s+&#34;)
        df_tor.columns = [&#39;k&#39;,&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;,&#39;p4&#39;,&#39;periodicity&#39;,&#39;phase&#39;]
        #print(df_tor.head())
        df_dihedrals = df_tor[[&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;,&#39;p4&#39;]]
        #print(df_dihedrals.head())
        dihedrals_list_list = []
        for i in range(len(df_dihedrals)):
            dihedrals_list_list.append(df_dihedrals.iloc[i].values.tolist())
        set_list = set()
        unique_dihedrals_list_list = []
        for x in dihedrals_list_list:
            srtd = tuple(sorted(x))
            if srtd not in set_list:
                unique_dihedrals_list_list.append(x)
                set_list.add(srtd)
        #print(unique_dihedrals_list_list)
        os.system(&#34;rm -rf &#34; + self.tor_dir)
        os.system(&#34;mkdir &#34; + self.tor_dir)
        parent_cwd = os.getcwd()
        shutil.copy(parent_cwd + &#34;/&#34; + self.psi_input_file, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.psi_input_file)
        shutil.copy(parent_cwd + &#34;/&#34; + self.template_pdb, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.template_pdb)
        shutil.copy(parent_cwd + &#34;/&#34; + self.torsion_drive_run_file, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.torsion_drive_run_file)
        os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir)
        torsion_drive_dir = os.getcwd()
        for i in range(len(unique_dihedrals_list_list)):
            dir_name = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
            os.system(&#34;rm -rf &#34; + dir_name)
            os.system(&#34;mkdir &#34;  + dir_name)
            os.chdir (torsion_drive_dir + &#34;/&#34; + dir_name)
            with open(self.dihedral_text_file, &#34;w&#34;) as f: 
                f.write(&#34;# dihedral definition by atom indices starting from 1&#34; + &#34;\n&#34;)
                f.write(&#34;# i     j     k     l&#34; + &#34;\n&#34;)
                i_ = unique_dihedrals_list_list[i][0]
                j_ = unique_dihedrals_list_list[i][1]
                k_ = unique_dihedrals_list_list[i][2]
                l_ = unique_dihedrals_list_list[i][3]
                f.write(&#34; &#34; +  &#34;{:&lt; 6d}&#34;.format(i_) + &#34;{:&lt; 6d}&#34;.format(j_) + &#34;{:&lt; 6d}&#34;.format(k_) + &#34;{:&lt; 6d}&#34;.format(l_) +  &#34;\n&#34;)
                shutil.copy (torsion_drive_dir + &#34;/&#34; + self.psi_input_file, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.psi_input_file)
                shutil.copy (torsion_drive_dir + &#34;/&#34; + self.template_pdb, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.template_pdb)
                shutil.copy (torsion_drive_dir + &#34;/&#34; + self.torsion_drive_run_file, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.torsion_drive_run_file)
                os.chdir(torsion_drive_dir)   
        os.system(&#34;rm -rf &#34;  + self.psi_input_file)
        os.system(&#34;rm -rf &#34;  + self.template_pdb)
        os.system(&#34;rm -rf &#34; + self.torsion_drive_run_file)
        os.chdir(parent_cwd)   

    def create_non_H_torsion_drive_dir(self):
        df_tor = pd.read_csv(self.torsion_xml_file, header = None, delimiter = r&#34;\s+&#34;)
        df_tor.columns = [&#39;k&#39;,&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;,&#39;p4&#39;,&#39;periodicity&#39;,&#39;phase&#39;]
        #print(df_tor.head())
        ppdb = PandasPdb()
        ppdb.read_pdb(self.template_pdb)
        df_index_symbol = ppdb.df[&#34;ATOM&#34;][[&#34;atom_number&#34;, &#34;element_symbol&#34;]]
        #print(df_index_symbol.head())
        df_dihedrals = df_tor[[&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;,&#39;p4&#39;]]
        #print(df_dihedrals.head())
        dihedrals_list_list = []
        for i in range(len(df_dihedrals)):
            dihedrals_list_list.append(df_dihedrals.iloc[i].values.tolist())
        set_list = set()
        unique_dihedrals_list_list = []
        for x in dihedrals_list_list:
            srtd = tuple(sorted(x))
            if srtd not in set_list:
                unique_dihedrals_list_list.append(x)
                set_list.add(srtd)
        #print(unique_dihedrals_list_list)
        atom_dihedral_list = []
        for sub_list in unique_dihedrals_list_list:
            atom_dihedral_list.append([df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[0]][&#34;element_symbol&#34;].to_list()[0],df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[1]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[2]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[3]][&#34;element_symbol&#34;].to_list()[0]])
        #print(atom_dihedral_list)
        index_to_include = []
        for i in range(len(atom_dihedral_list)):
            if &#34;H&#34; not in atom_dihedral_list[i]:
                index_to_include.append(i)
        non_H_dihedrals = []
        for i in index_to_include:
            non_H_dihedrals.append(unique_dihedrals_list_list[i])
        #print(non_H_dihedrals)
        non_H_atom_dihedral_list = []
        for sub_list in non_H_dihedrals:
            non_H_atom_dihedral_list.append([df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[0]][&#34;element_symbol&#34;].to_list()[0],df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[1]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[2]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[3]][&#34;element_symbol&#34;].to_list()[0]])
        print(non_H_atom_dihedral_list)  
        os.system(&#34;rm -rf &#34; + self.tor_dir)
        os.system(&#34;mkdir &#34; + self.tor_dir)
        parent_cwd = os.getcwd()
        shutil.copy(parent_cwd + &#34;/&#34; + self.psi_input_file, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.psi_input_file)
        shutil.copy(parent_cwd + &#34;/&#34; + self.template_pdb, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.template_pdb)
        shutil.copy(parent_cwd + &#34;/&#34; + self.torsion_drive_run_file, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.torsion_drive_run_file)
        os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir)
        torsion_drive_dir = os.getcwd()
        for i in range(len(non_H_dihedrals)):
            dir_name = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
            os.system(&#34;rm -rf &#34; + dir_name)
            os.system(&#34;mkdir &#34;  + dir_name)
            os.chdir (torsion_drive_dir + &#34;/&#34; + dir_name)
            with open(self.dihedral_text_file, &#34;w&#34;) as f: 
                f.write(&#34;# dihedral definition by atom indices starting from 1&#34; + &#34;\n&#34;)
                f.write(&#34;# i     j     k     l&#34; + &#34;\n&#34;)
                i_ = non_H_dihedrals[i][0]
                j_ = non_H_dihedrals[i][1]
                k_ = non_H_dihedrals[i][2]
                l_ = non_H_dihedrals[i][3]
                f.write(&#34; &#34; +  &#34;{:&lt; 6d}&#34;.format(i_) + &#34;{:&lt; 6d}&#34;.format(j_) + &#34;{:&lt; 6d}&#34;.format(k_) + &#34;{:&lt; 6d}&#34;.format(l_) +  &#34;\n&#34;)
                shutil.copy (torsion_drive_dir + &#34;/&#34; + self.psi_input_file, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.psi_input_file)
                shutil.copy (torsion_drive_dir + &#34;/&#34; + self.template_pdb, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.template_pdb)
                shutil.copy (torsion_drive_dir + &#34;/&#34; + self.torsion_drive_run_file, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.torsion_drive_run_file)
                os.chdir(torsion_drive_dir)   
        os.system(&#34;rm -rf &#34;  + self.psi_input_file)
        os.system(&#34;rm -rf &#34;  + self.template_pdb)
        os.system(&#34;rm -rf &#34; + self.torsion_drive_run_file)
        os.chdir(parent_cwd)  


    def create_non_H_bonded_torsion_drive_dir(self):
        df_tor = pd.read_csv(self.torsion_xml_file, header = None, delimiter = r&#34;\s+&#34;)
        df_tor.columns = [&#39;k&#39;,&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;,&#39;p4&#39;,&#39;periodicity&#39;,&#39;phase&#39;]
        #print(df_tor.head())
        ppdb = PandasPdb()
        ppdb.read_pdb(self.template_pdb)
        df_index_symbol = ppdb.df[&#34;ATOM&#34;][[&#34;atom_number&#34;, &#34;element_symbol&#34;]]
        #print(df_index_symbol.head())
        df_dihedrals = df_tor[[&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;,&#39;p4&#39;]]
        #print(df_dihedrals.head())
        dihedrals_list_list = []
        for i in range(len(df_dihedrals)):
            dihedrals_list_list.append(df_dihedrals.iloc[i].values.tolist())
        set_list = set()
        unique_dihedrals_list_list = []
        for x in dihedrals_list_list:
            srtd = tuple(sorted(x))
            if srtd not in set_list:
                unique_dihedrals_list_list.append(x)
                set_list.add(srtd)
        #print(unique_dihedrals_list_list)
        atom_dihedral_list = []
        for sub_list in unique_dihedrals_list_list:
            atom_dihedral_list.append([df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[0]][&#34;element_symbol&#34;].to_list()[0],df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[1]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[2]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[3]][&#34;element_symbol&#34;].to_list()[0]])
        #print(atom_dihedral_list)
        index_to_include = []
        for i in range(len(atom_dihedral_list)):
            if &#34;H&#34; not in atom_dihedral_list[i]:
                index_to_include.append(i)
        non_H_dihedrals = []
        for i in index_to_include:
            non_H_dihedrals.append(unique_dihedrals_list_list[i])
        #print(non_H_dihedrals)
        non_H_atom_dihedral_list = []
        for sub_list in non_H_dihedrals:
            non_H_atom_dihedral_list.append([df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[0]][&#34;element_symbol&#34;].to_list()[0],df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[1]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[2]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[3]][&#34;element_symbol&#34;].to_list()[0]])
        #print(non_H_atom_dihedral_list)  
        df_bonds_all = pd.read_csv(self.system_bonds_file, header = None, delimiter = r&#34;\s+&#34;)
        df_bonds_all.columns = [&#34;bond_names&#34;, &#34;k&#34;, &#34;angle&#34;, &#34;b1&#34;, &#34;b2&#34;]
        df_bonds = df_bonds_all[[&#39;b1&#39;,&#39;b2&#39;]]
        bonds_list_list = []
        for i in range(len(df_bonds)):
            bonds_list_list.append(df_bonds.iloc[i].values.tolist())
        #print(bonds_list_list)
        reverse_bond_list_list = []
        for i in bonds_list_list:
            reverse_bond_list_list.append(reverse_list(i))
        #print(reverse_bond_list_list)
        bond_list = bonds_list_list + reverse_bond_list_list
        #print(bond_list)
        non_H_dihedral_bonds_list = []
        for i in non_H_dihedrals:
            non_H_dihedral_bonds_list.append([[i[0], i[1]], [i[1], i[2]], [i[2], i[3]]])
        #print(non_H_dihedral_bonds_list)
        bonded_index_to_include = []
        for i in range(len(non_H_dihedral_bonds_list)):
            if [non_H_dihedral_bonds_list[i][0] in bond_list, non_H_dihedral_bonds_list[i][1] in bond_list, non_H_dihedral_bonds_list[i][2] in bond_list] == [True, True, True] :
                bonded_index_to_include.append(i)
        #print(bonded_index_to_include)
        non_H_bonded_dihedrals = []
        for i in bonded_index_to_include:
            non_H_bonded_dihedrals.append(non_H_dihedrals[i])
        #print(non_H_bonded_dihedrals)
        non_H_bonded_atom_dihedral_list = []
        for sub_list in non_H_bonded_dihedrals:
            non_H_bonded_atom_dihedral_list.append([df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[0]][&#34;element_symbol&#34;].to_list()[0],df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[1]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[2]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[3]][&#34;element_symbol&#34;].to_list()[0]])
        print(non_H_bonded_atom_dihedral_list)    
        os.system(&#34;rm -rf &#34; + self.tor_dir)
        os.system(&#34;mkdir &#34; + self.tor_dir)
        parent_cwd = os.getcwd()
        shutil.copy(parent_cwd + &#34;/&#34; + self.psi_input_file, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.psi_input_file)
        shutil.copy(parent_cwd + &#34;/&#34; + self.template_pdb, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.template_pdb)
        shutil.copy(parent_cwd + &#34;/&#34; + self.torsion_drive_run_file, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.torsion_drive_run_file)
        os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir)
        torsion_drive_dir = os.getcwd()
        for i in range(len(non_H_bonded_dihedrals)):
            dir_name = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
            os.system(&#34;rm -rf &#34; + dir_name)
            os.system(&#34;mkdir &#34;  + dir_name)
            os.chdir (torsion_drive_dir + &#34;/&#34; + dir_name)
            with open(self.dihedral_text_file, &#34;w&#34;) as f: 
                f.write(&#34;# dihedral definition by atom indices starting from 1&#34; + &#34;\n&#34;)
                f.write(&#34;# i     j     k     l&#34; + &#34;\n&#34;)
                i_ = non_H_bonded_dihedrals[i][0]
                j_ = non_H_bonded_dihedrals[i][1]
                k_ = non_H_bonded_dihedrals[i][2]
                l_ = non_H_bonded_dihedrals[i][3]
                f.write(&#34; &#34; +  &#34;{:&lt; 6d}&#34;.format(i_) + &#34;{:&lt; 6d}&#34;.format(j_) + &#34;{:&lt; 6d}&#34;.format(k_) + &#34;{:&lt; 6d}&#34;.format(l_) +  &#34;\n&#34;)
                shutil.copy (torsion_drive_dir + &#34;/&#34; + self.psi_input_file, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.psi_input_file)
                shutil.copy (torsion_drive_dir + &#34;/&#34; + self.template_pdb, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.template_pdb)
                shutil.copy (torsion_drive_dir + &#34;/&#34; + self.torsion_drive_run_file, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.torsion_drive_run_file)
                os.chdir(torsion_drive_dir)   
        os.system(&#34;rm -rf &#34;  + self.psi_input_file)
        os.system(&#34;rm -rf &#34;  + self.template_pdb)
        os.system(&#34;rm -rf &#34; + self.torsion_drive_run_file)
        os.chdir(parent_cwd)  

    def run_torsion_sim(self):
        parent_cwd = os.getcwd()
        target_dir = parent_cwd + &#34;/&#34; + self.tor_dir
        num_folders = 0
        for _, dirnames, filenames in os.walk(target_dir):
            num_folders += len(dirnames)
        for i in range(num_folders):
            dir_ = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
            os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + dir_)
            run_command = &#34;bash&#34; + &#34; &#34; + self.torsion_drive_run_file
            #os.system(run_command)
            print(run_command)
            os.chdir(parent_cwd) 
####################################################################################################################################################################################
class TorsionDriveParams:

    def __init__(self, num_charge_atoms, index_charge_atom_1, charge_atom_1, tor_dir = &#34;torsion_dir&#34;, reparameterized_torsional_params_file = &#34;reparameterized_torsional_params.txt&#34;, psi_input_file = &#34;torsion_drive_input.dat&#34;, xyz_file = &#34;torsion_drive_input.xyz&#34;, coords_file = &#34;torsion_drive_input.txt&#34;, template_pdb = &#34;guest_init_II.pdb&#34;, system_pdb = &#34;torsion_drive_input.pdb&#34;, system_sdf = &#34;torsion_drive_input.sdf&#34;, system_xml = &#34;torsion_drive_input.xml&#34;, qm_scan_file = &#34;scan.xyz&#34;, load_topology = &#34;openmm&#34;, method = &#34;L-BFGS-B&#34;, dihedral_text_file = &#34;dihedrals.txt&#34;, system_init_sdf = &#34;torsion_drive_input_init.sdf&#34;, reparameterised_system_xml_file = &#34;guest_reparameterised.xml&#34;, reparameterised_torsional_system_xml_file = &#34;guest_torsional_reparameterized.xml&#34;):  
        self.num_charge_atoms = num_charge_atoms
        self.index_charge_atom_1 = index_charge_atom_1
        self.charge_atom_1 = charge_atom_1
        self.tor_dir = tor_dir
        self.reparameterized_torsional_params_file = reparameterized_torsional_params_file
        self.psi_input_file = psi_input_file
        self.xyz_file = xyz_file
        self.coords_file = coords_file
        self.template_pdb = template_pdb
        self.system_pdb = system_pdb
        self.system_sdf = system_sdf
        self.system_xml = system_xml
        self.qm_scan_file = qm_scan_file
        self.method = method
        self.dihedral_text_file = dihedral_text_file
        self.system_init_sdf = system_init_sdf
        self.load_topology = load_topology
        self.reparameterised_system_xml_file = reparameterised_system_xml_file
        self.reparameterised_torsional_system_xml_file = reparameterised_torsional_system_xml_file

    def write_reparams_torsion_lines(self):
        torsional_parameters_list = []
        parent_cwd = os.getcwd()
        target_dir = parent_cwd + &#34;/&#34; + self.tor_dir
        for i in os.listdir(target_dir):
            os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + i)
            print(&#34;Entering directory&#34; + &#34; : &#34;  + os.getcwd())
            torsiondrive_input_to_xyz(psi_input_file = self.psi_input_file, xyz_file = self.xyz_file)
            xyz_to_pdb(xyz_file = self.xyz_file, coords_file = self.coords_file, template_pdb = self.template_pdb, system_pdb = self.system_pdb)
            generate_xml_from_charged_pdb_sdf(system_pdb = self.system_pdb, system_init_sdf = system_init_sdf, system_sdf = self.system_sdf, num_charge_atoms = num_charge_atoms, index_charge_atom_1 = index_charge_atom_1, charge_atom_1 = charge_atom_1, system_xml = self.system_xml) 
            torsional_lines = get_torsional_lines(template_pdb = self.template_pdb, system_xml = self.system_xml, qm_scan_file = self.qm_scan_file, load_topology = self.load_topology,  method = self.method, dihedral_text_file = self.dihedral_text_file)
            #print(torsional_lines)
            torsional_parameters_list.append(torsional_lines)
            remove_mm_files(qm_scan_file = self.qm_scan_file)
            os.chdir(parent_cwd)  
        torsional_parameters = [item for sublist in torsional_parameters_list for item in sublist]
        with open(self.reparameterized_torsional_params_file, &#34;w&#34;) as f: 
            for i in torsional_parameters:
                f.write(i + &#34;\n&#34;) 

    def write_reparams_torsion_lines_charged(self):
        torsional_parameters_list = []
        parent_cwd = os.getcwd()
        target_dir = parent_cwd + &#34;/&#34; + self.tor_dir
        for i in os.listdir(target_dir):
            os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + i)
            print(&#34;Entering directory&#34; + &#34; : &#34;  + os.getcwd())
            torsiondrive_input_to_xyz(psi_input_file = self.psi_input_file, xyz_file = self.xyz_file)
            xyz_to_pdb(xyz_file = self.xyz_file, coords_file = self.coords_file, template_pdb = self.template_pdb, system_pdb = self.system_pdb)
            generate_xml_from_charged_pdb_sdf(system_pdb = self.system_pdb, system_init_sdf = self.system_init_sdf, system_sdf = self.system_sdf, num_charge_atoms = self.num_charge_atoms, index_charge_atom_1 = self.index_charge_atom_1, charge_atom_1 = self.charge_atom_1, system_xml = self.system_xml) 
            torsional_lines = get_torsional_lines(template_pdb = self.template_pdb, system_xml = self.system_xml, qm_scan_file = self.qm_scan_file, load_topology = self.load_topology,  method = self.method, dihedral_text_file = self.dihedral_text_file)
            #print(torsional_lines)
            torsional_parameters_list.append(torsional_lines)
            remove_mm_files(qm_scan_file = self.qm_scan_file)
            os.chdir(parent_cwd)  
        torsional_parameters = [item for sublist in torsional_parameters_list for item in sublist]
        with open(self.reparameterized_torsional_params_file, &#34;w&#34;) as f: 
            for i in torsional_parameters:
                f.write(i + &#34;\n&#34;) 

    def write_torsional_reparams(self):
        xml_tor = open(self.reparameterized_torsional_params_file, &#39;r&#39;) 
        xml_tor_lines = xml_tor.readlines() 
        non_zero_k_tor = []
        for i in xml_tor_lines:
            to_find = &#34;k=&#34; + &#39;&#34;&#39; + &#34;0.0&#34; + &#39;&#34;&#39; 
            if to_find not in i:
                non_zero_k_tor.append(i)
        #print(non_zero_k_tor)
        p1 = []
        for i in range(len(non_zero_k_tor)):
            p1.append(int(re.findall(&#39;\d*\.?\d+&#39;,non_zero_k_tor[i])[2]))
        #print(p1)
        p2 = []
        for i in range(len(non_zero_k_tor)):
            p2.append(int(re.findall(&#39;\d*\.?\d+&#39;,non_zero_k_tor[i])[4]))
        #print(p2)
        p3 = []
        for i in range(len(non_zero_k_tor)):
            p3.append(int(re.findall(&#39;\d*\.?\d+&#39;,non_zero_k_tor[i])[6]))
        #print(p3)
        p4 = []
        for i in range(len(non_zero_k_tor)):
            p4.append(int(re.findall(&#39;\d*\.?\d+&#39;,non_zero_k_tor[i])[8]))
        #print(p4)
        periodicity = []
        for i in range(len(non_zero_k_tor)):
            periodicity.append(int(re.findall(&#39;\d*\.?\d+&#39;,non_zero_k_tor[i])[9]))
        #print(periodicity)
        xml_tor_reparams = open(self.reparameterised_system_xml_file, &#39;r&#39;) 
        xml_tor_reparams_lines = xml_tor_reparams.readlines() 
        for j in range(len(xml_tor_reparams_lines)):
            for i in range(len(non_zero_k_tor)):
                to_find_tor = &#34;p1=&#34; + &#39;&#34;&#39; + str(p1[i]) + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + str(p2[i]) + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + str(p3[i]) + &#39;&#34;&#39; + &#34; &#34; + &#34;p4=&#34; + &#39;&#34;&#39; + str(p4[i]) + &#39;&#34;&#39; + &#34; &#34; + &#34;periodicity=&#34; + &#39;&#34;&#39; + str(periodicity[i]) + &#39;&#34;&#39; 
                if to_find_tor in xml_tor_reparams_lines[j]:
                    #print(xml_tor_reparams_lines[j])
                    xml_tor_reparams_lines[j] = non_zero_k_tor[i]    
        with open(self.reparameterised_torsional_system_xml_file, &#39;w&#39;) as f:
            for i in xml_tor_reparams_lines:
                f.write(i)
####################################################################################################################################################################################</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="parameterize.OPLS_LJ"><code class="name flex">
<span>def <span class="ident">OPLS_LJ</span></span>(<span>system)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OPLS_LJ(system):
    forces = {system.getForce(index).__class__.__name__: system.getForce(index) for index in range(system.getNumForces())}
    nonbonded_force = forces[&#39;NonbondedForce&#39;]
    lorentz = simtk.openmm.openmm.CustomNonbondedForce(&#39;4*epsilon*((sigma/r)^12-(sigma/r)^6); sigma=sqrt(sigma1*sigma2); epsilon=sqrt(epsilon1*epsilon2)&#39;)
    lorentz.setNonbondedMethod(nonbonded_force.getNonbondedMethod())
    lorentz.addPerParticleParameter(&#39;sigma&#39;)
    lorentz.addPerParticleParameter(&#39;epsilon&#39;)
    lorentz.setCutoffDistance(nonbonded_force.getCutoffDistance())
    system.addForce(lorentz)
    LJset = {}
    for index in range(nonbonded_force.getNumParticles()):
        charge, sigma, epsilon = nonbonded_force.getParticleParameters(index)
        LJset[index] = (sigma, epsilon)
        lorentz.addParticle([sigma, epsilon])
        nonbonded_force.setParticleParameters(index, charge, sigma, epsilon * 0)
    for i in range(nonbonded_force.getNumExceptions()):
        (p1, p2, q, sig, eps) = nonbonded_force.getExceptionParameters(i)
        lorentz.addExclusion(p1, p2)
        if eps._value != 0.0:
            #print (p1,p2,sig,eps)
            sig14 = math.sqrt(LJset[p1][0].value_in_unit(simtk.unit.nanometer) * LJset[p2][0].value_in_unit(simtk.unit.nanometer))
            eps14 = math.sqrt(LJset[p1][1].value_in_unit(simtk.unit.kilojoule/simtk.unit.mole) * LJset[p2][1].value_in_unit(simtk.unit.kilojoule/simtk.unit.mole))
            nonbonded_force.setExceptionParameters(i, p1, p2, q, sig14, eps)
    return (system)</code></pre>
</details>
</dd>
<dt id="parameterize.copy_file"><code class="name flex">
<span>def <span class="ident">copy_file</span></span>(<span>source, destination)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_file(source, destination):
    shutil.copy(source, destination)</code></pre>
</details>
</dd>
<dt id="parameterize.dihedral_energy"><code class="name flex">
<span>def <span class="ident">dihedral_energy</span></span>(<span>x, k1, k2, k3, k4=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dihedral_energy (x, k1, k2, k3, k4 = 0):
    energy_1 = k1 * (1 + np.cos (1 * x * 0.01745))
    energy_2 = k2 * (1 - np.cos (2 * x * 0.01745))
    energy_3 = k3 * (1 + np.cos (3 * x * 0.01745))
    energy_4 = k4 * (1 - np.cos (4 * x *0.01745))
    dihedral_energy = energy_1 + energy_2 + energy_3 + energy_4
    return (dihedral_energy)</code></pre>
</details>
</dd>
<dt id="parameterize.dot_product"><code class="name flex">
<span>def <span class="ident">dot_product</span></span>(<span>u_PA, eig_AB)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dot_product(u_PA , eig_AB):
    x = 0     
    for i in range(0,3):
        x = x + u_PA[i] * eig_AB[i].conjugate()
    return x </code></pre>
</details>
</dd>
<dt id="parameterize.error_function"><code class="name flex">
<span>def <span class="ident">error_function</span></span>(<span>delta_qm, delta_mm)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error_function(delta_qm, delta_mm):
    squared_error = np.square(np.subtract(delta_qm, delta_mm))
    mean_squared_error = squared_error.mean()
    root_mean_squared_error = math.sqrt(mean_squared_error)
    return (root_mean_squared_error)</code></pre>
</details>
</dd>
<dt id="parameterize.error_function_boltzmann"><code class="name flex">
<span>def <span class="ident">error_function_boltzmann</span></span>(<span>delta_qm, delta_mm, T)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error_function_boltzmann(delta_qm, delta_mm, T):
    kb = 3.297623483* 10**(-24) # in cal/K
    delta_qm_boltzmann_weighted = [np.exp(-i / (kb * T)) for i in delta_qm]
    squared_error = np.square(np.subtract(delta_qm, delta_mm)) * delta_qm_boltzmann_weighted
    mean_squared_error = squared_error.mean()
    root_mean_squared_error = math.sqrt(mean_squared_error)
    return (root_mean_squared_error)</code></pre>
</details>
</dd>
<dt id="parameterize.fit_params"><code class="name flex">
<span>def <span class="ident">fit_params</span></span>(<span>qm_scan_file, load_topology, system_xml, method)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_params(qm_scan_file, load_topology, system_xml, method):
    k_guess = gen_init_guess(qm_scan_file = qm_scan_file, load_topology = load_topology, system_xml = system_xml)
    x_data = np.array(get_dihedrals(qm_scan_file))
    delta_qm = np.array(scale_list(list_hartree_kcal(list_ = get_qm_energies(qm_scan_file)))) 
    optimise = scipy.optimize.minimize(objective_function, k_guess, args=(x_data,delta_qm), method = method, bounds = [(0.00, None), (0.00, None), (0.00, None), (0.00, None)])
    return(optimise.x)</code></pre>
</details>
</dd>
<dt id="parameterize.force_angle_constant"><code class="name flex">
<span>def <span class="ident">force_angle_constant</span></span>(<span>atom_A, atom_B, atom_C, bond_lengths, eigenvalues, eigenvectors, coords, scaling_1, scaling_2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def force_angle_constant( atom_A, atom_B, atom_C, bond_lengths, eigenvalues, eigenvectors, coords, scaling_1, scaling_2 ):
    # Force Constant- Equation 14 of seminario calculation paper - gives force constant for angle (in kcal/mol/rad^2) and equilibrium angle in degrees
    # Vectors along bonds calculated
    diff_AB = coords[atom_B,:] - coords[atom_A,:]
    norm_diff_AB = np.linalg.norm(diff_AB)
    u_AB = diff_AB / norm_diff_AB
    diff_CB = coords[atom_B,:] - coords[atom_C,:]
    norm_diff_CB = np.linalg.norm(diff_CB)
    u_CB = diff_CB / norm_diff_CB
    # Bond lengths and eigenvalues found
    bond_length_AB = bond_lengths[atom_A,atom_B]
    eigenvalues_AB = eigenvalues[atom_A, atom_B, :]
    eigenvectors_AB = eigenvectors[0:3, 0:3, atom_A, atom_B]
    bond_length_BC = bond_lengths[atom_B,atom_C]
    eigenvalues_CB = eigenvalues[atom_C, atom_B,  :]
    eigenvectors_CB = eigenvectors[0:3, 0:3, atom_C, atom_B]
    # Normal vector to angle plane found
    u_N = unit_vector_N( u_CB, u_AB )
    u_PA = np.cross(u_N,  u_AB)
    norm_u_PA = np.linalg.norm(u_PA)
    u_PA = u_PA / norm_u_PA
    u_PC = np.cross(u_CB, u_N)
    norm_u_PC = np.linalg.norm(u_PC)
    u_PC = u_PC / norm_u_PC
    sum_first = 0 
    sum_second = 0
    # Projections of eigenvalues
    for i in range(0,3):
        eig_AB_i = eigenvectors_AB[:,i]
        eig_BC_i = eigenvectors_CB[:,i]
        sum_first = sum_first + ( eigenvalues_AB[i] * abs(dot_product(u_PA , eig_AB_i) ) ) 
        sum_second = sum_second +  ( eigenvalues_CB[i] * abs(dot_product(u_PC, eig_BC_i) ) ) 
    # Scaling due to additional angles - Modified Seminario Part
    sum_first = sum_first/scaling_1 
    sum_second = sum_second/scaling_2
    # Added as two springs in series
    k_theta = ( 1 / ( (bond_length_AB**2) * sum_first) ) + ( 1 / ( (bond_length_BC**2) * sum_second) ) 
    k_theta = 1/k_theta
    k_theta = - k_theta #Change to OPLS form
    k_theta = abs(k_theta * 0.5) #Change to OPLS form
    # Equilibrium Angle
    theta_0 = math.degrees(math.acos(np.dot(u_AB, u_CB)))
    # If the vectors u_CB and u_AB are linearly dependent u_N cannot be defined
    # This case is dealt with here
    if abs(sum((u_CB) - (u_AB))) &lt; 0.01 or ( abs(sum((u_CB) - (u_AB))) &gt; 1.99 and abs(sum((u_CB) - (u_AB))) &lt; 2.01):
        scaling_1 = 1 
        scaling_2 = 1
        [ k_theta, theta_0 ] = force_angle_constant_special_case( atom_A, atom_B, atom_C, bond_lengths, eigenvalues, eigenvectors, coords, scaling_1, scaling_2 )
    return k_theta, theta_0</code></pre>
</details>
</dd>
<dt id="parameterize.force_angle_constant_special_case"><code class="name flex">
<span>def <span class="ident">force_angle_constant_special_case</span></span>(<span>atom_A, atom_B, atom_C, bond_lengths, eigenvalues, eigenvectors, coords, scaling_1, scaling_2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def force_angle_constant_special_case( atom_A, atom_B, atom_C, bond_lengths, eigenvalues, eigenvectors, coords, scaling_1, scaling_2 ):
    # Force Constant- Equation 14 of seminario calculation paper - gives force constant for angle (in kcal/mol/rad^2) and equilibrium angle in degrees
    # Deals with cases when u_N cannot be defined and instead takes samples of u_N across a unit sphere. 
    # Vectors along bonds calculated
    diff_AB = coords[atom_B,:] - coords[atom_A,:]
    norm_diff_AB = np.linalg.norm(diff_AB)
    u_AB = diff_AB / norm_diff_AB
    diff_CB = coords[atom_B,:] - coords[atom_C,:]
    norm_diff_CB = np.linalg.norm(diff_CB)
    u_CB = diff_CB / norm_diff_CB
    # Bond lengths and eigenvalues found
    bond_length_AB = bond_lengths[atom_A,atom_B]
    eigenvalues_AB = eigenvalues[atom_A, atom_B, :]
    eigenvectors_AB = eigenvectors[0:3, 0:3, atom_A, atom_B]
    bond_length_BC = bond_lengths[atom_B,atom_C]
    eigenvalues_CB = eigenvalues[atom_C, atom_B,  :]
    eigenvectors_CB = eigenvectors[0:3, 0:3, atom_C, atom_B]
    k_theta_array = np.zeros((180, 360))
    # Find force constant with varying u_N (with vector uniformly sampled across a sphere)
    for theta in range(0,180):
        for phi in range(0,360):   
            r = 1
            u_N = [r * math.sin(math.radians(theta))*math.cos(math.radians(theta)),r * math.sin(math.radians(theta))*math.sin(math.radians(theta)), r*math.cos(math.radians(theta)) ]
            u_PA = np.cross(u_N,  u_AB)
            u_PA = u_PA / np.linalg.norm(u_PA)
            u_PC = np.cross(u_CB, u_N)
            u_PC = u_PC / np.linalg.norm(u_PC)
            sum_first = 0
            sum_second = 0
            # Projections of eigenvalues
            for i in range(0,3):
                eig_AB_i = eigenvectors_AB[:,i]
                eig_BC_i = eigenvectors_CB[:,i]
                sum_first = sum_first + ( eigenvalues_AB[i] * abs(dot_product(u_PA , eig_AB_i) ) ) 
                sum_second = sum_second +  ( eigenvalues_CB[i] * abs(dot_product(u_PC, eig_BC_i) ) ) 
            # Added as two springs in series
            k_theta_ij = ( 1 / ( (bond_length_AB**2) * sum_first) ) + ( 1 / ( (bond_length_BC**2) * sum_second) ) 
            k_theta_ij = 1/k_theta_ij
            k_theta_ij = - k_theta_ij #Change to OPLS form
            k_theta_ij = abs(k_theta_ij * 0.5) #Change to OPLS form
            k_theta_array[theta, phi] = k_theta_ij
    # Removes cases where u_N was linearly dependent of u_CB or u_AB
    # Force constant used is taken as the mean
    k_theta = np.mean(np.mean(k_theta_array))
    # Equilibrium Angle independent of u_N
    theta_0 = math.degrees(math.cos(np.dot(u_AB, u_CB)))
    return k_theta, theta_0</code></pre>
</details>
</dd>
<dt id="parameterize.force_constant_bond"><code class="name flex">
<span>def <span class="ident">force_constant_bond</span></span>(<span>atom_A, atom_B, eigenvalues, eigenvectors, coords)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def force_constant_bond(atom_A, atom_B, eigenvalues, eigenvectors, coords):
    # Force Constant - Equation 10 of Seminario paper - gives force constant for bond
    # Eigenvalues and eigenvectors calculated 
    eigenvalues_AB = eigenvalues[atom_A,atom_B,:]
    eigenvectors_AB = eigenvectors[:,:,atom_A,atom_B]
    # Vector along bond 
    diff_AB = np.array(coords[atom_B,:]) - np.array(coords[atom_A,:])
    norm_diff_AB = np.linalg.norm(diff_AB)
    unit_vectors_AB = diff_AB / norm_diff_AB
    k_AB = 0 
    # Projections of eigenvalues 
    for i in range(0,3):
        dot_product = abs(np.dot(unit_vectors_AB, eigenvectors_AB[:,i]))
        k_AB = k_AB + ( eigenvalues_AB[i] * dot_product )
    k_AB = -k_AB * 0.5 # Convert to OPLS form
    return k_AB</code></pre>
</details>
</dd>
<dt id="parameterize.gen_init_guess"><code class="name flex">
<span>def <span class="ident">gen_init_guess</span></span>(<span>qm_scan_file, load_topology, system_xml)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_init_guess(qm_scan_file, load_topology, system_xml):
    x = get_dihedrals(qm_scan_file)
    y  = scale_list(list_ = get_mm_potential_energies(qm_scan_file = qm_scan_file, load_topology = load_topology, system_xml = system_xml))
    init_vals = [0.0, 0.0, 0.0, 0.0]
    k_init_guess, covar = scipy.optimize.curve_fit(dihedral_energy, x, y, p0 = init_vals)
    for i in range(len(k_init_guess)):
        if k_init_guess[i] &lt; 0:
            k_init_guess[i] = 0
    return(k_init_guess)</code></pre>
</details>
</dd>
<dt id="parameterize.generate_mm_pdbs"><code class="name flex">
<span>def <span class="ident">generate_mm_pdbs</span></span>(<span>qm_scan_file, template_pdb)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_mm_pdbs(qm_scan_file, template_pdb):
    with open (qm_scan_file, &#34;r&#34;) as f:
        lines = f.readlines()
    energy_dihedral_lines = []
    for i in range(len(lines)):
        if &#34;Dihedral&#34; in lines[i]:
            energy_dihedral_lines.append(lines[i])
    dihedrals = []
    for i in energy_dihedral_lines:
        energy_dihedral = i 
        energy_dihedral = re.findall(r&#39;[-+]?\d+[.]?\d*&#39;, energy_dihedral)
        dihedral = float(energy_dihedral[0])
        dihedrals.append(dihedral)
    lines_markers = []
    for i in range(len(lines)):
        if &#34;Dihedral&#34; in lines[i]:
            lines_markers.append(i)
    lines_markers.append(len(lines) + 1)
    for i in range(len(lines_markers) - 1):
        #pdb_file_to_write = str(dihedrals[i]) + &#34;.pdb&#34;
        if dihedrals[i] &gt; 0 :
            pdb_file_to_write = &#34;plus_&#34; + str(abs(dihedrals[i])) + &#34;.pdb&#34;
        if dihedrals[i] &lt; 0 :
            pdb_file_to_write = &#34;minus_&#34; + str(abs(dihedrals[i])) + &#34;.pdb&#34;        
        to_begin = lines_markers[i]
        to_end = lines_markers[i+1]
        lines_to_write = lines[to_begin + 1:to_end - 1]
        x_coords = []
        y_coords = []
        z_coords = []
        for i in lines_to_write:
            coordinates = i 
            coordinates = re.findall(r&#39;[-+]?\d+[.]?\d*&#39;, coordinates)
            x = float(coordinates[0])
            y = float(coordinates[1])
            z = float(coordinates[2])
            x_coords.append(x)
            y_coords.append(y)
            z_coords.append(z)
        ppdb = PandasPdb()
        ppdb.read_pdb(template_pdb)
        ppdb.df[&#34;ATOM&#34;][&#34;x_coord&#34;] = x_coords
        ppdb.df[&#34;ATOM&#34;][&#34;y_coord&#34;] = y_coords
        ppdb.df[&#34;ATOM&#34;][&#34;z_coord&#34;] = z_coords    
        ppdb.to_pdb(pdb_file_to_write)  </code></pre>
</details>
</dd>
<dt id="parameterize.generate_xml_from_charged_pdb_sdf"><code class="name flex">
<span>def <span class="ident">generate_xml_from_charged_pdb_sdf</span></span>(<span>system_pdb, system_init_sdf, system_sdf, num_charge_atoms, index_charge_atom_1, charge_atom_1, system_xml)</span>
</code></dt>
<dd>
<div class="desc"><p>This function generates an openforcefield xml file from the pdb file via SDF file and openforcefield.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_xml_from_charged_pdb_sdf(system_pdb, system_init_sdf, system_sdf, num_charge_atoms, index_charge_atom_1, charge_atom_1, system_xml):
    &#34;&#34;&#34;
    This function generates an openforcefield xml file from the pdb file via SDF file and openforcefield.
    &#34;&#34;&#34;
    command = &#34;babel -ipdb &#34; + system_pdb + &#34; -osdf &#34; + system_init_sdf
    os.system(command)
    with open(system_init_sdf, &#39;r&#39;) as f1 :
        filedata = f1.readlines()
        filedata = filedata[:-2]
    with open(system_sdf, &#34;w+&#34;) as out:
        for i in filedata:
            out.write(i)
        line_1 = &#34;M  CHG  &#34; + str(num_charge_atoms) + &#34;   &#34; + str(index_charge_atom_1)   + &#34;   &#34; + str(charge_atom_1) + &#34;\n&#34; 
        line_2 = &#34;M  END&#34; + &#34;\n&#34;
        line_3 = &#34;$$$$&#34;
        out.write(line_1)
        out.write(line_2)
        out.write(line_3)
    off_molecule = openforcefield.topology.Molecule(system_sdf)
    force_field = openforcefield.typing.engines.smirnoff.ForceField(&#39;openff_unconstrained-1.0.0.offxml&#39;)
    system = force_field.create_openmm_system(off_molecule.to_topology())
    pdbfile = simtk.openmm.app.PDBFile(system_pdb)
    structure = parmed.openmm.load_topology(pdbfile.topology, system, xyz = pdbfile.positions)
    with open(system_xml, &#39;w&#39;) as f:
        f.write(simtk.openmm.XmlSerializer.serialize(system)) </code></pre>
</details>
</dd>
<dt id="parameterize.generate_xml_from_pdb_sdf"><code class="name flex">
<span>def <span class="ident">generate_xml_from_pdb_sdf</span></span>(<span>system_pdb, system_sdf, system_xml)</span>
</code></dt>
<dd>
<div class="desc"><p>This function generates an openforcefield xml file from the pdb file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_xml_from_pdb_sdf(system_pdb, system_sdf, system_xml):
    &#34;&#34;&#34;
    This function generates an openforcefield xml file from the pdb file
    &#34;&#34;&#34;
    command = &#34;babel -ipdb &#34; + system_pdb + &#34; -osdf &#34; + system_sdf
    os.system(command)
    off_molecule = openforcefield.topology.Molecule(system_sdf)
    force_field = openforcefield.typing.engines.smirnoff.ForceField(&#39;openff_unconstrained-1.0.0.offxml&#39;)
    system = force_field.create_openmm_system(off_molecule.to_topology())
    pdbfile = simtk.openmm.app.PDBFile(system_pdb)
    structure = parmed.openmm.load_topology(pdbfile.topology, system, xyz = pdbfile.positions)
    with open(system_xml, &#39;w&#39;) as f:
        f.write(simtk.openmm.XmlSerializer.serialize(system)) </code></pre>
</details>
</dd>
<dt id="parameterize.get_dihedrals"><code class="name flex">
<span>def <span class="ident">get_dihedrals</span></span>(<span>qm_scan_file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dihedrals(qm_scan_file):
    with open(qm_scan_file, &#34;r&#34;) as f:
        lines = f.readlines()
    energy_dihedral_lines = []
    for i in range(len(lines)):
        if &#34;Dihedral&#34; in lines[i]:
            energy_dihedral_lines.append(lines[i])
    dihedrals = []
    for i in energy_dihedral_lines:
        energy_dihedral = i
        energy_dihedral = re.findall(r&#39;[-+]?\d+[.]?\d*&#39;, energy_dihedral)
        dihedral = float(energy_dihedral[0])
        dihedrals.append(dihedral)
    return(dihedrals)</code></pre>
</details>
</dd>
<dt id="parameterize.get_mm_potential_energies"><code class="name flex">
<span>def <span class="ident">get_mm_potential_energies</span></span>(<span>qm_scan_file, load_topology, system_xml)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mm_potential_energies(qm_scan_file, load_topology, system_xml):
    mm_pdb_list = []
    for i in get_dihedrals(qm_scan_file):
        if i &gt; 0 :
            pdb_file = &#34;plus_&#34; + str(abs(i)) + &#34;.pdb&#34;
        if i &lt; 0 :
            pdb_file = &#34;minus_&#34; + str(abs(i)) + &#34;.pdb&#34;  
        mm_pdb_list.append(pdb_file)
    for i in mm_pdb_list:
        mm_pdb_file = i
    mm_potential_energies = []
    for i in mm_pdb_list:
        mm_pdb_file = i
        mm_energy = get_non_torsion_mm_energy(system_pdb = i, load_topology = load_topology, system_xml = system_xml)
        mm_potential_energies.append(mm_energy)
    return(mm_potential_energies)</code></pre>
</details>
</dd>
<dt id="parameterize.get_non_torsion_mm_energy"><code class="name flex">
<span>def <span class="ident">get_non_torsion_mm_energy</span></span>(<span>system_pdb, load_topology, system_xml)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_non_torsion_mm_energy(system_pdb, load_topology, system_xml):
    system_prmtop = system_pdb[:-4] + &#34;.prmtop&#34;
    system_inpcrd = system_pdb[:-4] + &#34;.inpcrd&#34;
    if load_topology == &#34;parmed&#34;:
        openmm_system = parmed.openmm.load_topology(parmed.load_file(system_pdb, structure=True).topology, parmed.load_file(system_xml))
    if load_topology == &#34;openmm&#34;:
        openmm_system = parmed.openmm.load_topology(simtk.openmm.app.PDBFile(system_pdb).topology, parmed.load_file(system_xml))
    openmm_system.save(system_prmtop, overwrite=True)
    openmm_system.coordinates = parmed.load_file(system_pdb, structure=True).coordinates
    openmm_system.save(system_inpcrd, overwrite=True)
    parm = parmed.load_file(system_prmtop, system_inpcrd)
    prmtop_energy_decomposition = parmed.openmm.energy_decomposition_system(parm, parm.createSystem())
    #print(prmtop_energy_decomposition)
    prmtop_energy_decomposition_value_no_torsion =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                                     list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                                     list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
    return(sum(prmtop_energy_decomposition_value_no_torsion))    </code></pre>
</details>
</dd>
<dt id="parameterize.get_qm_energies"><code class="name flex">
<span>def <span class="ident">get_qm_energies</span></span>(<span>qm_scan_file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_qm_energies(qm_scan_file):
    with open(qm_scan_file, &#34;r&#34;) as f:
        lines = f.readlines()
    energy_dihedral_lines = []
    for i in range(len(lines)):
        if &#34;Dihedral&#34; in lines[i]:
            energy_dihedral_lines.append(lines[i])
    qm_energies = []
    for i in energy_dihedral_lines:
        energy_dihedral = i 
        energy_dihedral = re.findall(r&#39;[-+]?\d+[.]?\d*&#39;, energy_dihedral)
        energy = float(energy_dihedral[1])
        qm_energies.append(energy)
    return(qm_energies)</code></pre>
</details>
</dd>
<dt id="parameterize.get_tor_params"><code class="name flex">
<span>def <span class="ident">get_tor_params</span></span>(<span>qm_scan_file, template_pdb, load_topology, system_xml, method)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tor_params(qm_scan_file, template_pdb, load_topology, system_xml, method):
    qm_e = get_qm_energies(qm_scan_file = qm_scan_file)
    qm_e_kcal = list_hartree_kcal(qm_e)
    delta_qm = scale_list(qm_e_kcal)
    generate_mm_pdbs(qm_scan_file = qm_scan_file, template_pdb = template_pdb)
    mm_pe_no_torsion_kcal = get_mm_potential_energies(qm_scan_file = qm_scan_file, load_topology = load_topology, system_xml = system_xml)
    delta_mm = scale_list(mm_pe_no_torsion_kcal)  
    opt_param = fit_params(qm_scan_file = qm_scan_file, load_topology = load_topology, system_xml = system_xml, method = method)
    return(opt_param)</code></pre>
</details>
</dd>
<dt id="parameterize.get_torsional_lines"><code class="name flex">
<span>def <span class="ident">get_torsional_lines</span></span>(<span>template_pdb, system_xml, qm_scan_file, load_topology, method, dihedral_text_file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_torsional_lines(template_pdb, system_xml, qm_scan_file, load_topology, method, dihedral_text_file):
    opt_param = get_tor_params(qm_scan_file = qm_scan_file, template_pdb = template_pdb, load_topology = load_topology, system_xml = system_xml, method = method)
    dihedral_text = open(dihedral_text_file, &#39;r&#39;)
    dihedral_text_lines = dihedral_text.readlines()
    atom_numbers = dihedral_text_lines[-1]
    atom_index_from_1 = [int(re.findall(r&#39;\d+&#39;, atom_numbers)[0]), int(re.findall(r&#39;\d+&#39;, atom_numbers)[1]), int(re.findall(r&#39;\d+&#39;, atom_numbers)[2]), int(re.findall(r&#39;\d+&#39;, atom_numbers)[3])]
    atom_index = [i -1 for i in atom_index_from_1]
    atom_index_lines = &#34; &#34; + &#34;p1=&#34; + &#39;&#34;&#39; + str(atom_index[0]) + &#39;&#34;&#39; + &#34; &#34; +  &#34;p2=&#34; + &#39;&#34;&#39; + str(atom_index[1]) + &#39;&#34;&#39; + &#34; &#34; +  &#34;p3=&#34; + &#39;&#34;&#39; + str(atom_index[2]) + &#39;&#34;&#39; + &#34; &#34; +  &#34;p4=&#34; + &#39;&#34;&#39; + str(atom_index[3]) + &#39;&#34;&#39; + &#34; &#34;  
    tor_lines = []
    for i in range(len(opt_param)):
        line_to_append = &#34;                &#34; + &#34;&lt;Torsion &#34; + &#34;k=&#34; + &#39;&#34;&#39; + str(round(opt_param[i], 8)) + &#39;&#34;&#39; + atom_index_lines + &#34;periodicity=&#34; + &#39;&#34;&#39; + str(i+1) + &#39;&#34;&#39; + &#34; &#34; + &#34;phase=&#34; + &#39;&#34;&#39; + &#34;0&#34; + &#39;&#34;&#39; + &#34;/&gt;&#34;
        #print(line_to_append)
        tor_lines.append(line_to_append)
    return(tor_lines)</code></pre>
</details>
</dd>
<dt id="parameterize.list_diff"><code class="name flex">
<span>def <span class="ident">list_diff</span></span>(<span>list_1, list_2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_diff(list_1, list_2):
    diff_list = []
    zipped_list = zip(list_1, list_2)
    for list1_i, list2_i in zipped_list:
        diff_list.append(list1_i-list2_i)
    return(diff_list)</code></pre>
</details>
</dd>
<dt id="parameterize.list_hartree_kcal"><code class="name flex">
<span>def <span class="ident">list_hartree_kcal</span></span>(<span>list_)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_hartree_kcal(list_):
    converted_list = [i * 627.5094 for i in list_]
    return (converted_list)</code></pre>
</details>
</dd>
<dt id="parameterize.list_kJ_kcal"><code class="name flex">
<span>def <span class="ident">list_kJ_kcal</span></span>(<span>list_)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_kJ_kcal(list_):
    converted_list = [i / 4.184 for i in list_]
    return (converted_list)</code></pre>
</details>
</dd>
<dt id="parameterize.list_to_dict"><code class="name flex">
<span>def <span class="ident">list_to_dict</span></span>(<span>lst)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_to_dict(lst):
    res_dct = {lst[i]: lst[i + 1] for i in range(0, len(lst), 2)}
    return (res_dct)</code></pre>
</details>
</dd>
<dt id="parameterize.objective_function"><code class="name flex">
<span>def <span class="ident">objective_function</span></span>(<span>k_array, x, delta_qm)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def objective_function(k_array, x, delta_qm):
    delta_mm = dihedral_energy(x, k1 = k_array[0], k2 = k_array[1], k3 = k_array[2],  k4 = k_array[3])    
    loss_function = error_function(delta_qm, delta_mm)
    return(loss_function)</code></pre>
</details>
</dd>
<dt id="parameterize.remove_mm_files"><code class="name flex">
<span>def <span class="ident">remove_mm_files</span></span>(<span>qm_scan_file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_mm_files(qm_scan_file):
    mm_pdb_list = []
    for i in get_dihedrals(qm_scan_file):
        if i &gt; 0 :
            pdb_file = &#34;plus_&#34; + str(abs(i)) + &#34;.pdb&#34;
        if i &lt; 0 :
            pdb_file = &#34;minus_&#34; + str(abs(i)) + &#34;.pdb&#34;  
        mm_pdb_list.append(pdb_file)
    for i in mm_pdb_list:
        command = &#34;rm -rf  &#34; + i 
        os.system(command) 
        command = &#34;rm -rf  &#34; + i[:-4] + &#34;.inpcrd&#34;
        os.system(command) 
        command = &#34;rm -rf  &#34; + i[:-4] + &#34;.prmtop&#34;
        os.system(command) </code></pre>
</details>
</dd>
<dt id="parameterize.reverse_list"><code class="name flex">
<span>def <span class="ident">reverse_list</span></span>(<span>lst)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverse_list(lst): 
    reversed_list = lst[::-1] 
    return (reversed_list)</code></pre>
</details>
</dd>
<dt id="parameterize.scale_list"><code class="name flex">
<span>def <span class="ident">scale_list</span></span>(<span>list_)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale_list(list_):
    scaled_list = [i - min(list_) for i in list_]
    return (scaled_list)</code></pre>
</details>
</dd>
<dt id="parameterize.search_in_file"><code class="name flex">
<span>def <span class="ident">search_in_file</span></span>(<span>file: str, word: str) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Search for the given string in file and return lines containing that string along with line numbers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_in_file(file: str, word: str) -&gt; list:
    &#34;&#34;&#34;Search for the given string in file and return lines containing that string along with line numbers&#34;&#34;&#34;
    line_number = 0
    list_of_results = []
    with open(file, &#39;r&#39;) as f:
        for line in f:
            line_number += 1
            if word in line:
                list_of_results.append((line_number, line.rstrip()))
    return(list_of_results)</code></pre>
</details>
</dd>
<dt id="parameterize.torsiondrive_input_to_xyz"><code class="name flex">
<span>def <span class="ident">torsiondrive_input_to_xyz</span></span>(<span>psi_input_file, xyz_file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def torsiondrive_input_to_xyz(psi_input_file, xyz_file): 
    with open (psi_input_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;molecule {&#34; in lines[i]:
            to_begin = int(i)   
        if &#34;set {&#34; in lines[i]:
            to_end = int(i)  
    xyz_lines = lines[to_begin + 2 : to_end - 1]
    with open(xyz_file, &#39;w&#39;) as f:
        f.write(str(len(xyz_lines)) + &#34;\n&#34;)
        f.write(xyz_file + &#34;\n&#34;)
        for i in xyz_lines:
            f.write(i)</code></pre>
</details>
</dd>
<dt id="parameterize.u_PA_from_angles"><code class="name flex">
<span>def <span class="ident">u_PA_from_angles</span></span>(<span>atom_A, atom_B, atom_C, coords)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def  u_PA_from_angles(atom_A, atom_B, atom_C, coords):
    # Gives the vector in the plane A,B,C and perpendicular to A to B
    diff_AB = coords[atom_B,:] - coords[atom_A,:]
    norm_diff_AB = np.linalg.norm(diff_AB)
    u_AB = diff_AB / norm_diff_AB
    diff_CB = coords[atom_B,:] - coords[atom_C,:]
    norm_diff_CB = np.linalg.norm(diff_CB)
    u_CB = diff_CB / norm_diff_CB
    u_N = unit_vector_N( u_CB, u_AB )
    u_PA = np.cross(u_N,  u_AB)
    norm_PA = np.linalg.norm(u_PA)
    u_PA = u_PA /norm_PA;
    return u_PA</code></pre>
</details>
</dd>
<dt id="parameterize.uniq"><code class="name flex">
<span>def <span class="ident">uniq</span></span>(<span>input_)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uniq(input_):
    output = []
    for x in input_:
        if x not in output:
            output.append(x)
    return output</code></pre>
</details>
</dd>
<dt id="parameterize.unit_vector_N"><code class="name flex">
<span>def <span class="ident">unit_vector_N</span></span>(<span>u_BC, u_AB)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unit_vector_N(u_BC, u_AB):
    # Calculates unit normal vector which is perpendicular to plane ABC
    cross_product = np.cross(u_BC, u_AB)
    norm_u_N = np.linalg.norm(cross_product)
    u_N = cross_product / norm_u_N
    return u_N</code></pre>
</details>
</dd>
<dt id="parameterize.xyz_to_pdb"><code class="name flex">
<span>def <span class="ident">xyz_to_pdb</span></span>(<span>xyz_file, coords_file, template_pdb, system_pdb)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xyz_to_pdb(xyz_file, coords_file, template_pdb, system_pdb):
    with open (xyz_file, &#34;r&#34;) as f:
        lines = f.readlines()
    needed_lines = lines[2:]
    with open(coords_file, &#39;w&#39;) as f:
        for i in needed_lines:
            f.write(i)
    df = pd.read_csv(coords_file, header = None, delimiter = r&#34;\s+&#34;)
    df.columns = [&#34;atom&#34;, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;]
    ppdb = PandasPdb()
    ppdb.read_pdb(template_pdb)
    ppdb.df[&#34;ATOM&#34;][&#34;x_coord&#34;] = df[&#34;x&#34;]
    ppdb.df[&#34;ATOM&#34;][&#34;y_coord&#34;] = df[&#34;y&#34;]
    ppdb.df[&#34;ATOM&#34;][&#34;z_coord&#34;] = df[&#34;z&#34;]  
    ppdb.to_pdb(system_pdb)  </code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="parameterize.GuestAmberXMLAmber"><code class="flex name class">
<span>class <span class="ident">GuestAmberXMLAmber</span></span>
<span>(</span><span>charge, num_charge_atoms, charge_atom_1, index_charge_atom_1, system_pdb='guest_init_II.pdb', system_mol2='guest.mol2', system_in='guest.in', system_frcmod='guest.frcmod', prmtop_system='guest.prmtop', inpcrd_system='guest.inpcrd', system_leap='guest.leap', system_xml='guest_init.xml', system_smi='guest.smi', system_sdf='guest.sdf', system_init_sdf='guest_init.sdf', index_charge_atom_2=' ', charge_atom_2=' ', charge_parameter_file='guest_charges.txt', system_qm_pdb='guest_init_II.pdb', bond_parameter_file='guest_bonds.txt', angle_parameter_file='guest_angles.txt', system_qm_params_file='guest_qm_params.txt', reparameterised_intermediate_system_xml_file='guest_intermediate_reparameterised.xml', system_xml_non_bonded_file='guest_xml_non_bonded.txt', system_xml_non_bonded_reparams_file='guest_xml_non_bonded_reparams.txt', reparameterised_system_xml_file='guest_reparameterised.xml', non_reparameterised_system_xml_file='guest_init.xml', prmtop_system_non_params='guest_non_params.prmtop', inpcrd_system_non_params='guest_non_params.inpcrd', prmtop_system_params='guest_params.prmtop', inpcrd_system_params='guest_params.inpcrd', load_topology='openmm')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GuestAmberXMLAmber:

    def __init__(self, charge, num_charge_atoms, charge_atom_1, index_charge_atom_1, system_pdb = &#34;guest_init_II.pdb&#34;, system_mol2 = &#34;guest.mol2&#34;, system_in = &#34;guest.in&#34;, system_frcmod = &#34;guest.frcmod&#34;, prmtop_system = &#34;guest.prmtop&#34;, inpcrd_system = &#34;guest.inpcrd&#34;, system_leap = &#34;guest.leap&#34;, system_xml = &#34;guest_init.xml&#34;,  system_smi =  &#34;guest.smi&#34;,  system_sdf =  &#34;guest.sdf&#34;, system_init_sdf = &#34;guest_init.sdf&#34;, index_charge_atom_2 = &#34; &#34;, charge_atom_2 = &#34; &#34;, charge_parameter_file = &#34;guest_charges.txt&#34;, system_qm_pdb = &#34;guest_init_II.pdb&#34;, bond_parameter_file = &#34;guest_bonds.txt&#34;, angle_parameter_file = &#34;guest_angles.txt&#34;, system_qm_params_file = &#34;guest_qm_params.txt&#34;, reparameterised_intermediate_system_xml_file = &#34;guest_intermediate_reparameterised.xml&#34;, system_xml_non_bonded_file = &#34;guest_xml_non_bonded.txt&#34;, system_xml_non_bonded_reparams_file = &#34;guest_xml_non_bonded_reparams.txt&#34;, reparameterised_system_xml_file = &#34;guest_reparameterised.xml&#34;, non_reparameterised_system_xml_file = &#34;guest_init.xml&#34;, prmtop_system_non_params = &#34;guest_non_params.prmtop&#34;, inpcrd_system_non_params = &#34;guest_non_params.inpcrd&#34;, prmtop_system_params = &#34;guest_params.prmtop&#34;, inpcrd_system_params = &#34;guest_params.inpcrd&#34;, load_topology = &#34;openmm&#34;):   
        self.charge = charge
        self.num_charge_atoms = num_charge_atoms
        self.charge_atom_1 = charge_atom_1
        self.index_charge_atom_1 = index_charge_atom_1
        self.system_pdb = system_pdb
        self.system_mol2 = system_mol2
        self.system_in = system_in
        self.system_frcmod = system_frcmod
        self.prmtop_system = prmtop_system
        self.inpcrd_system = inpcrd_system
        self.system_leap = system_leap
        self.system_xml = system_xml
        self.system_smi = system_smi
        self.system_sdf = system_sdf
        self.system_init_sdf = system_init_sdf
        self.index_charge_atom_2 = index_charge_atom_2
        self.charge_atom_2 = charge_atom_2
        self.charge_parameter_file = charge_parameter_file
        self.system_qm_pdb = system_qm_pdb
        self.bond_parameter_file = bond_parameter_file
        self.angle_parameter_file = angle_parameter_file
        self.system_qm_params_file = system_qm_params_file
        self.reparameterised_intermediate_system_xml_file  = reparameterised_intermediate_system_xml_file
        self.system_xml_non_bonded_file = system_xml_non_bonded_file
        self.system_xml_non_bonded_reparams_file = system_xml_non_bonded_reparams_file
        self.reparameterised_system_xml_file = reparameterised_system_xml_file
        self.non_reparameterised_system_xml_file = non_reparameterised_system_xml_file
        self.prmtop_system_non_params = prmtop_system_non_params
        self.inpcrd_system_non_params = inpcrd_system_non_params
        self.prmtop_system_params = prmtop_system_params
        self.inpcrd_system_params = inpcrd_system_params
        self.load_topology = load_topology

    def generate_xml_antechamber(self):
        &#34;&#34;&#34;
        This function generates an xml file from the pdb file through antechamber
        &#34;&#34;&#34;
        command = &#34;babel -ipdb &#34; +  self.system_pdb + &#34; -omol2 &#34; +  self.system_mol2
        os.system(command)
        command = &#34;antechamber -i &#34; + self.system_mol2 +  &#34; -fi mol2 -o &#34; + self.system_in + &#34; -fo prepi -c bcc -nc &#34; + str(self.charge)
        os.system(command)
        command = &#34;parmchk2 -i &#34; + self.system_in + &#34; -o &#34; + self.system_frcmod + &#34; -f prepi -a Y&#34;
        os.system(command)
        os.system(&#34;rm -rf ANTECHAMBER* leap.log sqm* ATOMTYPE.INF PREP.INF NEWPDB.PDB&#34;)
        line_1 = &#34;loadamberprep &#34; + self.system_in
        line_2 = &#34;loadamberparams &#34; + self.system_frcmod
        line_3 = &#34;pdb = loadpdb &#34; + self.system_pdb
        line_4 = &#34;saveamberparm pdb &#34; + self.prmtop_system + &#34; &#34; + self.inpcrd_system
        line_5 = &#34;quit&#34;
        with open(self.system_leap, &#39;w&#39;) as f:
            f.write(&#34;    &#34; + &#34;\n&#34;)
            f.write(line_1 + &#34;\n&#34;)
            f.write(line_2 + &#34;\n&#34;)
            f.write(line_3 + &#34;\n&#34;)
            f.write(line_4 + &#34;\n&#34;)
            f.write(line_5 + &#34;\n&#34;)
        command = &#34;tleap -f &#34; + self.system_leap
        os.system(command)
        parm = parmed.load_file(self.prmtop_system, self.inpcrd_system)
        system = parm.createSystem()
        with open(self.system_xml, &#39;w&#39;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system)) 

    def generate_xml_from_pdb_smi(self):
        &#34;&#34;&#34;
        This function generates an openforcefield xml file from the pdb file
        &#34;&#34;&#34;
        off_molecule = openforcefield.topology.Molecule(self.system_smi)
        force_field = openforcefield.typing.engines.smirnoff.ForceField(&#39;openff_unconstrained-1.0.0.offxml&#39;)
        system = force_field.create_openmm_system(off_molecule.to_topology())
        pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
        structure = parmed.openmm.load_topology(pdbfile.topology, system, xyz = pdbfile.positions)
        with open(self.system_xml, &#39;w&#39;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))   

    def generate_xml_from_pdb_sdf(self):
        &#34;&#34;&#34;
        This function generates an openforcefield xml file from the pdb file
        &#34;&#34;&#34;
        command = &#34;babel -ipdb &#34; + self.system_pdb + &#34; -osdf &#34; + self.system_sdf
        os.system(command)
        off_molecule = openforcefield.topology.Molecule(self.system_sdf)
        force_field = openforcefield.typing.engines.smirnoff.ForceField(&#39;openff_unconstrained-1.0.0.offxml&#39;)
        system = force_field.create_openmm_system(off_molecule.to_topology())
        pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
        structure = parmed.openmm.load_topology(pdbfile.topology, system, xyz = pdbfile.positions)
        with open(self.system_xml, &#39;w&#39;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))    

    def generate_xml_from_charged_pdb_sdf(self):
        &#34;&#34;&#34;
        This function generates an openforcefield xml file from the pdb file via SDF file and openforcefield.
        &#34;&#34;&#34;
        command = &#34;babel -ipdb &#34; + self.system_pdb + &#34; -osdf &#34; + self.system_init_sdf
        os.system(command)
        with open(self.system_init_sdf, &#39;r&#39;) as f1 :
            filedata = f1.readlines()
            filedata = filedata[:-2]
        with open(self.system_sdf, &#34;w+&#34;) as out:
            for i in filedata:
                out.write(i)
            line_1 = &#34;M  CHG  &#34; + str(self.num_charge_atoms) + &#34;   &#34; + str(self.index_charge_atom_1)   + &#34;   &#34; + str(self.charge_atom_1) + &#34;\n&#34; 
            line_2 = &#34;M  END&#34; + &#34;\n&#34;
            line_3 = &#34;$$$$&#34;
            out.write(line_1)
            out.write(line_2)
            out.write(line_3)
        off_molecule = openforcefield.topology.Molecule(self.system_sdf)
        force_field = openforcefield.typing.engines.smirnoff.ForceField(&#39;openff_unconstrained-1.0.0.offxml&#39;)
        system = force_field.create_openmm_system(off_molecule.to_topology())
        pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
        structure = parmed.openmm.load_topology(pdbfile.topology, system, xyz = pdbfile.positions)
        with open(self.system_xml, &#39;w&#39;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))  

    def generate_xml_from_doubly_charged_pdb_sdf(self):
        &#34;&#34;&#34;
        This function generates an openforcefield xml file from the pdb file via SDF file and openforcefield.
        &#34;&#34;&#34;
        command = &#34;babel -ipdb &#34; + self.system_pdb + &#34; -osdf &#34; + self.system_init_sdf
        os.system(command)
        with open(self.system_init_sdf, &#39;r&#39;) as f1 :
            filedata = f1.readlines()
            filedata = filedata[:-2]
        with open(self.system_sdf, &#34;w+&#34;) as out:
            for i in filedata:
                out.write(i)
            line_1 = &#34;M  CHG  &#34; + str(self.num_charge_atoms) + &#34;   &#34; + str(self.index_charge_atom_1)   + &#34;   &#34; + str(self.charge_atom_1) + &#34;   &#34; + str(self.index_charge_atom_2)   + &#34;   &#34; + str(self.charge_atom_2) + &#34;\n&#34; 
            line_2 = &#34;M  END&#34; + &#34;\n&#34;
            line_3 = &#34;$$$$&#34;
            out.write(line_1)
            out.write(line_2)
            out.write(line_3)
        off_molecule = openforcefield.topology.Molecule(self.system_sdf)
        force_field = openforcefield.typing.engines.smirnoff.ForceField(&#39;openff_unconstrained-1.0.0.offxml&#39;)
        system = force_field.create_openmm_system(off_molecule.to_topology())
        pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
        structure = parmed.openmm.load_topology(pdbfile.topology, system, xyz = pdbfile.positions)
        with open(self.system_xml, &#39;w&#39;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))      
    
    def write_system_params(self):
        &#34;&#34;&#34;
        This function saves the parameters obtained from the QM log files in a text file. 
        &#34;&#34;&#34;
        # Charges from QM files
        df_charges = pd.read_csv(self.charge_parameter_file, header = None, delimiter = r&#34;\s+&#34;)
        df_charges.columns = [&#34;atom&#34;, &#34;charges&#34;]
        qm_charges = df_charges[&#34;charges&#34;].values.tolist()
        qm_charges = [round(num, 6) for num in qm_charges]
        #print(qm_charges)
        # Bond Parameters from QM files
        ppdb = PandasPdb()
        ppdb.read_pdb(self.system_qm_pdb)
        atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
        atom_name_list = [i - 1 for i in atom_name_list]
        #print(atom_name_list)
        df = pd.read_csv(self.bond_parameter_file, header = None, delimiter = r&#34;\s+&#34;)
        df.columns = [&#34;bond&#34;, &#34;k_bond&#34;, &#34;bond_length&#34;, &#34;bond_1&#34;, &#34;bond_2&#34;]
        #print(df.head())
        bond_1_list = df[&#34;bond_1&#34;].values.tolist()
        bond_1_list = [x - 1 + min(atom_name_list) for x in bond_1_list]
        bond_2_list = df[&#34;bond_2&#34;].values.tolist()
        bond_2_list = [x - 1 + min(atom_name_list) for x in bond_2_list]
        #print(bond_1_list)
        #print(bond_2_list)
        k_bond_list = df[&#34;k_bond&#34;].values.tolist()
        k_bond_list = [i* 1000.00 for i in k_bond_list]
        k_bond_list = [round(num, 10) for num in k_bond_list]
        #print(k_bond_list)
        bond_length_list = df[&#34;bond_length&#34;].values.tolist()
        bond_length_list = [i/10.00 for i in bond_length_list]
        bond_length_list = [round(num, 6) for num in bond_length_list]
        #print(bond_length_list)
        # Angle Parameters from QM files
        ppdb = PandasPdb()
        ppdb.read_pdb(self.system_qm_pdb)
        atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
        atom_name_list = [i - 1 for i in atom_name_list]
        #print(atom_name_list)
        df = pd.read_csv(self.angle_parameter_file, header = None, delimiter = r&#34;\s+&#34;)
        df.columns = [&#34;angle&#34;, &#34;k_angle&#34;, &#34;angle_degrees&#34;, &#34;angle_1&#34;, &#34;angle_2&#34;, &#34;angle_3&#34;]
        #print(df.head())
        angle_1_list = df[&#34;angle_1&#34;].values.tolist()
        angle_1_list = [x - 1 + min(atom_name_list) for x in angle_1_list]
        #print(angle_1_list)
        angle_2_list = df[&#34;angle_2&#34;].values.tolist()
        angle_2_list = [x - 1 + min(atom_name_list) for x in angle_2_list]
        #print(angle_2_list)
        angle_3_list = df[&#34;angle_3&#34;].values.tolist()
        angle_3_list = [x - 1 + min(atom_name_list) for x in angle_3_list]
        #print(angle_3_list)
        k_angle_list = df[&#34;k_angle&#34;].values.tolist()
        k_angle_list = [round(num, 6) for num in k_angle_list]
        #print(k_angle_list)
        angle_list = df[&#34;angle_degrees&#34;].values.tolist()
        angle_list = [(i * math.pi)/180.00 for i in angle_list]
        angle_list = [round(num, 6) for num in angle_list]
        #print(angle_list)
        xml = open(self.system_qm_params_file, &#34;w&#34;)
        xml.write(&#34;Begin writing the Bond Parameters&#34; + &#34;\n&#34;)
        for i in range(len(k_bond_list)):
            xml.write(&#34;                                &#34; + &#34;&lt;Bond&#34;  + &#34; &#34; 
                               + &#34;d=&#34; + &#39;&#34;&#39; + str(bond_length_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;k=&#34; + &#39;&#34;&#39; + str(k_bond_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;p1=&#34; + &#39;&#34;&#39; + str(bond_1_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;p2=&#34; + &#39;&#34;&#39; + str(bond_2_list[i]) + &#39;&#34;&#39;  
                               + &#34;/&gt;&#34;  + &#34;\n&#34;)  
        xml.write(&#34;Finish writing the Bond Parameters&#34; + &#34;\n&#34;)
        xml.write(&#34;Begin writing the Angle Parameters&#34; + &#34;\n&#34;)
        for i in range(len(k_angle_list)):
            xml.write(&#34;                                &#34; + &#34;&lt;Angle&#34; + &#34; &#34; 
                               + &#34;a=&#34; + &#39;&#34;&#39; + str(angle_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;k=&#34; + &#39;&#34;&#39; + str(k_angle_list[i])  + &#39;&#34;&#39; + &#34; &#34;
                               + &#34;p1=&#34; + &#39;&#34;&#39; + str(angle_1_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;p2=&#34; + &#39;&#34;&#39; + str(angle_2_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;p3=&#34; + &#39;&#34;&#39; + str(angle_3_list[i]) + &#39;&#34;&#39; 
                               + &#34;/&gt;&#34;  + &#34;\n&#34;)
        xml.write(&#34;Finish writing the Angle Parameters&#34; + &#34;\n&#34;)    
        xml.write(&#34;Begin writing the Charge Parameters&#34; + &#34;\n&#34;)
        for i in range(len(qm_charges)):
            xml.write(&#34;&lt;Particle&#34; + &#34; &#34; 
                              + &#34;q=&#34; + &#39;&#34;&#39; + str(qm_charges[i]) + &#39;&#34;&#39; + &#34; &#34; 
                              + &#34;eps=&#34; + &#39;&#34;&#39; + str(0.00) + &#39;&#34;&#39; + &#34; &#34; 
                              + &#34;sig=&#34; + &#39;&#34;&#39; + str(0.00) + &#39;&#34;&#39; + &#34; &#34;   
                              + &#34;atom=&#34; + &#39;&#34;&#39; + str(atom_name_list[i]) + &#39;&#34;&#39; 
                              + &#34;/&gt;&#34;  + &#34;\n&#34;)
        xml.write(&#34;Finish writing the Charge Parameters&#34; + &#34;\n&#34;)    
        xml.close()
    
    def write_reparameterised_system_xml(self):
        # Bond Parameters
        f_params = open(self.system_qm_params_file, &#39;r&#39;)
        lines_params = f_params.readlines()
        # Bond Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Bond Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Bond Parameters&#34; in lines_params[i]:
                to_end = int(i)  
        bond_params = lines_params[to_begin + 1:to_end]
        index_search_replace_bond = []
        for i in bond_params:
            bond_line_to_replace = i
            #print(bond_line_to_replace)
            atom_number_list = [re.findall(&#39;\d*\.?\d+&#39;, i)[3], re.findall(&#39;\d*\.?\d+&#39;, i)[5]]
            #print(atom_number_list)
            comb_1 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_2 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_list_bond = [comb_1, comb_2]
            #print(comb_list_bond)
            list_search_bond = [search_in_file(file = self.system_xml, word = comb_1),search_in_file(file = self.system_xml, word = comb_2)]
            #print(list_search_bond)
            for j in range(len(list_search_bond)):
                if list_search_bond[j] != []:
                    to_add = (list_search_bond[j],i)
                    #print(to_add)
                    index_search_replace_bond.append(to_add)
        # Angle Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Angle Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Angle Parameters&#34; in lines_params[i]:
                to_end = int(i)  
        angle_params = lines_params[to_begin + 1:to_end]
        index_search_replace_angle = []
        for i in angle_params:
            angle_line_to_replace = i
            #print(angle_line_to_replace)
        index_search_replace_angle = []
        for i in angle_params:
            angle_line_to_replace = i
            #print(angle_line_to_replace)
            atom_number_list = [re.findall(&#39;\d*\.?\d+&#39;, i)[3], re.findall(&#39;\d*\.?\d+&#39;, i)[5], re.findall(&#39;\d*\.?\d+&#39;, i)[7]]
            #print(atom_number_list)
            comb_1 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_2 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_3 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_4 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_5 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_6 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_list_angle = [comb_1, comb_2, comb_3, comb_4, comb_5, comb_6]
            #print(comb_list_angle)    
            list_search_angle = [search_in_file(file = self.system_xml, word = comb_1), 
                                 search_in_file(file = self.system_xml, word = comb_2),
                                 search_in_file(file = self.system_xml, word = comb_3),
                                 search_in_file(file = self.system_xml, word = comb_4),
                                 search_in_file(file = self.system_xml, word = comb_5),
                                 search_in_file(file = self.system_xml, word = comb_6)]
            #print(list_search_angle)
            for j in range(len(list_search_angle)):
                if list_search_angle[j] != []:
                    to_add = (list_search_angle[j],i)
                    #print(to_add)
                    index_search_replace_angle.append(to_add)   
        f_org = open(self.system_xml)
        lines = f_org.readlines()
        for i in range(len(index_search_replace_bond)):
            line_number = index_search_replace_bond[i][0][0][0] - 1
            line_to_replace = index_search_replace_bond[i][0][0][1]
            line_to_replace_with = index_search_replace_bond[i][1]
            lines[line_number] = line_to_replace_with 
        for i in range(len(index_search_replace_angle)):
            line_number = index_search_replace_angle[i][0][0][0] - 1
            line_to_replace = index_search_replace_angle[i][0][0][1]
            line_to_replace_with = index_search_replace_angle[i][1]
            lines[line_number] = line_to_replace_with 
        f_cop = open(self.reparameterised_intermediate_system_xml_file, &#34;w&#34;)
        for i in lines:
            f_cop.write(i)
        f_cop.close()

        f_params = open(self.system_qm_params_file)
        lines_params = f_params.readlines()
        # Charge Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Charge Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Charge Parameters&#34; in lines_params[i]:
                to_end = int(i)  
        charge_params = lines_params[to_begin + 1:to_end]
        non_bonded_index = []
        for k in charge_params:
            non_bonded_index.append(int(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,k)[3]))
        charge_for_index = []
        for k in charge_params:
            charge_for_index.append(float(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,k)[0]))

        xml_off = open(self.system_xml) 
        xml_off_lines = xml_off.readlines() 
        for i in range(len(xml_off_lines)):
            if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
                to_begin = int(i)
            if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
                to_end = int(i)  
        nonbond_params = xml_off_lines[to_begin + 4 : to_end - 1]   
        #print(len(nonbond_params))
        f_non_bonded = open(self.system_xml_non_bonded_file, &#34;w&#34;) 
        for x in nonbond_params:
            f_non_bonded.write(x)

        f_non_bonded = open(self.system_xml_non_bonded_file)
        lines_non_bonded = f_non_bonded.readlines()
        #print(len(lines_non_bonded))
        lines_non_bonded_to_write = []
        for i in range(len(non_bonded_index)) :
            line_ = lines_non_bonded[non_bonded_index[i]]
            #print(line_)
            eps = float(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,line_)[0])
            sig = float(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,line_)[2])
            line_to_replace =     &#34;                                &#34; + &#34;&lt;Particle &#34; + &#34;eps=&#34; + &#39;&#34;&#39; + str(eps) + &#39;&#34;&#39; + &#34; &#34; + &#34;q=&#34; + &#39;&#34;&#39; + str(charge_for_index[i]) + &#39;&#34;&#39; + &#34; &#34; + &#34;sig=&#34; + &#39;&#34;&#39; + str(sig) + &#39;&#34;&#39; + &#34;/&gt;&#34; 
            lines_non_bonded_to_write.append(line_to_replace)
        data_ = list(zip(non_bonded_index,lines_non_bonded_to_write))

        df_non_bonded_params = pd.DataFrame(data_, columns=[&#39;line_index&#39;,&#39;line&#39;])
        #print(df_non_bonded_params.head())
        f_non_bonded_ = open(self.system_xml_non_bonded_file)
        lines_non_bonded_ = f_non_bonded_.readlines()
        for i in range(len(lines_non_bonded_)):
            if i in non_bonded_index:
                lines_non_bonded_[i] = (df_non_bonded_params.loc[df_non_bonded_params.line_index == i, &#39;line&#39;].values[0]) + &#34;\n&#34;
        #print(len(lines_non_bonded_))    
        f_write_non_bonded_reparams = open(self.system_xml_non_bonded_reparams_file, &#34;w&#34;) 
        for p in range(len(lines_non_bonded_)):
            f_write_non_bonded_reparams.write(lines_non_bonded_[p]) 
        f_write_non_bonded_reparams.close()
        f_ = open(self.system_xml_non_bonded_reparams_file)
        lines_ = f_.readlines()
        print(len(lines_) == len(lines_non_bonded))

        xml_off = open(self.reparameterised_intermediate_system_xml_file) 
        xml_off_lines = xml_off.readlines() 
        for i in range(len(xml_off_lines)):
            if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
                to_begin = int(i)
            if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
                to_end = int(i)  

        lines_before_params = xml_off_lines[ : to_begin + 4]
        f__ = open(self.system_xml_non_bonded_reparams_file)
        lines_params_non_bonded = f__.readlines()
        lines_after_params = xml_off_lines[to_end -1 : ]
        f_reparams_xml = open(self.reparameterised_system_xml_file, &#34;w&#34;) 
        for x in lines_before_params:
            f_reparams_xml.write(x)
        for x in lines_params_non_bonded:
            f_reparams_xml.write(x)
        for x in lines_after_params:
            f_reparams_xml.write(x)
        f_reparams_xml.close()
        
    def save_amber_params(self):

        if self.load_topology == &#34;parmed&#34;:
            openmm_system = parmed.openmm.load_topology(parmed.load_file(self.system_pdb, structure=True).topology, parmed.load_file(self.non_reparameterised_system_xml_file))
        if self.load_topology == &#34;openmm&#34;:
            openmm_system = parmed.openmm.load_topology(simtk.openmm.app.PDBFile(self.system_pdb).topology, parmed.load_file(self.non_reparameterised_system_xml_file))
        openmm_system.save(self.prmtop_system_non_params, overwrite=True)
        openmm_system.coordinates = parmed.load_file(self.system_pdb, structure=True).coordinates
        openmm_system.save(self.inpcrd_system_non_params, overwrite=True)
        parm = parmed.load_file(self.prmtop_system_non_params, self.inpcrd_system_non_params)

        xml_energy_decomposition = parmed.openmm.energy_decomposition_system(openmm_system, parmed.load_file(self.non_reparameterised_system_xml_file))
        xml_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        xml_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_xml = pd.DataFrame(list(zip(xml_energy_decomposition_list, xml_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_xml_non_params&#39;])
        df_energy_xml = df_energy_xml.set_index(&#39;Energy_term&#39;)

        prmtop_energy_decomposition = parmed.openmm.energy_decomposition_system(parm, parm.createSystem())
        prmtop_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        prmtop_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_prmtop = pd.DataFrame(list(zip(prmtop_energy_decomposition_list, prmtop_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_prmtop_non_params&#39;])
        df_energy_prmtop = df_energy_prmtop.set_index(&#39;Energy_term&#39;)

        df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
        print(df_compare)

        if self.load_topology == &#34;parmed&#34;:
            openmm_system = parmed.openmm.load_topology(parmed.load_file(self.system_pdb, structure=True).topology, parmed.load_file(self.reparameterised_system_xml_file))
        if self.load_topology == &#34;openmm&#34;:
            openmm_system = parmed.openmm.load_topology(simtk.openmm.app.PDBFile(self.system_pdb).topology, parmed.load_file(self.reparameterised_system_xml_file))
        openmm_system.save(self.prmtop_system_params, overwrite=True)
        openmm_system.coordinates = parmed.load_file(self.system_pdb, structure=True).coordinates
        openmm_system.save(self.inpcrd_system_params, overwrite=True)
        parm = parmed.load_file(self.prmtop_system_params, self.inpcrd_system_params)

        xml_energy_decomposition = parmed.openmm.energy_decomposition_system(openmm_system, parmed.load_file(self.reparameterised_system_xml_file))
        xml_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        xml_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_xml = pd.DataFrame(list(zip(xml_energy_decomposition_list, xml_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_xml_params&#39;])
        df_energy_xml = df_energy_xml.set_index(&#39;Energy_term&#39;)

        prmtop_energy_decomposition = parmed.openmm.energy_decomposition_system(parm, parm.createSystem())
        prmtop_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        prmtop_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_prmtop = pd.DataFrame(list(zip(prmtop_energy_decomposition_list, prmtop_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_prmtop_params&#39;])
        df_energy_prmtop = df_energy_prmtop.set_index(&#39;Energy_term&#39;)

        df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
        print(df_compare)
        
    def analyze_diff_energies(self):
        parm_non_params = parmed.load_file(self.prmtop_system_non_params, self.inpcrd_system_non_params)
        prmtop_energy_decomposition_non_params = parmed.openmm.energy_decomposition_system(parm_non_params, parm_non_params.createSystem())
        prmtop_energy_decomposition_non_params_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        prmtop_energy_decomposition_non_params_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_non_params = pd.DataFrame(list(zip(prmtop_energy_decomposition_non_params_list, prmtop_energy_decomposition_non_params_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_parm_non_params&#39;])
        df_energy_non_params = df_energy_non_params.set_index(&#39;Energy_term&#39;)
        #print(df_energy_non_params)
        parm_params = parmed.load_file(self.prmtop_system_params, self.inpcrd_system_params)
        prmtop_energy_decomposition_params = parmed.openmm.energy_decomposition_system(parm_params, parm_params.createSystem())
        prmtop_energy_decomposition_params_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        prmtop_energy_decomposition_params_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_params = pd.DataFrame(list(zip(prmtop_energy_decomposition_params_list, prmtop_energy_decomposition_params_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_parm_params&#39;])
        df_energy_params = df_energy_params.set_index(&#39;Energy_term&#39;)
        #print(df_energy_params)
        df_compare = pd.concat([df_energy_non_params, df_energy_params], axis=1)
        df_compare[&#39;Energy_difference&#39;] = df_compare[&#39;Energy_parm_non_params&#39;].sub(df_compare[&#39;Energy_parm_params&#39;], axis = 0)
        print(df_compare)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.GuestAmberXMLAmber.analyze_diff_energies"><code class="name flex">
<span>def <span class="ident">analyze_diff_energies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analyze_diff_energies(self):
    parm_non_params = parmed.load_file(self.prmtop_system_non_params, self.inpcrd_system_non_params)
    prmtop_energy_decomposition_non_params = parmed.openmm.energy_decomposition_system(parm_non_params, parm_non_params.createSystem())
    prmtop_energy_decomposition_non_params_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                                    list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                                    list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                                    list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;NonbondedForce&#34;)]
    prmtop_energy_decomposition_non_params_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
    df_energy_non_params = pd.DataFrame(list(zip(prmtop_energy_decomposition_non_params_list, prmtop_energy_decomposition_non_params_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_parm_non_params&#39;])
    df_energy_non_params = df_energy_non_params.set_index(&#39;Energy_term&#39;)
    #print(df_energy_non_params)
    parm_params = parmed.load_file(self.prmtop_system_params, self.inpcrd_system_params)
    prmtop_energy_decomposition_params = parmed.openmm.energy_decomposition_system(parm_params, parm_params.createSystem())
    prmtop_energy_decomposition_params_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                                    list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                                    list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                                    list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;NonbondedForce&#34;)]
    prmtop_energy_decomposition_params_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
    df_energy_params = pd.DataFrame(list(zip(prmtop_energy_decomposition_params_list, prmtop_energy_decomposition_params_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_parm_params&#39;])
    df_energy_params = df_energy_params.set_index(&#39;Energy_term&#39;)
    #print(df_energy_params)
    df_compare = pd.concat([df_energy_non_params, df_energy_params], axis=1)
    df_compare[&#39;Energy_difference&#39;] = df_compare[&#39;Energy_parm_non_params&#39;].sub(df_compare[&#39;Energy_parm_params&#39;], axis = 0)
    print(df_compare)</code></pre>
</details>
</dd>
<dt id="parameterize.GuestAmberXMLAmber.generate_xml_antechamber"><code class="name flex">
<span>def <span class="ident">generate_xml_antechamber</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function generates an xml file from the pdb file through antechamber</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_xml_antechamber(self):
    &#34;&#34;&#34;
    This function generates an xml file from the pdb file through antechamber
    &#34;&#34;&#34;
    command = &#34;babel -ipdb &#34; +  self.system_pdb + &#34; -omol2 &#34; +  self.system_mol2
    os.system(command)
    command = &#34;antechamber -i &#34; + self.system_mol2 +  &#34; -fi mol2 -o &#34; + self.system_in + &#34; -fo prepi -c bcc -nc &#34; + str(self.charge)
    os.system(command)
    command = &#34;parmchk2 -i &#34; + self.system_in + &#34; -o &#34; + self.system_frcmod + &#34; -f prepi -a Y&#34;
    os.system(command)
    os.system(&#34;rm -rf ANTECHAMBER* leap.log sqm* ATOMTYPE.INF PREP.INF NEWPDB.PDB&#34;)
    line_1 = &#34;loadamberprep &#34; + self.system_in
    line_2 = &#34;loadamberparams &#34; + self.system_frcmod
    line_3 = &#34;pdb = loadpdb &#34; + self.system_pdb
    line_4 = &#34;saveamberparm pdb &#34; + self.prmtop_system + &#34; &#34; + self.inpcrd_system
    line_5 = &#34;quit&#34;
    with open(self.system_leap, &#39;w&#39;) as f:
        f.write(&#34;    &#34; + &#34;\n&#34;)
        f.write(line_1 + &#34;\n&#34;)
        f.write(line_2 + &#34;\n&#34;)
        f.write(line_3 + &#34;\n&#34;)
        f.write(line_4 + &#34;\n&#34;)
        f.write(line_5 + &#34;\n&#34;)
    command = &#34;tleap -f &#34; + self.system_leap
    os.system(command)
    parm = parmed.load_file(self.prmtop_system, self.inpcrd_system)
    system = parm.createSystem()
    with open(self.system_xml, &#39;w&#39;) as f:
        f.write(simtk.openmm.XmlSerializer.serialize(system)) </code></pre>
</details>
</dd>
<dt id="parameterize.GuestAmberXMLAmber.generate_xml_from_charged_pdb_sdf"><code class="name flex">
<span>def <span class="ident">generate_xml_from_charged_pdb_sdf</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function generates an openforcefield xml file from the pdb file via SDF file and openforcefield.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_xml_from_charged_pdb_sdf(self):
    &#34;&#34;&#34;
    This function generates an openforcefield xml file from the pdb file via SDF file and openforcefield.
    &#34;&#34;&#34;
    command = &#34;babel -ipdb &#34; + self.system_pdb + &#34; -osdf &#34; + self.system_init_sdf
    os.system(command)
    with open(self.system_init_sdf, &#39;r&#39;) as f1 :
        filedata = f1.readlines()
        filedata = filedata[:-2]
    with open(self.system_sdf, &#34;w+&#34;) as out:
        for i in filedata:
            out.write(i)
        line_1 = &#34;M  CHG  &#34; + str(self.num_charge_atoms) + &#34;   &#34; + str(self.index_charge_atom_1)   + &#34;   &#34; + str(self.charge_atom_1) + &#34;\n&#34; 
        line_2 = &#34;M  END&#34; + &#34;\n&#34;
        line_3 = &#34;$$$$&#34;
        out.write(line_1)
        out.write(line_2)
        out.write(line_3)
    off_molecule = openforcefield.topology.Molecule(self.system_sdf)
    force_field = openforcefield.typing.engines.smirnoff.ForceField(&#39;openff_unconstrained-1.0.0.offxml&#39;)
    system = force_field.create_openmm_system(off_molecule.to_topology())
    pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
    structure = parmed.openmm.load_topology(pdbfile.topology, system, xyz = pdbfile.positions)
    with open(self.system_xml, &#39;w&#39;) as f:
        f.write(simtk.openmm.XmlSerializer.serialize(system))  </code></pre>
</details>
</dd>
<dt id="parameterize.GuestAmberXMLAmber.generate_xml_from_doubly_charged_pdb_sdf"><code class="name flex">
<span>def <span class="ident">generate_xml_from_doubly_charged_pdb_sdf</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function generates an openforcefield xml file from the pdb file via SDF file and openforcefield.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_xml_from_doubly_charged_pdb_sdf(self):
    &#34;&#34;&#34;
    This function generates an openforcefield xml file from the pdb file via SDF file and openforcefield.
    &#34;&#34;&#34;
    command = &#34;babel -ipdb &#34; + self.system_pdb + &#34; -osdf &#34; + self.system_init_sdf
    os.system(command)
    with open(self.system_init_sdf, &#39;r&#39;) as f1 :
        filedata = f1.readlines()
        filedata = filedata[:-2]
    with open(self.system_sdf, &#34;w+&#34;) as out:
        for i in filedata:
            out.write(i)
        line_1 = &#34;M  CHG  &#34; + str(self.num_charge_atoms) + &#34;   &#34; + str(self.index_charge_atom_1)   + &#34;   &#34; + str(self.charge_atom_1) + &#34;   &#34; + str(self.index_charge_atom_2)   + &#34;   &#34; + str(self.charge_atom_2) + &#34;\n&#34; 
        line_2 = &#34;M  END&#34; + &#34;\n&#34;
        line_3 = &#34;$$$$&#34;
        out.write(line_1)
        out.write(line_2)
        out.write(line_3)
    off_molecule = openforcefield.topology.Molecule(self.system_sdf)
    force_field = openforcefield.typing.engines.smirnoff.ForceField(&#39;openff_unconstrained-1.0.0.offxml&#39;)
    system = force_field.create_openmm_system(off_molecule.to_topology())
    pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
    structure = parmed.openmm.load_topology(pdbfile.topology, system, xyz = pdbfile.positions)
    with open(self.system_xml, &#39;w&#39;) as f:
        f.write(simtk.openmm.XmlSerializer.serialize(system))      </code></pre>
</details>
</dd>
<dt id="parameterize.GuestAmberXMLAmber.generate_xml_from_pdb_sdf"><code class="name flex">
<span>def <span class="ident">generate_xml_from_pdb_sdf</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function generates an openforcefield xml file from the pdb file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_xml_from_pdb_sdf(self):
    &#34;&#34;&#34;
    This function generates an openforcefield xml file from the pdb file
    &#34;&#34;&#34;
    command = &#34;babel -ipdb &#34; + self.system_pdb + &#34; -osdf &#34; + self.system_sdf
    os.system(command)
    off_molecule = openforcefield.topology.Molecule(self.system_sdf)
    force_field = openforcefield.typing.engines.smirnoff.ForceField(&#39;openff_unconstrained-1.0.0.offxml&#39;)
    system = force_field.create_openmm_system(off_molecule.to_topology())
    pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
    structure = parmed.openmm.load_topology(pdbfile.topology, system, xyz = pdbfile.positions)
    with open(self.system_xml, &#39;w&#39;) as f:
        f.write(simtk.openmm.XmlSerializer.serialize(system))    </code></pre>
</details>
</dd>
<dt id="parameterize.GuestAmberXMLAmber.generate_xml_from_pdb_smi"><code class="name flex">
<span>def <span class="ident">generate_xml_from_pdb_smi</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function generates an openforcefield xml file from the pdb file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_xml_from_pdb_smi(self):
    &#34;&#34;&#34;
    This function generates an openforcefield xml file from the pdb file
    &#34;&#34;&#34;
    off_molecule = openforcefield.topology.Molecule(self.system_smi)
    force_field = openforcefield.typing.engines.smirnoff.ForceField(&#39;openff_unconstrained-1.0.0.offxml&#39;)
    system = force_field.create_openmm_system(off_molecule.to_topology())
    pdbfile = simtk.openmm.app.PDBFile(self.system_pdb)
    structure = parmed.openmm.load_topology(pdbfile.topology, system, xyz = pdbfile.positions)
    with open(self.system_xml, &#39;w&#39;) as f:
        f.write(simtk.openmm.XmlSerializer.serialize(system))   </code></pre>
</details>
</dd>
<dt id="parameterize.GuestAmberXMLAmber.save_amber_params"><code class="name flex">
<span>def <span class="ident">save_amber_params</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_amber_params(self):

    if self.load_topology == &#34;parmed&#34;:
        openmm_system = parmed.openmm.load_topology(parmed.load_file(self.system_pdb, structure=True).topology, parmed.load_file(self.non_reparameterised_system_xml_file))
    if self.load_topology == &#34;openmm&#34;:
        openmm_system = parmed.openmm.load_topology(simtk.openmm.app.PDBFile(self.system_pdb).topology, parmed.load_file(self.non_reparameterised_system_xml_file))
    openmm_system.save(self.prmtop_system_non_params, overwrite=True)
    openmm_system.coordinates = parmed.load_file(self.system_pdb, structure=True).coordinates
    openmm_system.save(self.inpcrd_system_non_params, overwrite=True)
    parm = parmed.load_file(self.prmtop_system_non_params, self.inpcrd_system_non_params)

    xml_energy_decomposition = parmed.openmm.energy_decomposition_system(openmm_system, parmed.load_file(self.non_reparameterised_system_xml_file))
    xml_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                       list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                       list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                       list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
    xml_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
    df_energy_xml = pd.DataFrame(list(zip(xml_energy_decomposition_list, xml_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_xml_non_params&#39;])
    df_energy_xml = df_energy_xml.set_index(&#39;Energy_term&#39;)

    prmtop_energy_decomposition = parmed.openmm.energy_decomposition_system(parm, parm.createSystem())
    prmtop_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                          list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                          list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                          list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
    prmtop_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
    df_energy_prmtop = pd.DataFrame(list(zip(prmtop_energy_decomposition_list, prmtop_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_prmtop_non_params&#39;])
    df_energy_prmtop = df_energy_prmtop.set_index(&#39;Energy_term&#39;)

    df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
    print(df_compare)

    if self.load_topology == &#34;parmed&#34;:
        openmm_system = parmed.openmm.load_topology(parmed.load_file(self.system_pdb, structure=True).topology, parmed.load_file(self.reparameterised_system_xml_file))
    if self.load_topology == &#34;openmm&#34;:
        openmm_system = parmed.openmm.load_topology(simtk.openmm.app.PDBFile(self.system_pdb).topology, parmed.load_file(self.reparameterised_system_xml_file))
    openmm_system.save(self.prmtop_system_params, overwrite=True)
    openmm_system.coordinates = parmed.load_file(self.system_pdb, structure=True).coordinates
    openmm_system.save(self.inpcrd_system_params, overwrite=True)
    parm = parmed.load_file(self.prmtop_system_params, self.inpcrd_system_params)

    xml_energy_decomposition = parmed.openmm.energy_decomposition_system(openmm_system, parmed.load_file(self.reparameterised_system_xml_file))
    xml_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                       list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                       list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                       list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
    xml_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
    df_energy_xml = pd.DataFrame(list(zip(xml_energy_decomposition_list, xml_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_xml_params&#39;])
    df_energy_xml = df_energy_xml.set_index(&#39;Energy_term&#39;)

    prmtop_energy_decomposition = parmed.openmm.energy_decomposition_system(parm, parm.createSystem())
    prmtop_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                          list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                          list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                          list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
    prmtop_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
    df_energy_prmtop = pd.DataFrame(list(zip(prmtop_energy_decomposition_list, prmtop_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_prmtop_params&#39;])
    df_energy_prmtop = df_energy_prmtop.set_index(&#39;Energy_term&#39;)

    df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
    print(df_compare)</code></pre>
</details>
</dd>
<dt id="parameterize.GuestAmberXMLAmber.write_reparameterised_system_xml"><code class="name flex">
<span>def <span class="ident">write_reparameterised_system_xml</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_reparameterised_system_xml(self):
    # Bond Parameters
    f_params = open(self.system_qm_params_file, &#39;r&#39;)
    lines_params = f_params.readlines()
    # Bond Parameters
    for i in range(len(lines_params)):
        if &#34;Begin writing the Bond Parameters&#34; in lines_params[i]:
            to_begin = int(i)
        if &#34;Finish writing the Bond Parameters&#34; in lines_params[i]:
            to_end = int(i)  
    bond_params = lines_params[to_begin + 1:to_end]
    index_search_replace_bond = []
    for i in bond_params:
        bond_line_to_replace = i
        #print(bond_line_to_replace)
        atom_number_list = [re.findall(&#39;\d*\.?\d+&#39;, i)[3], re.findall(&#39;\d*\.?\d+&#39;, i)[5]]
        #print(atom_number_list)
        comb_1 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34;/&gt;&#34;
        comb_2 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34;/&gt;&#34;
        comb_list_bond = [comb_1, comb_2]
        #print(comb_list_bond)
        list_search_bond = [search_in_file(file = self.system_xml, word = comb_1),search_in_file(file = self.system_xml, word = comb_2)]
        #print(list_search_bond)
        for j in range(len(list_search_bond)):
            if list_search_bond[j] != []:
                to_add = (list_search_bond[j],i)
                #print(to_add)
                index_search_replace_bond.append(to_add)
    # Angle Parameters
    for i in range(len(lines_params)):
        if &#34;Begin writing the Angle Parameters&#34; in lines_params[i]:
            to_begin = int(i)
        if &#34;Finish writing the Angle Parameters&#34; in lines_params[i]:
            to_end = int(i)  
    angle_params = lines_params[to_begin + 1:to_end]
    index_search_replace_angle = []
    for i in angle_params:
        angle_line_to_replace = i
        #print(angle_line_to_replace)
    index_search_replace_angle = []
    for i in angle_params:
        angle_line_to_replace = i
        #print(angle_line_to_replace)
        atom_number_list = [re.findall(&#39;\d*\.?\d+&#39;, i)[3], re.findall(&#39;\d*\.?\d+&#39;, i)[5], re.findall(&#39;\d*\.?\d+&#39;, i)[7]]
        #print(atom_number_list)
        comb_1 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34;/&gt;&#34;
        comb_2 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34;/&gt;&#34;
        comb_3 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34;/&gt;&#34;
        comb_4 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34;/&gt;&#34;
        comb_5 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34;/&gt;&#34;
        comb_6 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34;/&gt;&#34;
        comb_list_angle = [comb_1, comb_2, comb_3, comb_4, comb_5, comb_6]
        #print(comb_list_angle)    
        list_search_angle = [search_in_file(file = self.system_xml, word = comb_1), 
                             search_in_file(file = self.system_xml, word = comb_2),
                             search_in_file(file = self.system_xml, word = comb_3),
                             search_in_file(file = self.system_xml, word = comb_4),
                             search_in_file(file = self.system_xml, word = comb_5),
                             search_in_file(file = self.system_xml, word = comb_6)]
        #print(list_search_angle)
        for j in range(len(list_search_angle)):
            if list_search_angle[j] != []:
                to_add = (list_search_angle[j],i)
                #print(to_add)
                index_search_replace_angle.append(to_add)   
    f_org = open(self.system_xml)
    lines = f_org.readlines()
    for i in range(len(index_search_replace_bond)):
        line_number = index_search_replace_bond[i][0][0][0] - 1
        line_to_replace = index_search_replace_bond[i][0][0][1]
        line_to_replace_with = index_search_replace_bond[i][1]
        lines[line_number] = line_to_replace_with 
    for i in range(len(index_search_replace_angle)):
        line_number = index_search_replace_angle[i][0][0][0] - 1
        line_to_replace = index_search_replace_angle[i][0][0][1]
        line_to_replace_with = index_search_replace_angle[i][1]
        lines[line_number] = line_to_replace_with 
    f_cop = open(self.reparameterised_intermediate_system_xml_file, &#34;w&#34;)
    for i in lines:
        f_cop.write(i)
    f_cop.close()

    f_params = open(self.system_qm_params_file)
    lines_params = f_params.readlines()
    # Charge Parameters
    for i in range(len(lines_params)):
        if &#34;Begin writing the Charge Parameters&#34; in lines_params[i]:
            to_begin = int(i)
        if &#34;Finish writing the Charge Parameters&#34; in lines_params[i]:
            to_end = int(i)  
    charge_params = lines_params[to_begin + 1:to_end]
    non_bonded_index = []
    for k in charge_params:
        non_bonded_index.append(int(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,k)[3]))
    charge_for_index = []
    for k in charge_params:
        charge_for_index.append(float(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,k)[0]))

    xml_off = open(self.system_xml) 
    xml_off_lines = xml_off.readlines() 
    for i in range(len(xml_off_lines)):
        if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
            to_begin = int(i)
        if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
            to_end = int(i)  
    nonbond_params = xml_off_lines[to_begin + 4 : to_end - 1]   
    #print(len(nonbond_params))
    f_non_bonded = open(self.system_xml_non_bonded_file, &#34;w&#34;) 
    for x in nonbond_params:
        f_non_bonded.write(x)

    f_non_bonded = open(self.system_xml_non_bonded_file)
    lines_non_bonded = f_non_bonded.readlines()
    #print(len(lines_non_bonded))
    lines_non_bonded_to_write = []
    for i in range(len(non_bonded_index)) :
        line_ = lines_non_bonded[non_bonded_index[i]]
        #print(line_)
        eps = float(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,line_)[0])
        sig = float(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,line_)[2])
        line_to_replace =     &#34;                                &#34; + &#34;&lt;Particle &#34; + &#34;eps=&#34; + &#39;&#34;&#39; + str(eps) + &#39;&#34;&#39; + &#34; &#34; + &#34;q=&#34; + &#39;&#34;&#39; + str(charge_for_index[i]) + &#39;&#34;&#39; + &#34; &#34; + &#34;sig=&#34; + &#39;&#34;&#39; + str(sig) + &#39;&#34;&#39; + &#34;/&gt;&#34; 
        lines_non_bonded_to_write.append(line_to_replace)
    data_ = list(zip(non_bonded_index,lines_non_bonded_to_write))

    df_non_bonded_params = pd.DataFrame(data_, columns=[&#39;line_index&#39;,&#39;line&#39;])
    #print(df_non_bonded_params.head())
    f_non_bonded_ = open(self.system_xml_non_bonded_file)
    lines_non_bonded_ = f_non_bonded_.readlines()
    for i in range(len(lines_non_bonded_)):
        if i in non_bonded_index:
            lines_non_bonded_[i] = (df_non_bonded_params.loc[df_non_bonded_params.line_index == i, &#39;line&#39;].values[0]) + &#34;\n&#34;
    #print(len(lines_non_bonded_))    
    f_write_non_bonded_reparams = open(self.system_xml_non_bonded_reparams_file, &#34;w&#34;) 
    for p in range(len(lines_non_bonded_)):
        f_write_non_bonded_reparams.write(lines_non_bonded_[p]) 
    f_write_non_bonded_reparams.close()
    f_ = open(self.system_xml_non_bonded_reparams_file)
    lines_ = f_.readlines()
    print(len(lines_) == len(lines_non_bonded))

    xml_off = open(self.reparameterised_intermediate_system_xml_file) 
    xml_off_lines = xml_off.readlines() 
    for i in range(len(xml_off_lines)):
        if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
            to_begin = int(i)
        if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
            to_end = int(i)  

    lines_before_params = xml_off_lines[ : to_begin + 4]
    f__ = open(self.system_xml_non_bonded_reparams_file)
    lines_params_non_bonded = f__.readlines()
    lines_after_params = xml_off_lines[to_end -1 : ]
    f_reparams_xml = open(self.reparameterised_system_xml_file, &#34;w&#34;) 
    for x in lines_before_params:
        f_reparams_xml.write(x)
    for x in lines_params_non_bonded:
        f_reparams_xml.write(x)
    for x in lines_after_params:
        f_reparams_xml.write(x)
    f_reparams_xml.close()</code></pre>
</details>
</dd>
<dt id="parameterize.GuestAmberXMLAmber.write_system_params"><code class="name flex">
<span>def <span class="ident">write_system_params</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves the parameters obtained from the QM log files in a text file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_system_params(self):
    &#34;&#34;&#34;
    This function saves the parameters obtained from the QM log files in a text file. 
    &#34;&#34;&#34;
    # Charges from QM files
    df_charges = pd.read_csv(self.charge_parameter_file, header = None, delimiter = r&#34;\s+&#34;)
    df_charges.columns = [&#34;atom&#34;, &#34;charges&#34;]
    qm_charges = df_charges[&#34;charges&#34;].values.tolist()
    qm_charges = [round(num, 6) for num in qm_charges]
    #print(qm_charges)
    # Bond Parameters from QM files
    ppdb = PandasPdb()
    ppdb.read_pdb(self.system_qm_pdb)
    atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
    atom_name_list = [i - 1 for i in atom_name_list]
    #print(atom_name_list)
    df = pd.read_csv(self.bond_parameter_file, header = None, delimiter = r&#34;\s+&#34;)
    df.columns = [&#34;bond&#34;, &#34;k_bond&#34;, &#34;bond_length&#34;, &#34;bond_1&#34;, &#34;bond_2&#34;]
    #print(df.head())
    bond_1_list = df[&#34;bond_1&#34;].values.tolist()
    bond_1_list = [x - 1 + min(atom_name_list) for x in bond_1_list]
    bond_2_list = df[&#34;bond_2&#34;].values.tolist()
    bond_2_list = [x - 1 + min(atom_name_list) for x in bond_2_list]
    #print(bond_1_list)
    #print(bond_2_list)
    k_bond_list = df[&#34;k_bond&#34;].values.tolist()
    k_bond_list = [i* 1000.00 for i in k_bond_list]
    k_bond_list = [round(num, 10) for num in k_bond_list]
    #print(k_bond_list)
    bond_length_list = df[&#34;bond_length&#34;].values.tolist()
    bond_length_list = [i/10.00 for i in bond_length_list]
    bond_length_list = [round(num, 6) for num in bond_length_list]
    #print(bond_length_list)
    # Angle Parameters from QM files
    ppdb = PandasPdb()
    ppdb.read_pdb(self.system_qm_pdb)
    atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
    atom_name_list = [i - 1 for i in atom_name_list]
    #print(atom_name_list)
    df = pd.read_csv(self.angle_parameter_file, header = None, delimiter = r&#34;\s+&#34;)
    df.columns = [&#34;angle&#34;, &#34;k_angle&#34;, &#34;angle_degrees&#34;, &#34;angle_1&#34;, &#34;angle_2&#34;, &#34;angle_3&#34;]
    #print(df.head())
    angle_1_list = df[&#34;angle_1&#34;].values.tolist()
    angle_1_list = [x - 1 + min(atom_name_list) for x in angle_1_list]
    #print(angle_1_list)
    angle_2_list = df[&#34;angle_2&#34;].values.tolist()
    angle_2_list = [x - 1 + min(atom_name_list) for x in angle_2_list]
    #print(angle_2_list)
    angle_3_list = df[&#34;angle_3&#34;].values.tolist()
    angle_3_list = [x - 1 + min(atom_name_list) for x in angle_3_list]
    #print(angle_3_list)
    k_angle_list = df[&#34;k_angle&#34;].values.tolist()
    k_angle_list = [round(num, 6) for num in k_angle_list]
    #print(k_angle_list)
    angle_list = df[&#34;angle_degrees&#34;].values.tolist()
    angle_list = [(i * math.pi)/180.00 for i in angle_list]
    angle_list = [round(num, 6) for num in angle_list]
    #print(angle_list)
    xml = open(self.system_qm_params_file, &#34;w&#34;)
    xml.write(&#34;Begin writing the Bond Parameters&#34; + &#34;\n&#34;)
    for i in range(len(k_bond_list)):
        xml.write(&#34;                                &#34; + &#34;&lt;Bond&#34;  + &#34; &#34; 
                           + &#34;d=&#34; + &#39;&#34;&#39; + str(bond_length_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                           + &#34;k=&#34; + &#39;&#34;&#39; + str(k_bond_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                           + &#34;p1=&#34; + &#39;&#34;&#39; + str(bond_1_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                           + &#34;p2=&#34; + &#39;&#34;&#39; + str(bond_2_list[i]) + &#39;&#34;&#39;  
                           + &#34;/&gt;&#34;  + &#34;\n&#34;)  
    xml.write(&#34;Finish writing the Bond Parameters&#34; + &#34;\n&#34;)
    xml.write(&#34;Begin writing the Angle Parameters&#34; + &#34;\n&#34;)
    for i in range(len(k_angle_list)):
        xml.write(&#34;                                &#34; + &#34;&lt;Angle&#34; + &#34; &#34; 
                           + &#34;a=&#34; + &#39;&#34;&#39; + str(angle_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                           + &#34;k=&#34; + &#39;&#34;&#39; + str(k_angle_list[i])  + &#39;&#34;&#39; + &#34; &#34;
                           + &#34;p1=&#34; + &#39;&#34;&#39; + str(angle_1_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                           + &#34;p2=&#34; + &#39;&#34;&#39; + str(angle_2_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                           + &#34;p3=&#34; + &#39;&#34;&#39; + str(angle_3_list[i]) + &#39;&#34;&#39; 
                           + &#34;/&gt;&#34;  + &#34;\n&#34;)
    xml.write(&#34;Finish writing the Angle Parameters&#34; + &#34;\n&#34;)    
    xml.write(&#34;Begin writing the Charge Parameters&#34; + &#34;\n&#34;)
    for i in range(len(qm_charges)):
        xml.write(&#34;&lt;Particle&#34; + &#34; &#34; 
                          + &#34;q=&#34; + &#39;&#34;&#39; + str(qm_charges[i]) + &#39;&#34;&#39; + &#34; &#34; 
                          + &#34;eps=&#34; + &#39;&#34;&#39; + str(0.00) + &#39;&#34;&#39; + &#34; &#34; 
                          + &#34;sig=&#34; + &#39;&#34;&#39; + str(0.00) + &#39;&#34;&#39; + &#34; &#34;   
                          + &#34;atom=&#34; + &#39;&#34;&#39; + str(atom_name_list[i]) + &#39;&#34;&#39; 
                          + &#34;/&gt;&#34;  + &#34;\n&#34;)
    xml.write(&#34;Finish writing the Charge Parameters&#34; + &#34;\n&#34;)    
    xml.close()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.HostAmberXMLAmber"><code class="flex name class">
<span>class <span class="ident">HostAmberXMLAmber</span></span>
<span>(</span><span>system_pdb='host.pdb', system_xml='host.xml', sim_output='sim_output.pdb', sim_steps=1000, charge_parameter_file='host_qm_surround_charges.txt', system_qm_pdb='host_qm.pdb', bond_parameter_file='host_qm_bonds.txt', angle_parameter_file='host_qm_angles.txt', system_qm_params_file='host_qm_params.txt', reparameterised_intermediate_system_xml_file='host_intermediate_reparameterised.xml', system_xml_non_bonded_file='host_xml_non_bonded.txt', system_xml_non_bonded_reparams_file='host_xml_non_bonded_reparams.txt', reparameterised_system_xml_file='host_reparameterised.xml', non_reparameterised_system_xml_file='host.xml', prmtop_system_non_params='host_non_params.prmtop', inpcrd_system_non_params='host_non_params.inpcrd', prmtop_system_params='host_params.prmtop', inpcrd_system_params='host_params.inpcrd', load_topology='openmm')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HostAmberXMLAmber:

    def __init__(self, system_pdb = &#34;host.pdb&#34;, system_xml = &#34;host.xml&#34;, sim_output = &#34;sim_output.pdb&#34;, sim_steps = 1000, charge_parameter_file = &#34;host_qm_surround_charges.txt&#34;, system_qm_pdb = &#34;host_qm.pdb&#34;, bond_parameter_file = &#34;host_qm_bonds.txt&#34;, angle_parameter_file = &#34;host_qm_angles.txt&#34;, system_qm_params_file = &#34;host_qm_params.txt&#34;, reparameterised_intermediate_system_xml_file = &#34;host_intermediate_reparameterised.xml&#34;, system_xml_non_bonded_file = &#34;host_xml_non_bonded.txt&#34;, system_xml_non_bonded_reparams_file = &#34;host_xml_non_bonded_reparams.txt&#34;, reparameterised_system_xml_file = &#34;host_reparameterised.xml&#34;, non_reparameterised_system_xml_file = &#34;host.xml&#34;, prmtop_system_non_params = &#34;host_non_params.prmtop&#34;, inpcrd_system_non_params = &#34;host_non_params.inpcrd&#34;, prmtop_system_params = &#34;host_params.prmtop&#34;, inpcrd_system_params = &#34;host_params.inpcrd&#34;, load_topology = &#34;openmm&#34;):   
        self.system_pdb = system_pdb
        self.system_xml = system_xml
        self.sim_output = sim_output
        self.sim_steps = sim_steps
        self.charge_parameter_file = charge_parameter_file
        self.system_qm_pdb = system_qm_pdb
        self.bond_parameter_file = bond_parameter_file
        self.angle_parameter_file = angle_parameter_file
        self.system_qm_params_file = system_qm_params_file
        self.reparameterised_intermediate_system_xml_file  = reparameterised_intermediate_system_xml_file
        self.system_xml_non_bonded_file = system_xml_non_bonded_file
        self.system_xml_non_bonded_reparams_file = system_xml_non_bonded_reparams_file
        self.reparameterised_system_xml_file = reparameterised_system_xml_file
        self.non_reparameterised_system_xml_file = non_reparameterised_system_xml_file
        self.prmtop_system_non_params = prmtop_system_non_params
        self.inpcrd_system_non_params = inpcrd_system_non_params
        self.prmtop_system_params = prmtop_system_params
        self.inpcrd_system_params = inpcrd_system_params
        self.load_topology = load_topology
        
    def serialize_system(self):        
        pdb = simtk.openmm.app.PDBFile(self.system_pdb)
        forcefield = simtk.openmm.app.ForceField(&#39;amber14-all.xml&#39;)
        system = forcefield.createSystem(pdb.topology)
        integrator = simtk.openmm.LangevinIntegrator(300 * simtk.unit.kelvin, 1 / simtk.unit.picosecond, 0.002 * simtk.unit.picoseconds)
        simulation = simtk.openmm.app.Simulation(pdb.topology, system, integrator)
        simulation.context.setPositions(pdb.positions)
        simulation.minimizeEnergy()
        state = simulation.context.getState(getEnergy=True)
        energy = state.getPotentialEnergy()
        print(energy)
        simulation.reporters.append(simtk.openmm.app.PDBReporter(self.sim_output, self.sim_steps/10))
        simulation.reporters.append(simtk.openmm.app.StateDataReporter(stdout, reportInterval = int(self.sim_steps/10), step = True, potentialEnergy = True, temperature = True))
        simulation.step(self.sim_steps)
        command = &#34;rm -rf &#34; + self.sim_output
        os.system(command)
        with open(self.system_xml, &#39;w&#39;) as f:
            f.write(simtk.openmm.XmlSerializer.serialize(system))
    
    def write_system_params(self):
        &#34;&#34;&#34;
        This function saves the parameters obtained from the QM log files in a text file. 
        &#34;&#34;&#34;
        # Charges from QM files
        df_charges = pd.read_csv(self.charge_parameter_file, header = None, delimiter = r&#34;\s+&#34;)
        df_charges.columns = [&#34;atom&#34;, &#34;charges&#34;]
        qm_charges = df_charges[&#34;charges&#34;].values.tolist()
        qm_charges = [round(num, 6) for num in qm_charges]
        #print(qm_charges)
        # Bond Parameters from QM files
        ppdb = PandasPdb()
        ppdb.read_pdb(self.system_qm_pdb)
        atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
        atom_name_list = [i - 1 for i in atom_name_list]
        #print(atom_name_list)
        df = pd.read_csv(self.bond_parameter_file, header = None, delimiter = r&#34;\s+&#34;)
        df.columns = [&#34;bond&#34;, &#34;k_bond&#34;, &#34;bond_length&#34;, &#34;bond_1&#34;, &#34;bond_2&#34;]
        #print(df.head())
        bond_1_list = df[&#34;bond_1&#34;].values.tolist()
        bond_1_list = [x - 1 + min(atom_name_list) for x in bond_1_list]
        bond_2_list = df[&#34;bond_2&#34;].values.tolist()
        bond_2_list = [x - 1 + min(atom_name_list) for x in bond_2_list]
        #print(bond_1_list)
        #print(bond_2_list)
        k_bond_list = df[&#34;k_bond&#34;].values.tolist()
        k_bond_list = [i* 1000.00 for i in k_bond_list]
        k_bond_list = [round(num, 10) for num in k_bond_list]
        #print(k_bond_list)
        bond_length_list = df[&#34;bond_length&#34;].values.tolist()
        bond_length_list = [i/10.00 for i in bond_length_list]
        bond_length_list = [round(num, 6) for num in bond_length_list]
        #print(bond_length_list)
        # Angle Parameters from QM files
        ppdb = PandasPdb()
        ppdb.read_pdb(self.system_qm_pdb)
        atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
        atom_name_list = [i - 1 for i in atom_name_list]
        #print(atom_name_list)
        df = pd.read_csv(self.angle_parameter_file, header = None, delimiter = r&#34;\s+&#34;)
        df.columns = [&#34;angle&#34;, &#34;k_angle&#34;, &#34;angle_degrees&#34;, &#34;angle_1&#34;, &#34;angle_2&#34;, &#34;angle_3&#34;]
        #print(df.head())
        angle_1_list = df[&#34;angle_1&#34;].values.tolist()
        angle_1_list = [x - 1 + min(atom_name_list) for x in angle_1_list]
        #print(angle_1_list)
        angle_2_list = df[&#34;angle_2&#34;].values.tolist()
        angle_2_list = [x - 1 + min(atom_name_list) for x in angle_2_list]
        #print(angle_2_list)
        angle_3_list = df[&#34;angle_3&#34;].values.tolist()
        angle_3_list = [x - 1 + min(atom_name_list) for x in angle_3_list]
        #print(angle_3_list)
        k_angle_list = df[&#34;k_angle&#34;].values.tolist()
        k_angle_list = [round(num, 6) for num in k_angle_list]
        #print(k_angle_list)
        angle_list = df[&#34;angle_degrees&#34;].values.tolist()
        angle_list = [(i * math.pi)/180.00 for i in angle_list]
        angle_list = [round(num, 6) for num in angle_list]
        #print(angle_list)
        xml = open(self.system_qm_params_file, &#34;w&#34;)
        xml.write(&#34;Begin writing the Bond Parameters&#34; + &#34;\n&#34;)
        for i in range(len(k_bond_list)):
            xml.write(&#34;                                &#34; + &#34;&lt;Bond&#34;  + &#34; &#34; 
                               + &#34;d=&#34; + &#39;&#34;&#39; + str(bond_length_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;k=&#34; + &#39;&#34;&#39; + str(k_bond_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;p1=&#34; + &#39;&#34;&#39; + str(bond_1_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;p2=&#34; + &#39;&#34;&#39; + str(bond_2_list[i]) + &#39;&#34;&#39;  
                               + &#34;/&gt;&#34;  + &#34;\n&#34;)  
        xml.write(&#34;Finish writing the Bond Parameters&#34; + &#34;\n&#34;)
        xml.write(&#34;Begin writing the Angle Parameters&#34; + &#34;\n&#34;)
        for i in range(len(k_angle_list)):
            xml.write(&#34;                                &#34; + &#34;&lt;Angle&#34; + &#34; &#34; 
                               + &#34;a=&#34; + &#39;&#34;&#39; + str(angle_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;k=&#34; + &#39;&#34;&#39; + str(k_angle_list[i])  + &#39;&#34;&#39; + &#34; &#34;
                               + &#34;p1=&#34; + &#39;&#34;&#39; + str(angle_1_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;p2=&#34; + &#39;&#34;&#39; + str(angle_2_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                               + &#34;p3=&#34; + &#39;&#34;&#39; + str(angle_3_list[i]) + &#39;&#34;&#39; 
                               + &#34;/&gt;&#34;  + &#34;\n&#34;)
        xml.write(&#34;Finish writing the Angle Parameters&#34; + &#34;\n&#34;)    
        xml.write(&#34;Begin writing the Charge Parameters&#34; + &#34;\n&#34;)
        for i in range(len(qm_charges)):
            xml.write(&#34;&lt;Particle&#34; + &#34; &#34; 
                              + &#34;q=&#34; + &#39;&#34;&#39; + str(qm_charges[i]) + &#39;&#34;&#39; + &#34; &#34; 
                              + &#34;eps=&#34; + &#39;&#34;&#39; + str(0.00) + &#39;&#34;&#39; + &#34; &#34; 
                              + &#34;sig=&#34; + &#39;&#34;&#39; + str(0.00) + &#39;&#34;&#39; + &#34; &#34;   
                              + &#34;atom=&#34; + &#39;&#34;&#39; + str(atom_name_list[i]) + &#39;&#34;&#39; 
                              + &#34;/&gt;&#34;  + &#34;\n&#34;)
        xml.write(&#34;Finish writing the Charge Parameters&#34; + &#34;\n&#34;)    
        xml.close()
    
    def write_reparameterised_system_xml(self):
        # Bond Parameters
        f_params = open(self.system_qm_params_file, &#39;r&#39;)
        lines_params = f_params.readlines()
        # Bond Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Bond Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Bond Parameters&#34; in lines_params[i]:
                to_end = int(i)  
        bond_params = lines_params[to_begin + 1:to_end]
        index_search_replace_bond = []
        for i in bond_params:
            bond_line_to_replace = i
            #print(bond_line_to_replace)
            atom_number_list = [re.findall(&#39;\d*\.?\d+&#39;, i)[3], re.findall(&#39;\d*\.?\d+&#39;, i)[5]]
            #print(atom_number_list)
            comb_1 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_2 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_list_bond = [comb_1, comb_2]
            #print(comb_list_bond)
            list_search_bond = [search_in_file(file = self.system_xml, word = comb_1),search_in_file(file = self.system_xml, word = comb_2)]
            #print(list_search_bond)
            for j in range(len(list_search_bond)):
                if list_search_bond[j] != []:
                    to_add = (list_search_bond[j],i)
                    #print(to_add)
                    index_search_replace_bond.append(to_add)
        # Angle Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Angle Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Angle Parameters&#34; in lines_params[i]:
                to_end = int(i)  
        angle_params = lines_params[to_begin + 1:to_end]
        index_search_replace_angle = []
        for i in angle_params:
            angle_line_to_replace = i
            #print(angle_line_to_replace)
        index_search_replace_angle = []
        for i in angle_params:
            angle_line_to_replace = i
            #print(angle_line_to_replace)
            atom_number_list = [re.findall(&#39;\d*\.?\d+&#39;, i)[3], re.findall(&#39;\d*\.?\d+&#39;, i)[5], re.findall(&#39;\d*\.?\d+&#39;, i)[7]]
            #print(atom_number_list)
            comb_1 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_2 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_3 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_4 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_5 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_6 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34;/&gt;&#34;
            comb_list_angle = [comb_1, comb_2, comb_3, comb_4, comb_5, comb_6]
            #print(comb_list_angle)    
            list_search_angle = [search_in_file(file = self.system_xml, word = comb_1), 
                                 search_in_file(file = self.system_xml, word = comb_2),
                                 search_in_file(file = self.system_xml, word = comb_3),
                                 search_in_file(file = self.system_xml, word = comb_4),
                                 search_in_file(file = self.system_xml, word = comb_5),
                                 search_in_file(file = self.system_xml, word = comb_6)]
            #print(list_search_angle)
            for j in range(len(list_search_angle)):
                if list_search_angle[j] != []:
                    to_add = (list_search_angle[j],i)
                    #print(to_add)
                    index_search_replace_angle.append(to_add)   
        f_org = open(self.system_xml)
        lines = f_org.readlines()
        for i in range(len(index_search_replace_bond)):
            line_number = index_search_replace_bond[i][0][0][0] - 1
            line_to_replace = index_search_replace_bond[i][0][0][1]
            line_to_replace_with = index_search_replace_bond[i][1]
            lines[line_number] = line_to_replace_with 
        for i in range(len(index_search_replace_angle)):
            line_number = index_search_replace_angle[i][0][0][0] - 1
            line_to_replace = index_search_replace_angle[i][0][0][1]
            line_to_replace_with = index_search_replace_angle[i][1]
            lines[line_number] = line_to_replace_with 
        f_cop = open(self.reparameterised_intermediate_system_xml_file, &#34;w&#34;)
        for i in lines:
            f_cop.write(i)
        f_cop.close()

        f_params = open(self.system_qm_params_file)
        lines_params = f_params.readlines()
        # Charge Parameters
        for i in range(len(lines_params)):
            if &#34;Begin writing the Charge Parameters&#34; in lines_params[i]:
                to_begin = int(i)
            if &#34;Finish writing the Charge Parameters&#34; in lines_params[i]:
                to_end = int(i)  
        charge_params = lines_params[to_begin + 1:to_end]
        non_bonded_index = []
        for k in charge_params:
            non_bonded_index.append(int(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,k)[3]))
        charge_for_index = []
        for k in charge_params:
            charge_for_index.append(float(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,k)[0]))

        xml_off = open(self.system_xml) 
        xml_off_lines = xml_off.readlines() 
        for i in range(len(xml_off_lines)):
            if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
                to_begin = int(i)
            if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
                to_end = int(i)  
        nonbond_params = xml_off_lines[to_begin + 4 : to_end - 1]   
        #print(len(nonbond_params))
        f_non_bonded = open(self.system_xml_non_bonded_file, &#34;w&#34;) 
        for x in nonbond_params:
            f_non_bonded.write(x)

        f_non_bonded = open(self.system_xml_non_bonded_file)
        lines_non_bonded = f_non_bonded.readlines()
        #print(len(lines_non_bonded))
        lines_non_bonded_to_write = []
        for i in range(len(non_bonded_index)) :
            line_ = lines_non_bonded[non_bonded_index[i]]
            #print(line_)
            eps = float(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,line_)[0])
            sig = float(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,line_)[2])
            line_to_replace =     &#34;                                &#34; + &#34;&lt;Particle &#34; + &#34;eps=&#34; + &#39;&#34;&#39; + str(eps) + &#39;&#34;&#39; + &#34; &#34; + &#34;q=&#34; + &#39;&#34;&#39; + str(charge_for_index[i]) + &#39;&#34;&#39; + &#34; &#34; + &#34;sig=&#34; + &#39;&#34;&#39; + str(sig) + &#39;&#34;&#39; + &#34;/&gt;&#34; 
            lines_non_bonded_to_write.append(line_to_replace)
        data_ = list(zip(non_bonded_index,lines_non_bonded_to_write))

        df_non_bonded_params = pd.DataFrame(data_, columns=[&#39;line_index&#39;,&#39;line&#39;])
        #print(df_non_bonded_params.head())
        f_non_bonded_ = open(self.system_xml_non_bonded_file)
        lines_non_bonded_ = f_non_bonded_.readlines()
        for i in range(len(lines_non_bonded_)):
            if i in non_bonded_index:
                lines_non_bonded_[i] = (df_non_bonded_params.loc[df_non_bonded_params.line_index == i, &#39;line&#39;].values[0]) + &#34;\n&#34;
        #print(len(lines_non_bonded_))    
        f_write_non_bonded_reparams = open(self.system_xml_non_bonded_reparams_file, &#34;w&#34;) 
        for p in range(len(lines_non_bonded_)):
            f_write_non_bonded_reparams.write(lines_non_bonded_[p]) 
        f_write_non_bonded_reparams.close()
        f_ = open(self.system_xml_non_bonded_reparams_file)
        lines_ = f_.readlines()
        print(len(lines_) == len(lines_non_bonded))

        xml_off = open(self.reparameterised_intermediate_system_xml_file) 
        xml_off_lines = xml_off.readlines() 
        for i in range(len(xml_off_lines)):
            if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
                to_begin = int(i)
            if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
                to_end = int(i)  

        lines_before_params = xml_off_lines[ : to_begin + 4]
        f__ = open(self.system_xml_non_bonded_reparams_file)
        lines_params_non_bonded = f__.readlines()
        lines_after_params = xml_off_lines[to_end -1 : ]
        f_reparams_xml = open(self.reparameterised_system_xml_file, &#34;w&#34;) 
        for x in lines_before_params:
            f_reparams_xml.write(x)
        for x in lines_params_non_bonded:
            f_reparams_xml.write(x)
        for x in lines_after_params:
            f_reparams_xml.write(x)
        f_reparams_xml.close()
        
    def save_amber_params(self):

        if self.load_topology == &#34;parmed&#34;:
            openmm_system = parmed.openmm.load_topology(parmed.load_file(self.system_pdb, structure=True).topology, parmed.load_file(self.non_reparameterised_system_xml_file))
        if self.load_topology == &#34;openmm&#34;:
            openmm_system = parmed.openmm.load_topology(simtk.openmm.app.PDBFile(self.system_pdb).topology, parmed.load_file(self.non_reparameterised_system_xml_file))
        openmm_system.save(self.prmtop_system_non_params, overwrite=True)
        openmm_system.coordinates = parmed.load_file(self.system_pdb, structure=True).coordinates
        openmm_system.save(self.inpcrd_system_non_params, overwrite=True)
        parm = parmed.load_file(self.prmtop_system_non_params, self.inpcrd_system_non_params)

        xml_energy_decomposition = parmed.openmm.energy_decomposition_system(openmm_system, parmed.load_file(self.non_reparameterised_system_xml_file))
        xml_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        xml_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_xml = pd.DataFrame(list(zip(xml_energy_decomposition_list, xml_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_xml_non_params&#39;])
        df_energy_xml = df_energy_xml.set_index(&#39;Energy_term&#39;)

        prmtop_energy_decomposition = parmed.openmm.energy_decomposition_system(parm, parm.createSystem())
        prmtop_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        prmtop_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_prmtop = pd.DataFrame(list(zip(prmtop_energy_decomposition_list, prmtop_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_prmtop_non_params&#39;])
        df_energy_prmtop = df_energy_prmtop.set_index(&#39;Energy_term&#39;)

        df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
        print(df_compare)

        if self.load_topology == &#34;parmed&#34;:
            openmm_system = parmed.openmm.load_topology(parmed.load_file(self.system_pdb, structure=True).topology, parmed.load_file(self.reparameterised_system_xml_file))
        if self.load_topology == &#34;openmm&#34;:
            openmm_system = parmed.openmm.load_topology(simtk.openmm.app.PDBFile(self.system_pdb).topology, parmed.load_file(self.reparameterised_system_xml_file))
        openmm_system.save(self.prmtop_system_params, overwrite=True)
        openmm_system.coordinates = parmed.load_file(self.system_pdb, structure=True).coordinates
        openmm_system.save(self.inpcrd_system_params, overwrite=True)
        parm = parmed.load_file(self.prmtop_system_params, self.inpcrd_system_params)

        xml_energy_decomposition = parmed.openmm.energy_decomposition_system(openmm_system, parmed.load_file(self.reparameterised_system_xml_file))
        xml_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                           list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        xml_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_xml = pd.DataFrame(list(zip(xml_energy_decomposition_list, xml_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_xml_params&#39;])
        df_energy_xml = df_energy_xml.set_index(&#39;Energy_term&#39;)

        prmtop_energy_decomposition = parmed.openmm.energy_decomposition_system(parm, parm.createSystem())
        prmtop_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                              list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        prmtop_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_prmtop = pd.DataFrame(list(zip(prmtop_energy_decomposition_list, prmtop_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_prmtop_params&#39;])
        df_energy_prmtop = df_energy_prmtop.set_index(&#39;Energy_term&#39;)

        df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
        print(df_compare)
        
    def analyze_diff_energies(self):
        parm_non_params = parmed.load_file(self.prmtop_system_non_params, self.inpcrd_system_non_params)
        prmtop_energy_decomposition_non_params = parmed.openmm.energy_decomposition_system(parm_non_params, parm_non_params.createSystem())
        prmtop_energy_decomposition_non_params_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        prmtop_energy_decomposition_non_params_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_non_params = pd.DataFrame(list(zip(prmtop_energy_decomposition_non_params_list, prmtop_energy_decomposition_non_params_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_parm_non_params&#39;])
        df_energy_non_params = df_energy_non_params.set_index(&#39;Energy_term&#39;)
        #print(df_energy_non_params)
        parm_params = parmed.load_file(self.prmtop_system_params, self.inpcrd_system_params)
        prmtop_energy_decomposition_params = parmed.openmm.energy_decomposition_system(parm_params, parm_params.createSystem())
        prmtop_energy_decomposition_params_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                                        list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;NonbondedForce&#34;)]
        prmtop_energy_decomposition_params_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
        df_energy_params = pd.DataFrame(list(zip(prmtop_energy_decomposition_params_list, prmtop_energy_decomposition_params_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_parm_params&#39;])
        df_energy_params = df_energy_params.set_index(&#39;Energy_term&#39;)
        #print(df_energy_params)
        df_compare = pd.concat([df_energy_non_params, df_energy_params], axis=1)
        df_compare[&#39;Energy_difference&#39;] = df_compare[&#39;Energy_parm_non_params&#39;].sub(df_compare[&#39;Energy_parm_params&#39;], axis = 0)
        print(df_compare)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.HostAmberXMLAmber.analyze_diff_energies"><code class="name flex">
<span>def <span class="ident">analyze_diff_energies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analyze_diff_energies(self):
    parm_non_params = parmed.load_file(self.prmtop_system_non_params, self.inpcrd_system_non_params)
    prmtop_energy_decomposition_non_params = parmed.openmm.energy_decomposition_system(parm_non_params, parm_non_params.createSystem())
    prmtop_energy_decomposition_non_params_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                                    list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                                    list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                                    list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_non_params] for item in sublist]).get(&#34;NonbondedForce&#34;)]
    prmtop_energy_decomposition_non_params_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
    df_energy_non_params = pd.DataFrame(list(zip(prmtop_energy_decomposition_non_params_list, prmtop_energy_decomposition_non_params_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_parm_non_params&#39;])
    df_energy_non_params = df_energy_non_params.set_index(&#39;Energy_term&#39;)
    #print(df_energy_non_params)
    parm_params = parmed.load_file(self.prmtop_system_params, self.inpcrd_system_params)
    prmtop_energy_decomposition_params = parmed.openmm.energy_decomposition_system(parm_params, parm_params.createSystem())
    prmtop_energy_decomposition_params_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                                    list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                                    list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                                    list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition_params] for item in sublist]).get(&#34;NonbondedForce&#34;)]
    prmtop_energy_decomposition_params_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
    df_energy_params = pd.DataFrame(list(zip(prmtop_energy_decomposition_params_list, prmtop_energy_decomposition_params_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_parm_params&#39;])
    df_energy_params = df_energy_params.set_index(&#39;Energy_term&#39;)
    #print(df_energy_params)
    df_compare = pd.concat([df_energy_non_params, df_energy_params], axis=1)
    df_compare[&#39;Energy_difference&#39;] = df_compare[&#39;Energy_parm_non_params&#39;].sub(df_compare[&#39;Energy_parm_params&#39;], axis = 0)
    print(df_compare)</code></pre>
</details>
</dd>
<dt id="parameterize.HostAmberXMLAmber.save_amber_params"><code class="name flex">
<span>def <span class="ident">save_amber_params</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_amber_params(self):

    if self.load_topology == &#34;parmed&#34;:
        openmm_system = parmed.openmm.load_topology(parmed.load_file(self.system_pdb, structure=True).topology, parmed.load_file(self.non_reparameterised_system_xml_file))
    if self.load_topology == &#34;openmm&#34;:
        openmm_system = parmed.openmm.load_topology(simtk.openmm.app.PDBFile(self.system_pdb).topology, parmed.load_file(self.non_reparameterised_system_xml_file))
    openmm_system.save(self.prmtop_system_non_params, overwrite=True)
    openmm_system.coordinates = parmed.load_file(self.system_pdb, structure=True).coordinates
    openmm_system.save(self.inpcrd_system_non_params, overwrite=True)
    parm = parmed.load_file(self.prmtop_system_non_params, self.inpcrd_system_non_params)

    xml_energy_decomposition = parmed.openmm.energy_decomposition_system(openmm_system, parmed.load_file(self.non_reparameterised_system_xml_file))
    xml_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                       list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                       list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                       list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
    xml_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
    df_energy_xml = pd.DataFrame(list(zip(xml_energy_decomposition_list, xml_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_xml_non_params&#39;])
    df_energy_xml = df_energy_xml.set_index(&#39;Energy_term&#39;)

    prmtop_energy_decomposition = parmed.openmm.energy_decomposition_system(parm, parm.createSystem())
    prmtop_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                          list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                          list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                          list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
    prmtop_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
    df_energy_prmtop = pd.DataFrame(list(zip(prmtop_energy_decomposition_list, prmtop_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_prmtop_non_params&#39;])
    df_energy_prmtop = df_energy_prmtop.set_index(&#39;Energy_term&#39;)

    df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
    print(df_compare)

    if self.load_topology == &#34;parmed&#34;:
        openmm_system = parmed.openmm.load_topology(parmed.load_file(self.system_pdb, structure=True).topology, parmed.load_file(self.reparameterised_system_xml_file))
    if self.load_topology == &#34;openmm&#34;:
        openmm_system = parmed.openmm.load_topology(simtk.openmm.app.PDBFile(self.system_pdb).topology, parmed.load_file(self.reparameterised_system_xml_file))
    openmm_system.save(self.prmtop_system_params, overwrite=True)
    openmm_system.coordinates = parmed.load_file(self.system_pdb, structure=True).coordinates
    openmm_system.save(self.inpcrd_system_params, overwrite=True)
    parm = parmed.load_file(self.prmtop_system_params, self.inpcrd_system_params)

    xml_energy_decomposition = parmed.openmm.energy_decomposition_system(openmm_system, parmed.load_file(self.reparameterised_system_xml_file))
    xml_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                       list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                       list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                       list_to_dict([item for sublist in [list(elem) for elem in xml_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
    xml_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
    df_energy_xml = pd.DataFrame(list(zip(xml_energy_decomposition_list, xml_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_xml_params&#39;])
    df_energy_xml = df_energy_xml.set_index(&#39;Energy_term&#39;)

    prmtop_energy_decomposition = parmed.openmm.energy_decomposition_system(parm, parm.createSystem())
    prmtop_energy_decomposition_value =  [list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicBondForce&#34;), 
                                          list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;HarmonicAngleForce&#34;), 
                                          list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;PeriodicTorsionForce&#34;), 
                                          list_to_dict([item for sublist in [list(elem) for elem in prmtop_energy_decomposition] for item in sublist]).get(&#34;NonbondedForce&#34;)]
    prmtop_energy_decomposition_list = [&#34;HarmonicBondForce&#34;, &#34;HarmonicAngleForce&#34;, &#34;PeriodicTorsionForce&#34;, &#34;NonbondedForce&#34;]
    df_energy_prmtop = pd.DataFrame(list(zip(prmtop_energy_decomposition_list, prmtop_energy_decomposition_value)), columns=[&#39;Energy_term&#39;,&#39;Energy_prmtop_params&#39;])
    df_energy_prmtop = df_energy_prmtop.set_index(&#39;Energy_term&#39;)

    df_compare = pd.concat([df_energy_xml, df_energy_prmtop], axis=1)
    print(df_compare)</code></pre>
</details>
</dd>
<dt id="parameterize.HostAmberXMLAmber.serialize_system"><code class="name flex">
<span>def <span class="ident">serialize_system</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize_system(self):        
    pdb = simtk.openmm.app.PDBFile(self.system_pdb)
    forcefield = simtk.openmm.app.ForceField(&#39;amber14-all.xml&#39;)
    system = forcefield.createSystem(pdb.topology)
    integrator = simtk.openmm.LangevinIntegrator(300 * simtk.unit.kelvin, 1 / simtk.unit.picosecond, 0.002 * simtk.unit.picoseconds)
    simulation = simtk.openmm.app.Simulation(pdb.topology, system, integrator)
    simulation.context.setPositions(pdb.positions)
    simulation.minimizeEnergy()
    state = simulation.context.getState(getEnergy=True)
    energy = state.getPotentialEnergy()
    print(energy)
    simulation.reporters.append(simtk.openmm.app.PDBReporter(self.sim_output, self.sim_steps/10))
    simulation.reporters.append(simtk.openmm.app.StateDataReporter(stdout, reportInterval = int(self.sim_steps/10), step = True, potentialEnergy = True, temperature = True))
    simulation.step(self.sim_steps)
    command = &#34;rm -rf &#34; + self.sim_output
    os.system(command)
    with open(self.system_xml, &#39;w&#39;) as f:
        f.write(simtk.openmm.XmlSerializer.serialize(system))</code></pre>
</details>
</dd>
<dt id="parameterize.HostAmberXMLAmber.write_reparameterised_system_xml"><code class="name flex">
<span>def <span class="ident">write_reparameterised_system_xml</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_reparameterised_system_xml(self):
    # Bond Parameters
    f_params = open(self.system_qm_params_file, &#39;r&#39;)
    lines_params = f_params.readlines()
    # Bond Parameters
    for i in range(len(lines_params)):
        if &#34;Begin writing the Bond Parameters&#34; in lines_params[i]:
            to_begin = int(i)
        if &#34;Finish writing the Bond Parameters&#34; in lines_params[i]:
            to_end = int(i)  
    bond_params = lines_params[to_begin + 1:to_end]
    index_search_replace_bond = []
    for i in bond_params:
        bond_line_to_replace = i
        #print(bond_line_to_replace)
        atom_number_list = [re.findall(&#39;\d*\.?\d+&#39;, i)[3], re.findall(&#39;\d*\.?\d+&#39;, i)[5]]
        #print(atom_number_list)
        comb_1 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34;/&gt;&#34;
        comb_2 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34;/&gt;&#34;
        comb_list_bond = [comb_1, comb_2]
        #print(comb_list_bond)
        list_search_bond = [search_in_file(file = self.system_xml, word = comb_1),search_in_file(file = self.system_xml, word = comb_2)]
        #print(list_search_bond)
        for j in range(len(list_search_bond)):
            if list_search_bond[j] != []:
                to_add = (list_search_bond[j],i)
                #print(to_add)
                index_search_replace_bond.append(to_add)
    # Angle Parameters
    for i in range(len(lines_params)):
        if &#34;Begin writing the Angle Parameters&#34; in lines_params[i]:
            to_begin = int(i)
        if &#34;Finish writing the Angle Parameters&#34; in lines_params[i]:
            to_end = int(i)  
    angle_params = lines_params[to_begin + 1:to_end]
    index_search_replace_angle = []
    for i in angle_params:
        angle_line_to_replace = i
        #print(angle_line_to_replace)
    index_search_replace_angle = []
    for i in angle_params:
        angle_line_to_replace = i
        #print(angle_line_to_replace)
        atom_number_list = [re.findall(&#39;\d*\.?\d+&#39;, i)[3], re.findall(&#39;\d*\.?\d+&#39;, i)[5], re.findall(&#39;\d*\.?\d+&#39;, i)[7]]
        #print(atom_number_list)
        comb_1 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34;/&gt;&#34;
        comb_2 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34;/&gt;&#34;
        comb_3 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34;/&gt;&#34;
        comb_4 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34;/&gt;&#34;
        comb_5 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34;/&gt;&#34;
        comb_6 = &#34;p1=&#34; + &#39;&#34;&#39; + atom_number_list[2] + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + atom_number_list[1] + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + atom_number_list[0] + &#39;&#34;&#39; + &#34;/&gt;&#34;
        comb_list_angle = [comb_1, comb_2, comb_3, comb_4, comb_5, comb_6]
        #print(comb_list_angle)    
        list_search_angle = [search_in_file(file = self.system_xml, word = comb_1), 
                             search_in_file(file = self.system_xml, word = comb_2),
                             search_in_file(file = self.system_xml, word = comb_3),
                             search_in_file(file = self.system_xml, word = comb_4),
                             search_in_file(file = self.system_xml, word = comb_5),
                             search_in_file(file = self.system_xml, word = comb_6)]
        #print(list_search_angle)
        for j in range(len(list_search_angle)):
            if list_search_angle[j] != []:
                to_add = (list_search_angle[j],i)
                #print(to_add)
                index_search_replace_angle.append(to_add)   
    f_org = open(self.system_xml)
    lines = f_org.readlines()
    for i in range(len(index_search_replace_bond)):
        line_number = index_search_replace_bond[i][0][0][0] - 1
        line_to_replace = index_search_replace_bond[i][0][0][1]
        line_to_replace_with = index_search_replace_bond[i][1]
        lines[line_number] = line_to_replace_with 
    for i in range(len(index_search_replace_angle)):
        line_number = index_search_replace_angle[i][0][0][0] - 1
        line_to_replace = index_search_replace_angle[i][0][0][1]
        line_to_replace_with = index_search_replace_angle[i][1]
        lines[line_number] = line_to_replace_with 
    f_cop = open(self.reparameterised_intermediate_system_xml_file, &#34;w&#34;)
    for i in lines:
        f_cop.write(i)
    f_cop.close()

    f_params = open(self.system_qm_params_file)
    lines_params = f_params.readlines()
    # Charge Parameters
    for i in range(len(lines_params)):
        if &#34;Begin writing the Charge Parameters&#34; in lines_params[i]:
            to_begin = int(i)
        if &#34;Finish writing the Charge Parameters&#34; in lines_params[i]:
            to_end = int(i)  
    charge_params = lines_params[to_begin + 1:to_end]
    non_bonded_index = []
    for k in charge_params:
        non_bonded_index.append(int(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,k)[3]))
    charge_for_index = []
    for k in charge_params:
        charge_for_index.append(float(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,k)[0]))

    xml_off = open(self.system_xml) 
    xml_off_lines = xml_off.readlines() 
    for i in range(len(xml_off_lines)):
        if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
            to_begin = int(i)
        if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
            to_end = int(i)  
    nonbond_params = xml_off_lines[to_begin + 4 : to_end - 1]   
    #print(len(nonbond_params))
    f_non_bonded = open(self.system_xml_non_bonded_file, &#34;w&#34;) 
    for x in nonbond_params:
        f_non_bonded.write(x)

    f_non_bonded = open(self.system_xml_non_bonded_file)
    lines_non_bonded = f_non_bonded.readlines()
    #print(len(lines_non_bonded))
    lines_non_bonded_to_write = []
    for i in range(len(non_bonded_index)) :
        line_ = lines_non_bonded[non_bonded_index[i]]
        #print(line_)
        eps = float(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,line_)[0])
        sig = float(re.findall(&#39;[-+]?\d*\.\d+|\d+&#39;,line_)[2])
        line_to_replace =     &#34;                                &#34; + &#34;&lt;Particle &#34; + &#34;eps=&#34; + &#39;&#34;&#39; + str(eps) + &#39;&#34;&#39; + &#34; &#34; + &#34;q=&#34; + &#39;&#34;&#39; + str(charge_for_index[i]) + &#39;&#34;&#39; + &#34; &#34; + &#34;sig=&#34; + &#39;&#34;&#39; + str(sig) + &#39;&#34;&#39; + &#34;/&gt;&#34; 
        lines_non_bonded_to_write.append(line_to_replace)
    data_ = list(zip(non_bonded_index,lines_non_bonded_to_write))

    df_non_bonded_params = pd.DataFrame(data_, columns=[&#39;line_index&#39;,&#39;line&#39;])
    #print(df_non_bonded_params.head())
    f_non_bonded_ = open(self.system_xml_non_bonded_file)
    lines_non_bonded_ = f_non_bonded_.readlines()
    for i in range(len(lines_non_bonded_)):
        if i in non_bonded_index:
            lines_non_bonded_[i] = (df_non_bonded_params.loc[df_non_bonded_params.line_index == i, &#39;line&#39;].values[0]) + &#34;\n&#34;
    #print(len(lines_non_bonded_))    
    f_write_non_bonded_reparams = open(self.system_xml_non_bonded_reparams_file, &#34;w&#34;) 
    for p in range(len(lines_non_bonded_)):
        f_write_non_bonded_reparams.write(lines_non_bonded_[p]) 
    f_write_non_bonded_reparams.close()
    f_ = open(self.system_xml_non_bonded_reparams_file)
    lines_ = f_.readlines()
    print(len(lines_) == len(lines_non_bonded))

    xml_off = open(self.reparameterised_intermediate_system_xml_file) 
    xml_off_lines = xml_off.readlines() 
    for i in range(len(xml_off_lines)):
        if &#34;&lt;GlobalParameters/&gt;&#34; in xml_off_lines[i]:
            to_begin = int(i)
        if &#34;&lt;Exceptions&gt;&#34; in xml_off_lines[i]:
            to_end = int(i)  

    lines_before_params = xml_off_lines[ : to_begin + 4]
    f__ = open(self.system_xml_non_bonded_reparams_file)
    lines_params_non_bonded = f__.readlines()
    lines_after_params = xml_off_lines[to_end -1 : ]
    f_reparams_xml = open(self.reparameterised_system_xml_file, &#34;w&#34;) 
    for x in lines_before_params:
        f_reparams_xml.write(x)
    for x in lines_params_non_bonded:
        f_reparams_xml.write(x)
    for x in lines_after_params:
        f_reparams_xml.write(x)
    f_reparams_xml.close()</code></pre>
</details>
</dd>
<dt id="parameterize.HostAmberXMLAmber.write_system_params"><code class="name flex">
<span>def <span class="ident">write_system_params</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves the parameters obtained from the QM log files in a text file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_system_params(self):
    &#34;&#34;&#34;
    This function saves the parameters obtained from the QM log files in a text file. 
    &#34;&#34;&#34;
    # Charges from QM files
    df_charges = pd.read_csv(self.charge_parameter_file, header = None, delimiter = r&#34;\s+&#34;)
    df_charges.columns = [&#34;atom&#34;, &#34;charges&#34;]
    qm_charges = df_charges[&#34;charges&#34;].values.tolist()
    qm_charges = [round(num, 6) for num in qm_charges]
    #print(qm_charges)
    # Bond Parameters from QM files
    ppdb = PandasPdb()
    ppdb.read_pdb(self.system_qm_pdb)
    atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
    atom_name_list = [i - 1 for i in atom_name_list]
    #print(atom_name_list)
    df = pd.read_csv(self.bond_parameter_file, header = None, delimiter = r&#34;\s+&#34;)
    df.columns = [&#34;bond&#34;, &#34;k_bond&#34;, &#34;bond_length&#34;, &#34;bond_1&#34;, &#34;bond_2&#34;]
    #print(df.head())
    bond_1_list = df[&#34;bond_1&#34;].values.tolist()
    bond_1_list = [x - 1 + min(atom_name_list) for x in bond_1_list]
    bond_2_list = df[&#34;bond_2&#34;].values.tolist()
    bond_2_list = [x - 1 + min(atom_name_list) for x in bond_2_list]
    #print(bond_1_list)
    #print(bond_2_list)
    k_bond_list = df[&#34;k_bond&#34;].values.tolist()
    k_bond_list = [i* 1000.00 for i in k_bond_list]
    k_bond_list = [round(num, 10) for num in k_bond_list]
    #print(k_bond_list)
    bond_length_list = df[&#34;bond_length&#34;].values.tolist()
    bond_length_list = [i/10.00 for i in bond_length_list]
    bond_length_list = [round(num, 6) for num in bond_length_list]
    #print(bond_length_list)
    # Angle Parameters from QM files
    ppdb = PandasPdb()
    ppdb.read_pdb(self.system_qm_pdb)
    atom_name_list = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;].values.tolist()
    atom_name_list = [i - 1 for i in atom_name_list]
    #print(atom_name_list)
    df = pd.read_csv(self.angle_parameter_file, header = None, delimiter = r&#34;\s+&#34;)
    df.columns = [&#34;angle&#34;, &#34;k_angle&#34;, &#34;angle_degrees&#34;, &#34;angle_1&#34;, &#34;angle_2&#34;, &#34;angle_3&#34;]
    #print(df.head())
    angle_1_list = df[&#34;angle_1&#34;].values.tolist()
    angle_1_list = [x - 1 + min(atom_name_list) for x in angle_1_list]
    #print(angle_1_list)
    angle_2_list = df[&#34;angle_2&#34;].values.tolist()
    angle_2_list = [x - 1 + min(atom_name_list) for x in angle_2_list]
    #print(angle_2_list)
    angle_3_list = df[&#34;angle_3&#34;].values.tolist()
    angle_3_list = [x - 1 + min(atom_name_list) for x in angle_3_list]
    #print(angle_3_list)
    k_angle_list = df[&#34;k_angle&#34;].values.tolist()
    k_angle_list = [round(num, 6) for num in k_angle_list]
    #print(k_angle_list)
    angle_list = df[&#34;angle_degrees&#34;].values.tolist()
    angle_list = [(i * math.pi)/180.00 for i in angle_list]
    angle_list = [round(num, 6) for num in angle_list]
    #print(angle_list)
    xml = open(self.system_qm_params_file, &#34;w&#34;)
    xml.write(&#34;Begin writing the Bond Parameters&#34; + &#34;\n&#34;)
    for i in range(len(k_bond_list)):
        xml.write(&#34;                                &#34; + &#34;&lt;Bond&#34;  + &#34; &#34; 
                           + &#34;d=&#34; + &#39;&#34;&#39; + str(bond_length_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                           + &#34;k=&#34; + &#39;&#34;&#39; + str(k_bond_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                           + &#34;p1=&#34; + &#39;&#34;&#39; + str(bond_1_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                           + &#34;p2=&#34; + &#39;&#34;&#39; + str(bond_2_list[i]) + &#39;&#34;&#39;  
                           + &#34;/&gt;&#34;  + &#34;\n&#34;)  
    xml.write(&#34;Finish writing the Bond Parameters&#34; + &#34;\n&#34;)
    xml.write(&#34;Begin writing the Angle Parameters&#34; + &#34;\n&#34;)
    for i in range(len(k_angle_list)):
        xml.write(&#34;                                &#34; + &#34;&lt;Angle&#34; + &#34; &#34; 
                           + &#34;a=&#34; + &#39;&#34;&#39; + str(angle_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                           + &#34;k=&#34; + &#39;&#34;&#39; + str(k_angle_list[i])  + &#39;&#34;&#39; + &#34; &#34;
                           + &#34;p1=&#34; + &#39;&#34;&#39; + str(angle_1_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                           + &#34;p2=&#34; + &#39;&#34;&#39; + str(angle_2_list[i]) + &#39;&#34;&#39; + &#34; &#34; 
                           + &#34;p3=&#34; + &#39;&#34;&#39; + str(angle_3_list[i]) + &#39;&#34;&#39; 
                           + &#34;/&gt;&#34;  + &#34;\n&#34;)
    xml.write(&#34;Finish writing the Angle Parameters&#34; + &#34;\n&#34;)    
    xml.write(&#34;Begin writing the Charge Parameters&#34; + &#34;\n&#34;)
    for i in range(len(qm_charges)):
        xml.write(&#34;&lt;Particle&#34; + &#34; &#34; 
                          + &#34;q=&#34; + &#39;&#34;&#39; + str(qm_charges[i]) + &#39;&#34;&#39; + &#34; &#34; 
                          + &#34;eps=&#34; + &#39;&#34;&#39; + str(0.00) + &#39;&#34;&#39; + &#34; &#34; 
                          + &#34;sig=&#34; + &#39;&#34;&#39; + str(0.00) + &#39;&#34;&#39; + &#34; &#34;   
                          + &#34;atom=&#34; + &#39;&#34;&#39; + str(atom_name_list[i]) + &#39;&#34;&#39; 
                          + &#34;/&gt;&#34;  + &#34;\n&#34;)
    xml.write(&#34;Finish writing the Charge Parameters&#34; + &#34;\n&#34;)    
    xml.close()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.MergeHostGuestTopology"><code class="flex name class">
<span>class <span class="ident">MergeHostGuestTopology</span></span>
<span>(</span><span>host_prmtop, guest_prmtop, host_inpcrd, guest_inpcrd, system_prmtop, system_inpcrd)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MergeHostGuestTopology:

    def __init__(self, host_prmtop, guest_prmtop, host_inpcrd, guest_inpcrd, system_prmtop, system_inpcrd):  
        self.host_prmtop = host_prmtop
        self.guest_prmtop = guest_prmtop
        self.host_inpcrd = host_inpcrd
        self.guest_inpcrd = guest_inpcrd
        self.system_prmtop = system_prmtop 
        self.system_inpcrd = system_inpcrd 

    def merge_topology_files(self):
        print(&#34;Merging the &#34; + self.host_prmtop + &#34; &#34; + self.guest_prmtop + &#34; files&#34;)
        print(&#34;Merging the &#34; + self.host_inpcrd + &#34; &#34; + self.guest_inpcrd + &#34; files&#34;)
        host_system = parmed.load_file(self.host_prmtop, xyz = self.host_inpcrd)
        guest_system = parmed.load_file(self.guest_prmtop, xyz = self.guest_inpcrd)
        system = host_system + guest_system
        system.save(self.system_prmtop, overwrite = True)
        system.save(self.system_inpcrd, overwrite = True)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.MergeHostGuestTopology.merge_topology_files"><code class="name flex">
<span>def <span class="ident">merge_topology_files</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_topology_files(self):
    print(&#34;Merging the &#34; + self.host_prmtop + &#34; &#34; + self.guest_prmtop + &#34; files&#34;)
    print(&#34;Merging the &#34; + self.host_inpcrd + &#34; &#34; + self.guest_inpcrd + &#34; files&#34;)
    host_system = parmed.load_file(self.host_prmtop, xyz = self.host_inpcrd)
    guest_system = parmed.load_file(self.guest_prmtop, xyz = self.guest_inpcrd)
    system = host_system + guest_system
    system.save(self.system_prmtop, overwrite = True)
    system.save(self.system_inpcrd, overwrite = True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.ParameterizeGuest"><code class="flex name class">
<span>class <span class="ident">ParameterizeGuest</span></span>
<span>(</span><span>vibrational_scaling, xyz_file='guest_coords.xyz', coordinate_file='guest_coordinates.txt', unprocessed_hessian_file='guest_unprocessed_hessian.txt', bond_list_file='guest_bond_list.txt', angle_list_file='guest_angle_list.txt', hessian_file='guest_hessian.txt', atom_names_file='guest_atom_names.txt', bond_parameter_file='guest_bonds.txt', angle_parameter_file='guest_angles.txt', charge_parameter_file='guest_charges.txt', guest_pdb='guest_init_II.pdb', proper_dihedral_file='proper_dihedrals.txt')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterizeGuest:
    
    def __init__(self, vibrational_scaling, xyz_file = &#34;guest_coords.xyz&#34;, coordinate_file = &#34;guest_coordinates.txt&#34;, unprocessed_hessian_file = &#34;guest_unprocessed_hessian.txt&#34;, bond_list_file = &#34;guest_bond_list.txt&#34;, angle_list_file = &#34;guest_angle_list.txt&#34;, hessian_file = &#34;guest_hessian.txt&#34;, atom_names_file = &#34;guest_atom_names.txt&#34;, bond_parameter_file = &#34;guest_bonds.txt&#34;, angle_parameter_file = &#34;guest_angles.txt&#34;, charge_parameter_file = &#34;guest_charges.txt&#34;, guest_pdb = &#34;guest_init_II.pdb&#34;, proper_dihedral_file = &#34;proper_dihedrals.txt&#34;):
        self.vibrational_scaling = vibrational_scaling
        self.xyz_file = xyz_file
        self.coordinate_file = coordinate_file
        self.unprocessed_hessian_file = unprocessed_hessian_file
        self.bond_list_file = bond_list_file
        self.angle_list_file = angle_list_file
        self.hessian_file = hessian_file
        self.atom_names_file = atom_names_file
        self.bond_parameter_file = bond_parameter_file
        self.angle_parameter_file = angle_parameter_file
        self.charge_parameter_file = charge_parameter_file
        self.guest_pdb = guest_pdb
        self.proper_dihedral_file = proper_dihedral_file
        
    def get_xyz(self):   
        &#34;&#34;&#34;
        This function saves a xyz file from the formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
        with open (fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
                no_coordinates = int(no_coordinates[0])
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                to_begin = int(i)     
        cartesian_coords = lines[to_begin + 1:to_begin + 1 + int(math.ceil(no_coordinates/5))]
        cartesian_list = []
        for i in range(len(cartesian_coords)):
            cartesian_list.append(cartesian_coords[i].strip().split())
        coordinates_list = [item for sublist in cartesian_list for item in sublist]
        list_coords = [float(x)*float(0.529) for x in coordinates_list]
        for i in range(len(lines)):
            if &#34;Atomic numbers&#34; in lines[i]:
                to_begin = int(i) 
            if &#34;Nuclear charges&#34; in lines[i]:
                to_end = int(i)    
        atomic_numbers = lines[to_begin + 1:to_end]
        atom_numbers = []
        for i in range(len(atomic_numbers)):
            atom_numbers.append(atomic_numbers[i].strip().split())
        numbers = [item for sublist in atom_numbers for item in sublist]
        N = int(no_coordinates/3)
        # Opens the new xyz file 
        file = open(self.xyz_file, &#34;w&#34;)
        file.write(str(N) + &#39;\n \n&#39;)
        coords = np.zeros((N,3))
        n = 0
        names = []   
        # Gives name for atomic number
        for x in range(0,len(numbers)):
            names.append(element_list[int(numbers[x]) - 1][1]) 
        # Print coordinates to new input_coords.xyz file
        for i in range(0, N):
            for j in range(0,3):
                coords[i][j] = list_coords[n]
                n = n + 1
            file.write(names[i] + str(round(coords[i][0],3)) + &#39; &#39; + str(round(coords[i][1],3)) + &#39; &#39; + str(round(coords[i][2], 3)) + &#39;\n&#39;)
        file.close()
        np.savetxt(self.coordinate_file, coords, fmt=&#39;%s&#39;)  
        
    def get_unprocessed_hessian(self):   
        &#34;&#34;&#34;
        This function saves a text file of the unprocessed hessian from the formatted checkpoint file.
        &#34;&#34;&#34;    
        fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
        with open (fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Cartesian Force Constants&#34; in lines[i]:
                no_hessian = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
                no_hessian = int(no_hessian[0])
        for i in range(len(lines)):
            if &#34;Cartesian Force Constants&#34; in lines[i]:
                to_begin = int(i)     
        hessian = lines[to_begin + 1:to_begin + 1 + int(math.ceil(no_hessian/5))]
        hessian_list = []
        for i in range(len(hessian)):
            hessian_list.append(hessian[i].strip().split())
        unprocessed_Hessian = [item for sublist in hessian_list for item in sublist]
        np.savetxt(self.unprocessed_hessian_file, unprocessed_Hessian, fmt=&#39;%s&#39;)
        
    def get_bond_angles(self):   
        &#34;&#34;&#34;
        This function saves a text file of the bonds and angles from the gaussian log file.
        &#34;&#34;&#34; 
        log_file = self.guest_pdb[:-4] + &#34;.log&#34;
        fid = open(log_file, &#34;r&#34;)
        tline = fid.readline()
        bond_list = []
        angle_list = []
        n = 1
        n_bond = 1
        n_angle = 1
        tmp = &#39;R&#39; # States if bond or angle
        B = []
        # Finds the bond and angles from the .log file
        while tline:
            tline = fid.readline()
            # Line starts at point when bond and angle list occurs
            if len(tline) &gt; 80 and tline[0:81].strip() == &#39;! Name  Definition              Value          Derivative Info.                !&#39;:
                tline = fid.readline()
                tline = fid.readline()
                # Stops when all bond and angles recorded 
                while ( ( tmp[0] == &#39;R&#39; ) or (tmp[0] == &#39;A&#39;) ):
                    line = tline.split()
                    tmp = line[1]
                    # Bond or angles listed as string
                    list_terms = line[2][2:-1]
                    # Bond List 
                    if ( tmp[0] == &#39;R&#39; ): 
                        x = list_terms.split(&#39;,&#39;)
                        # Subtraction due to python array indexing at 0
                        x = [(int(i) - 1 ) for i in x]
                        bond_list.append(x)
                        # Angle List 
                    if (tmp[0] == &#39;A&#39; ): 
                        x = list_terms.split(&#39;,&#39;)
                        # Subtraction due to python array indexing at 0
                        x = [(int(i) - 1 ) for i in x]
                        angle_list.append(x)
                    tline = fid.readline()
                # Leave loop
                tline = -1
        np.savetxt(self.bond_list_file, bond_list, fmt=&#39;%s&#39;)
        np.savetxt(self.angle_list_file, angle_list, fmt=&#39;%s&#39;)
        
    def get_hessian(self):
        &#34;&#34;&#34;
        This function extracts hessian from the unprocessed hessian and saves into a new file.
        &#34;&#34;&#34;       
        unprocessed_Hessian = np.loadtxt(self.unprocessed_hessian_file) 
        fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;     
        with open (fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
                no_coordinates = int(no_coordinates[0])
        N = int(no_coordinates/3)    
        length_hessian = 3 * N
        hessian = np.zeros((length_hessian, length_hessian))
        m = 0
        # Write the hessian in a 2D array format 
        for i in range (0,(length_hessian)):
            for j in range (0,(i + 1)):
                hessian[i][j] = unprocessed_Hessian[m]
                hessian[j][i] = unprocessed_Hessian[m]
                m = m + 1
        hessian = (hessian * (627.509391))/ (0.529**2)  # Change from Hartree/bohr to kcal/mol/ang
        np.savetxt(self.hessian_file, hessian, fmt=&#39;%s&#39;)

    def get_atom_names(self):
        &#34;&#34;&#34;
        This function saves a list of atom names from the formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
        with open (fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()    
        for i in range(len(lines)):
            if &#34;Atomic numbers&#34; in lines[i]:
                to_begin = int(i) 
            if &#34;Nuclear charges&#34; in lines[i]:
                to_end = int(i) 
        atomic_numbers = lines[to_begin + 1:to_end]
        atom_numbers = []
        for i in range(len(atomic_numbers)):
            atom_numbers.append(atomic_numbers[i].strip().split())
        numbers = [item for sublist in atom_numbers for item in sublist]
        names = []   
        # Gives name for atomic number
        for x in range(0,len(numbers)):
            names.append(element_list[int(numbers[x]) - 1][1]) 
        atom_names = []
        for i in range(0,len(names)):
            atom_names.append(names[i].strip() + str(i + 1))
        np.savetxt(self.atom_names_file, atom_names, fmt =&#39;%s&#39;)
        
    def get_bond_angle_params(self):  
        &#34;&#34;&#34;
        This function saves the bond and angle parameter files obtained from the formatted checkpoint file. 
        &#34;&#34;&#34;
        fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
        with open (fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
                no_coordinates = int(no_coordinates[0])    
        N = int(no_coordinates/3)
        coords = np.loadtxt(self.coordinate_file)
        hessian = np.loadtxt(self.hessian_file)
        bond_list = np.loadtxt(self.bond_list_file, dtype = int)
        atom_names = np.loadtxt(self.atom_names_file, dtype = str) 
        # Find bond lengths
        bond_lengths = np.zeros((N, N))
        for i in range (0,N):
            for j in range(0,N):
                diff_i_j = np.array(coords[i,:]) - np.array(coords[j,:])
                bond_lengths[i][j] =  np.linalg.norm(diff_i_j)
        eigenvectors = np.empty((3, 3, N, N), dtype=complex)
        eigenvalues = np.empty((N, N, 3), dtype=complex)
        partial_hessian = np.zeros((3, 3))
        for i in range(0,N):
            for j in range(0,N):
                partial_hessian = hessian[(i * 3):((i + 1)*3),(j * 3):((j + 1)*3)]
                [a, b] = np.linalg.eig(partial_hessian)
                eigenvalues[i,j,:] = (a)
                eigenvectors[:,:,i,j] = (b)
        # Modified Seminario method to find the bond parameters and print them to file
        file_bond = open(self.bond_parameter_file, &#39;w&#39;)
        k_b = np.zeros(len(bond_list))
        bond_length_list = np.zeros(len(bond_list))
        unique_values_bonds = [] # Used to find average values 
        for i in range(0, len(bond_list)):
            AB = force_constant_bond(bond_list[i][0], bond_list[i][1],eigenvalues, eigenvectors, coords)
            BA = force_constant_bond(bond_list[i][1], bond_list[i][0],eigenvalues, eigenvectors, coords)
            # Order of bonds sometimes causes slight differences, find the mean
            k_b[i] = np.real(( AB + BA ) /2); 
            # Vibrational_scaling takes into account DFT deficities/ anharmocity   
            vibrational_scaling_squared = self.vibrational_scaling**2        
            k_b[i] = k_b[i] * vibrational_scaling_squared
            bond_length_list[i] =  bond_lengths[bond_list[i][0]][bond_list[i][1]]
            file_bond.write(atom_names[bond_list[i][0]] + &#39;-&#39; + atom_names[bond_list[i][1]] + &#39;  &#39;)
            file_bond.write(str(&#34;%#.5g&#34; % k_b[i])+ &#39;   &#39; + str(&#34;%#.4g&#34; % bond_length_list[i]) +  &#39;   &#39; + str(bond_list[i][0] + 1) +  &#39;   &#39; + str(bond_list[i][1] + 1))
            file_bond.write(&#39;\n&#39;)
            unique_values_bonds.append([atom_names[bond_list[i][0]], atom_names[bond_list[i][1]], k_b[i], bond_length_list[i], 1 ])
        file_bond.close()
        angle_list = np.loadtxt(self.angle_list_file, dtype = int)
        # Modified Seminario method to find the angle parameters and print them to file
        file_angle = open(self.angle_parameter_file, &#39;w&#39;)
        k_theta = np.zeros(len(angle_list))
        theta_0 = np.zeros(len(angle_list))
        unique_values_angles = [] # Used to find average values
        # Modified Seminario part goes here ...
        # Connectivity information for Modified Seminario Method
        central_atoms_angles = []
        # A structure is created with the index giving the central atom of the angle, an array then lists the angles with that central atom. 
        # i.e. central_atoms_angles{3} contains an array of angles with central atom 3
        for i in range(0, len(coords)):
            central_atoms_angles.append([])
            for j in range(0, len(angle_list)):
                if i == angle_list[j][1]:
                    # For angle ABC, atoms A C are written to array
                    AC_array = [angle_list[j][0],  angle_list[j][2], j]
                    central_atoms_angles[i].append(AC_array)
                    # For angle ABC, atoms C A are written to array
                    CA_array = [angle_list[j][2],  angle_list[j][0], j]
                    central_atoms_angles[i].append(CA_array)
        # Sort rows by atom number
        for i in range(0, len(coords)):
            central_atoms_angles[i] = sorted(central_atoms_angles[i], key=itemgetter(0))
        # Find normals u_PA for each angle
        unit_PA_all_angles = []
        for i in range(0,len(central_atoms_angles)):
            unit_PA_all_angles.append([])
            for j in range(0, len(central_atoms_angles[i])):
                # For the angle at central_atoms_angles[i][j,:] the corresponding u_PA value is found for the plane ABC and bond AB, where ABC corresponds to the order of the arguements. This is why the reverse order was also added
                unit_PA_all_angles[i].append(u_PA_from_angles(central_atoms_angles[i][j][0], i, central_atoms_angles[i][j][1], coords))
        # Finds the contributing factors from the other angle terms scaling_factor_all_angles = cell(max(max(angle_list))); %This array will contain scaling factor and angle list position
        scaling_factor_all_angles = []
        for i in range(0,len(central_atoms_angles)):
            scaling_factor_all_angles.append([])
            for j in range(0,len(central_atoms_angles[i])):
                n = 1
                m = 1
                angles_around = 0 
                additional_contributions = 0 
                scaling_factor_all_angles[i].append([0,0]) 
                # Position in angle list
                scaling_factor_all_angles[i][j][1] =  central_atoms_angles[i][j][2] 
                # Goes through the list of angles with the same central atom and computes the term need for the modified Seminario method    
                # Forwards directions, finds the same bonds with the central atom i  
                while( ( (j + n ) &lt; len(central_atoms_angles[i]) ) and central_atoms_angles[i][j][0] == central_atoms_angles[i][j+n][0] ):
                    additional_contributions = additional_contributions + (abs(np.dot(unit_PA_all_angles[i][j][:], unit_PA_all_angles[i][j + n][:])))**2 
                    n = n + 1
                    angles_around = angles_around + 1
                 # Backwards direction, finds the same bonds with the central atom i   
                while( ( (j - m ) &gt;= 0 ) and central_atoms_angles[i][j][0] == central_atoms_angles[i][j-m][0] ):
                    additional_contributions = additional_contributions + (abs(np.dot(unit_PA_all_angles[i][j][:], unit_PA_all_angles[i][j - m][:] ) ) )**2
                    m = m + 1
                    angles_around =  angles_around + 1
                if (n != 1 or m != 1):
                    # Finds the mean value of the additional contribution to change to normal Seminario method comment out + part 
                    scaling_factor_all_angles[i][j][0] = 1 + ( additional_contributions / (m  + n - 2) )  
                else:
                    scaling_factor_all_angles[i][j][0] = 1
        scaling_factors_angles_list = []
        for i in range(0,len(angle_list) ):
            scaling_factors_angles_list.append([]) 
        # Orders the scaling factors according to the angle list
        for i in range(0,len(central_atoms_angles)):
            for j in range(0,len(central_atoms_angles[i]) ):
                scaling_factors_angles_list[scaling_factor_all_angles[i][j][1]].append(scaling_factor_all_angles[i][j][0]) 
        # Finds the angle force constants with the scaling factors included for each angle
        for i in range(0,len(angle_list) ):
            # Ensures that there is no difference when the ordering is changed 
            [AB_k_theta, AB_theta_0] = force_angle_constant( angle_list[i][0], angle_list[i][1], angle_list[i][2], bond_lengths, eigenvalues, eigenvectors, coords, scaling_factors_angles_list[i][0], scaling_factors_angles_list[i][1] ) 
            [BA_k_theta, BA_theta_0] = force_angle_constant( angle_list[i][2], angle_list[i][1], angle_list[i][0], bond_lengths, eigenvalues, eigenvectors, coords, scaling_factors_angles_list[i][1], scaling_factors_angles_list[i][0] ) 
            k_theta[i] = (AB_k_theta + BA_k_theta ) / 2
            theta_0[i] = (AB_theta_0 +  BA_theta_0 ) / 2
            # Vibrational_scaling takes into account DFT deficities/ anharmonicity 
            k_theta[i] =  k_theta[i] * vibrational_scaling_squared
            file_angle.write(atom_names[angle_list[i][0]] + &#39;-&#39; + atom_names[angle_list[i][1] ] + &#39;-&#39; + atom_names[angle_list[i][2]] + &#39;  &#39; )
            file_angle.write(str(&#34;%#.4g&#34; % k_theta[i]) + &#39;   &#39; + str(&#34;%#.4g&#34; % theta_0[i]) + &#39;   &#39; + str(angle_list[i][0] + 1)  + &#39;   &#39; + str(angle_list[i][1] + 1) + &#39;   &#39; + str(angle_list[i][2] + 1))
            file_angle.write(&#39;\n&#39;)
            unique_values_angles.append([atom_names[angle_list[i][0]], atom_names[angle_list[i][1]], atom_names[angle_list[i][2]], k_theta[i], theta_0[i], 1 ])
        file_angle.close()
        
    def get_charges(self):
        &#34;&#34;&#34;
        This function saves the charges in a text file obtained from the Gaussian log file. 
        &#34;&#34;&#34;
        log_file = self.guest_pdb[:-4] + &#34;.log&#34;
        with open (log_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Fitting point charges to electrostatic potential&#34; in lines[i]:
                to_begin = int(i)   
            if &#34; Sum of ESP charges =&#34; in lines[i]:
                to_end = int(i)  
        charges = lines[to_begin + 4: to_end]
        charge_list = []
        for i in range(len(charges)):
            charge_list.append(charges[i].strip().split())
        charge_list_value = []
        atom_list = []
        for i in range(len(charge_list)):
            charge_list_value.append(charge_list[i][2])
            atom_list.append(charge_list[i][1])
        data_tuples = list(zip(atom_list,charge_list_value))
        df_charge = pd.DataFrame(data_tuples, columns=[&#39;Atom&#39;,&#39;Charge&#39;])
        df_charge.to_csv (self.charge_parameter_file, index = False, header = False, sep = &#39; &#39;)
        
    def get_proper_dihedrals(self):
        &#34;&#34;&#34;
        This function saves proper dihedral angles of the guest molecule in a text file.
        &#34;&#34;&#34;
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_pdb)
        no_atoms = len(ppdb.df[&#34;ATOM&#34;])
        atom_index_list = []
        for i in range(no_atoms):
            atom_index_list.append(i+1)
        possible_dihedrals = []
        for dihed in itertools.permutations(atom_index_list, 4):
            possible_dihedrals.append(dihed)
        df_bonds = pd.read_csv(self.bond_parameter_file, header = None, delimiter = r&#34;\s+&#34;)
        df_bonds.columns = [&#34;bond&#34;, &#34;k_bond&#34;, &#34;bond_length&#34;, &#34;bond_1&#34;, &#34;bond_2&#34;]
        bond1 = df_bonds[&#34;bond_1&#34;].values.tolist()
        bond2 = df_bonds[&#34;bond_2&#34;].values.tolist()
        bond_list_list = []
        for i in range(len(bond1)):
            args = (bond1[i],bond2[i])
            bond_list_list.append(list(args))   
        reverse_bond_list_list = []
        for bonds in bond_list_list:
            reverse_bond_list_list.append(reverse_list(bonds))
        bond_lists = bond_list_list + reverse_bond_list_list
        proper_dihed_repeated  = []
        for i in range(len(possible_dihedrals)):
            dihed_frag = [possible_dihedrals[i][0],possible_dihedrals[i][1]], [possible_dihedrals[i][1],possible_dihedrals[i][2]], [possible_dihedrals[i][2],possible_dihedrals[i][3]]
            a = [dihed_frag[0] in bond_lists,dihed_frag[1] in bond_lists,dihed_frag[2] in bond_lists]
            if a == [True, True, True] :
                proper_dihed_repeated.append(possible_dihedrals[i])
        
        len_repeated_dihed_list = len(proper_dihed_repeated)
        proper_dihedrals = proper_dihed_repeated
        for x in proper_dihedrals:
            z = x[::-1]
            if z in proper_dihedrals:
                proper_dihedrals.remove(z)
        len_non_repeated_dihed_list = len(proper_dihedrals)
        #print(len_repeated_dihed_list == len_non_repeated_dihed_list * 2)  
        np.savetxt(self.proper_dihedral_file, proper_dihedrals, fmt=&#39;%s&#39;)
        #return(proper_dihedrals)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.ParameterizeGuest.get_atom_names"><code class="name flex">
<span>def <span class="ident">get_atom_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves a list of atom names from the formatted checkpoint file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_atom_names(self):
    &#34;&#34;&#34;
    This function saves a list of atom names from the formatted checkpoint file.
    &#34;&#34;&#34;
    fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
    with open (fchk_file, &#34;r&#34;) as f:
        lines = f.readlines()    
    for i in range(len(lines)):
        if &#34;Atomic numbers&#34; in lines[i]:
            to_begin = int(i) 
        if &#34;Nuclear charges&#34; in lines[i]:
            to_end = int(i) 
    atomic_numbers = lines[to_begin + 1:to_end]
    atom_numbers = []
    for i in range(len(atomic_numbers)):
        atom_numbers.append(atomic_numbers[i].strip().split())
    numbers = [item for sublist in atom_numbers for item in sublist]
    names = []   
    # Gives name for atomic number
    for x in range(0,len(numbers)):
        names.append(element_list[int(numbers[x]) - 1][1]) 
    atom_names = []
    for i in range(0,len(names)):
        atom_names.append(names[i].strip() + str(i + 1))
    np.savetxt(self.atom_names_file, atom_names, fmt =&#39;%s&#39;)</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeGuest.get_bond_angle_params"><code class="name flex">
<span>def <span class="ident">get_bond_angle_params</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves the bond and angle parameter files obtained from the formatted checkpoint file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bond_angle_params(self):  
    &#34;&#34;&#34;
    This function saves the bond and angle parameter files obtained from the formatted checkpoint file. 
    &#34;&#34;&#34;
    fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
    with open (fchk_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Current cartesian coordinates&#34; in lines[i]:
            no_coordinates = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
            no_coordinates = int(no_coordinates[0])    
    N = int(no_coordinates/3)
    coords = np.loadtxt(self.coordinate_file)
    hessian = np.loadtxt(self.hessian_file)
    bond_list = np.loadtxt(self.bond_list_file, dtype = int)
    atom_names = np.loadtxt(self.atom_names_file, dtype = str) 
    # Find bond lengths
    bond_lengths = np.zeros((N, N))
    for i in range (0,N):
        for j in range(0,N):
            diff_i_j = np.array(coords[i,:]) - np.array(coords[j,:])
            bond_lengths[i][j] =  np.linalg.norm(diff_i_j)
    eigenvectors = np.empty((3, 3, N, N), dtype=complex)
    eigenvalues = np.empty((N, N, 3), dtype=complex)
    partial_hessian = np.zeros((3, 3))
    for i in range(0,N):
        for j in range(0,N):
            partial_hessian = hessian[(i * 3):((i + 1)*3),(j * 3):((j + 1)*3)]
            [a, b] = np.linalg.eig(partial_hessian)
            eigenvalues[i,j,:] = (a)
            eigenvectors[:,:,i,j] = (b)
    # Modified Seminario method to find the bond parameters and print them to file
    file_bond = open(self.bond_parameter_file, &#39;w&#39;)
    k_b = np.zeros(len(bond_list))
    bond_length_list = np.zeros(len(bond_list))
    unique_values_bonds = [] # Used to find average values 
    for i in range(0, len(bond_list)):
        AB = force_constant_bond(bond_list[i][0], bond_list[i][1],eigenvalues, eigenvectors, coords)
        BA = force_constant_bond(bond_list[i][1], bond_list[i][0],eigenvalues, eigenvectors, coords)
        # Order of bonds sometimes causes slight differences, find the mean
        k_b[i] = np.real(( AB + BA ) /2); 
        # Vibrational_scaling takes into account DFT deficities/ anharmocity   
        vibrational_scaling_squared = self.vibrational_scaling**2        
        k_b[i] = k_b[i] * vibrational_scaling_squared
        bond_length_list[i] =  bond_lengths[bond_list[i][0]][bond_list[i][1]]
        file_bond.write(atom_names[bond_list[i][0]] + &#39;-&#39; + atom_names[bond_list[i][1]] + &#39;  &#39;)
        file_bond.write(str(&#34;%#.5g&#34; % k_b[i])+ &#39;   &#39; + str(&#34;%#.4g&#34; % bond_length_list[i]) +  &#39;   &#39; + str(bond_list[i][0] + 1) +  &#39;   &#39; + str(bond_list[i][1] + 1))
        file_bond.write(&#39;\n&#39;)
        unique_values_bonds.append([atom_names[bond_list[i][0]], atom_names[bond_list[i][1]], k_b[i], bond_length_list[i], 1 ])
    file_bond.close()
    angle_list = np.loadtxt(self.angle_list_file, dtype = int)
    # Modified Seminario method to find the angle parameters and print them to file
    file_angle = open(self.angle_parameter_file, &#39;w&#39;)
    k_theta = np.zeros(len(angle_list))
    theta_0 = np.zeros(len(angle_list))
    unique_values_angles = [] # Used to find average values
    # Modified Seminario part goes here ...
    # Connectivity information for Modified Seminario Method
    central_atoms_angles = []
    # A structure is created with the index giving the central atom of the angle, an array then lists the angles with that central atom. 
    # i.e. central_atoms_angles{3} contains an array of angles with central atom 3
    for i in range(0, len(coords)):
        central_atoms_angles.append([])
        for j in range(0, len(angle_list)):
            if i == angle_list[j][1]:
                # For angle ABC, atoms A C are written to array
                AC_array = [angle_list[j][0],  angle_list[j][2], j]
                central_atoms_angles[i].append(AC_array)
                # For angle ABC, atoms C A are written to array
                CA_array = [angle_list[j][2],  angle_list[j][0], j]
                central_atoms_angles[i].append(CA_array)
    # Sort rows by atom number
    for i in range(0, len(coords)):
        central_atoms_angles[i] = sorted(central_atoms_angles[i], key=itemgetter(0))
    # Find normals u_PA for each angle
    unit_PA_all_angles = []
    for i in range(0,len(central_atoms_angles)):
        unit_PA_all_angles.append([])
        for j in range(0, len(central_atoms_angles[i])):
            # For the angle at central_atoms_angles[i][j,:] the corresponding u_PA value is found for the plane ABC and bond AB, where ABC corresponds to the order of the arguements. This is why the reverse order was also added
            unit_PA_all_angles[i].append(u_PA_from_angles(central_atoms_angles[i][j][0], i, central_atoms_angles[i][j][1], coords))
    # Finds the contributing factors from the other angle terms scaling_factor_all_angles = cell(max(max(angle_list))); %This array will contain scaling factor and angle list position
    scaling_factor_all_angles = []
    for i in range(0,len(central_atoms_angles)):
        scaling_factor_all_angles.append([])
        for j in range(0,len(central_atoms_angles[i])):
            n = 1
            m = 1
            angles_around = 0 
            additional_contributions = 0 
            scaling_factor_all_angles[i].append([0,0]) 
            # Position in angle list
            scaling_factor_all_angles[i][j][1] =  central_atoms_angles[i][j][2] 
            # Goes through the list of angles with the same central atom and computes the term need for the modified Seminario method    
            # Forwards directions, finds the same bonds with the central atom i  
            while( ( (j + n ) &lt; len(central_atoms_angles[i]) ) and central_atoms_angles[i][j][0] == central_atoms_angles[i][j+n][0] ):
                additional_contributions = additional_contributions + (abs(np.dot(unit_PA_all_angles[i][j][:], unit_PA_all_angles[i][j + n][:])))**2 
                n = n + 1
                angles_around = angles_around + 1
             # Backwards direction, finds the same bonds with the central atom i   
            while( ( (j - m ) &gt;= 0 ) and central_atoms_angles[i][j][0] == central_atoms_angles[i][j-m][0] ):
                additional_contributions = additional_contributions + (abs(np.dot(unit_PA_all_angles[i][j][:], unit_PA_all_angles[i][j - m][:] ) ) )**2
                m = m + 1
                angles_around =  angles_around + 1
            if (n != 1 or m != 1):
                # Finds the mean value of the additional contribution to change to normal Seminario method comment out + part 
                scaling_factor_all_angles[i][j][0] = 1 + ( additional_contributions / (m  + n - 2) )  
            else:
                scaling_factor_all_angles[i][j][0] = 1
    scaling_factors_angles_list = []
    for i in range(0,len(angle_list) ):
        scaling_factors_angles_list.append([]) 
    # Orders the scaling factors according to the angle list
    for i in range(0,len(central_atoms_angles)):
        for j in range(0,len(central_atoms_angles[i]) ):
            scaling_factors_angles_list[scaling_factor_all_angles[i][j][1]].append(scaling_factor_all_angles[i][j][0]) 
    # Finds the angle force constants with the scaling factors included for each angle
    for i in range(0,len(angle_list) ):
        # Ensures that there is no difference when the ordering is changed 
        [AB_k_theta, AB_theta_0] = force_angle_constant( angle_list[i][0], angle_list[i][1], angle_list[i][2], bond_lengths, eigenvalues, eigenvectors, coords, scaling_factors_angles_list[i][0], scaling_factors_angles_list[i][1] ) 
        [BA_k_theta, BA_theta_0] = force_angle_constant( angle_list[i][2], angle_list[i][1], angle_list[i][0], bond_lengths, eigenvalues, eigenvectors, coords, scaling_factors_angles_list[i][1], scaling_factors_angles_list[i][0] ) 
        k_theta[i] = (AB_k_theta + BA_k_theta ) / 2
        theta_0[i] = (AB_theta_0 +  BA_theta_0 ) / 2
        # Vibrational_scaling takes into account DFT deficities/ anharmonicity 
        k_theta[i] =  k_theta[i] * vibrational_scaling_squared
        file_angle.write(atom_names[angle_list[i][0]] + &#39;-&#39; + atom_names[angle_list[i][1] ] + &#39;-&#39; + atom_names[angle_list[i][2]] + &#39;  &#39; )
        file_angle.write(str(&#34;%#.4g&#34; % k_theta[i]) + &#39;   &#39; + str(&#34;%#.4g&#34; % theta_0[i]) + &#39;   &#39; + str(angle_list[i][0] + 1)  + &#39;   &#39; + str(angle_list[i][1] + 1) + &#39;   &#39; + str(angle_list[i][2] + 1))
        file_angle.write(&#39;\n&#39;)
        unique_values_angles.append([atom_names[angle_list[i][0]], atom_names[angle_list[i][1]], atom_names[angle_list[i][2]], k_theta[i], theta_0[i], 1 ])
    file_angle.close()</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeGuest.get_bond_angles"><code class="name flex">
<span>def <span class="ident">get_bond_angles</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves a text file of the bonds and angles from the gaussian log file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bond_angles(self):   
    &#34;&#34;&#34;
    This function saves a text file of the bonds and angles from the gaussian log file.
    &#34;&#34;&#34; 
    log_file = self.guest_pdb[:-4] + &#34;.log&#34;
    fid = open(log_file, &#34;r&#34;)
    tline = fid.readline()
    bond_list = []
    angle_list = []
    n = 1
    n_bond = 1
    n_angle = 1
    tmp = &#39;R&#39; # States if bond or angle
    B = []
    # Finds the bond and angles from the .log file
    while tline:
        tline = fid.readline()
        # Line starts at point when bond and angle list occurs
        if len(tline) &gt; 80 and tline[0:81].strip() == &#39;! Name  Definition              Value          Derivative Info.                !&#39;:
            tline = fid.readline()
            tline = fid.readline()
            # Stops when all bond and angles recorded 
            while ( ( tmp[0] == &#39;R&#39; ) or (tmp[0] == &#39;A&#39;) ):
                line = tline.split()
                tmp = line[1]
                # Bond or angles listed as string
                list_terms = line[2][2:-1]
                # Bond List 
                if ( tmp[0] == &#39;R&#39; ): 
                    x = list_terms.split(&#39;,&#39;)
                    # Subtraction due to python array indexing at 0
                    x = [(int(i) - 1 ) for i in x]
                    bond_list.append(x)
                    # Angle List 
                if (tmp[0] == &#39;A&#39; ): 
                    x = list_terms.split(&#39;,&#39;)
                    # Subtraction due to python array indexing at 0
                    x = [(int(i) - 1 ) for i in x]
                    angle_list.append(x)
                tline = fid.readline()
            # Leave loop
            tline = -1
    np.savetxt(self.bond_list_file, bond_list, fmt=&#39;%s&#39;)
    np.savetxt(self.angle_list_file, angle_list, fmt=&#39;%s&#39;)</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeGuest.get_charges"><code class="name flex">
<span>def <span class="ident">get_charges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves the charges in a text file obtained from the Gaussian log file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_charges(self):
    &#34;&#34;&#34;
    This function saves the charges in a text file obtained from the Gaussian log file. 
    &#34;&#34;&#34;
    log_file = self.guest_pdb[:-4] + &#34;.log&#34;
    with open (log_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Fitting point charges to electrostatic potential&#34; in lines[i]:
            to_begin = int(i)   
        if &#34; Sum of ESP charges =&#34; in lines[i]:
            to_end = int(i)  
    charges = lines[to_begin + 4: to_end]
    charge_list = []
    for i in range(len(charges)):
        charge_list.append(charges[i].strip().split())
    charge_list_value = []
    atom_list = []
    for i in range(len(charge_list)):
        charge_list_value.append(charge_list[i][2])
        atom_list.append(charge_list[i][1])
    data_tuples = list(zip(atom_list,charge_list_value))
    df_charge = pd.DataFrame(data_tuples, columns=[&#39;Atom&#39;,&#39;Charge&#39;])
    df_charge.to_csv (self.charge_parameter_file, index = False, header = False, sep = &#39; &#39;)</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeGuest.get_hessian"><code class="name flex">
<span>def <span class="ident">get_hessian</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function extracts hessian from the unprocessed hessian and saves into a new file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hessian(self):
    &#34;&#34;&#34;
    This function extracts hessian from the unprocessed hessian and saves into a new file.
    &#34;&#34;&#34;       
    unprocessed_Hessian = np.loadtxt(self.unprocessed_hessian_file) 
    fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;     
    with open (fchk_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Current cartesian coordinates&#34; in lines[i]:
            no_coordinates = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
            no_coordinates = int(no_coordinates[0])
    N = int(no_coordinates/3)    
    length_hessian = 3 * N
    hessian = np.zeros((length_hessian, length_hessian))
    m = 0
    # Write the hessian in a 2D array format 
    for i in range (0,(length_hessian)):
        for j in range (0,(i + 1)):
            hessian[i][j] = unprocessed_Hessian[m]
            hessian[j][i] = unprocessed_Hessian[m]
            m = m + 1
    hessian = (hessian * (627.509391))/ (0.529**2)  # Change from Hartree/bohr to kcal/mol/ang
    np.savetxt(self.hessian_file, hessian, fmt=&#39;%s&#39;)</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeGuest.get_proper_dihedrals"><code class="name flex">
<span>def <span class="ident">get_proper_dihedrals</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves proper dihedral angles of the guest molecule in a text file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_proper_dihedrals(self):
    &#34;&#34;&#34;
    This function saves proper dihedral angles of the guest molecule in a text file.
    &#34;&#34;&#34;
    ppdb = PandasPdb()
    ppdb.read_pdb(self.guest_pdb)
    no_atoms = len(ppdb.df[&#34;ATOM&#34;])
    atom_index_list = []
    for i in range(no_atoms):
        atom_index_list.append(i+1)
    possible_dihedrals = []
    for dihed in itertools.permutations(atom_index_list, 4):
        possible_dihedrals.append(dihed)
    df_bonds = pd.read_csv(self.bond_parameter_file, header = None, delimiter = r&#34;\s+&#34;)
    df_bonds.columns = [&#34;bond&#34;, &#34;k_bond&#34;, &#34;bond_length&#34;, &#34;bond_1&#34;, &#34;bond_2&#34;]
    bond1 = df_bonds[&#34;bond_1&#34;].values.tolist()
    bond2 = df_bonds[&#34;bond_2&#34;].values.tolist()
    bond_list_list = []
    for i in range(len(bond1)):
        args = (bond1[i],bond2[i])
        bond_list_list.append(list(args))   
    reverse_bond_list_list = []
    for bonds in bond_list_list:
        reverse_bond_list_list.append(reverse_list(bonds))
    bond_lists = bond_list_list + reverse_bond_list_list
    proper_dihed_repeated  = []
    for i in range(len(possible_dihedrals)):
        dihed_frag = [possible_dihedrals[i][0],possible_dihedrals[i][1]], [possible_dihedrals[i][1],possible_dihedrals[i][2]], [possible_dihedrals[i][2],possible_dihedrals[i][3]]
        a = [dihed_frag[0] in bond_lists,dihed_frag[1] in bond_lists,dihed_frag[2] in bond_lists]
        if a == [True, True, True] :
            proper_dihed_repeated.append(possible_dihedrals[i])
    
    len_repeated_dihed_list = len(proper_dihed_repeated)
    proper_dihedrals = proper_dihed_repeated
    for x in proper_dihedrals:
        z = x[::-1]
        if z in proper_dihedrals:
            proper_dihedrals.remove(z)
    len_non_repeated_dihed_list = len(proper_dihedrals)
    #print(len_repeated_dihed_list == len_non_repeated_dihed_list * 2)  
    np.savetxt(self.proper_dihedral_file, proper_dihedrals, fmt=&#39;%s&#39;)
    #return(proper_dihedrals)</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeGuest.get_unprocessed_hessian"><code class="name flex">
<span>def <span class="ident">get_unprocessed_hessian</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves a text file of the unprocessed hessian from the formatted checkpoint file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_unprocessed_hessian(self):   
    &#34;&#34;&#34;
    This function saves a text file of the unprocessed hessian from the formatted checkpoint file.
    &#34;&#34;&#34;    
    fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
    with open (fchk_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Cartesian Force Constants&#34; in lines[i]:
            no_hessian = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
            no_hessian = int(no_hessian[0])
    for i in range(len(lines)):
        if &#34;Cartesian Force Constants&#34; in lines[i]:
            to_begin = int(i)     
    hessian = lines[to_begin + 1:to_begin + 1 + int(math.ceil(no_hessian/5))]
    hessian_list = []
    for i in range(len(hessian)):
        hessian_list.append(hessian[i].strip().split())
    unprocessed_Hessian = [item for sublist in hessian_list for item in sublist]
    np.savetxt(self.unprocessed_hessian_file, unprocessed_Hessian, fmt=&#39;%s&#39;)</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeGuest.get_xyz"><code class="name flex">
<span>def <span class="ident">get_xyz</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves a xyz file from the formatted checkpoint file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_xyz(self):   
    &#34;&#34;&#34;
    This function saves a xyz file from the formatted checkpoint file.
    &#34;&#34;&#34;
    fchk_file = self.guest_pdb[:-4] + &#34;.fchk&#34;
    with open (fchk_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Current cartesian coordinates&#34; in lines[i]:
            no_coordinates = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
            no_coordinates = int(no_coordinates[0])
    for i in range(len(lines)):
        if &#34;Current cartesian coordinates&#34; in lines[i]:
            to_begin = int(i)     
    cartesian_coords = lines[to_begin + 1:to_begin + 1 + int(math.ceil(no_coordinates/5))]
    cartesian_list = []
    for i in range(len(cartesian_coords)):
        cartesian_list.append(cartesian_coords[i].strip().split())
    coordinates_list = [item for sublist in cartesian_list for item in sublist]
    list_coords = [float(x)*float(0.529) for x in coordinates_list]
    for i in range(len(lines)):
        if &#34;Atomic numbers&#34; in lines[i]:
            to_begin = int(i) 
        if &#34;Nuclear charges&#34; in lines[i]:
            to_end = int(i)    
    atomic_numbers = lines[to_begin + 1:to_end]
    atom_numbers = []
    for i in range(len(atomic_numbers)):
        atom_numbers.append(atomic_numbers[i].strip().split())
    numbers = [item for sublist in atom_numbers for item in sublist]
    N = int(no_coordinates/3)
    # Opens the new xyz file 
    file = open(self.xyz_file, &#34;w&#34;)
    file.write(str(N) + &#39;\n \n&#39;)
    coords = np.zeros((N,3))
    n = 0
    names = []   
    # Gives name for atomic number
    for x in range(0,len(numbers)):
        names.append(element_list[int(numbers[x]) - 1][1]) 
    # Print coordinates to new input_coords.xyz file
    for i in range(0, N):
        for j in range(0,3):
            coords[i][j] = list_coords[n]
            n = n + 1
        file.write(names[i] + str(round(coords[i][0],3)) + &#39; &#39; + str(round(coords[i][1],3)) + &#39; &#39; + str(round(coords[i][2], 3)) + &#39;\n&#39;)
    file.close()
    np.savetxt(self.coordinate_file, coords, fmt=&#39;%s&#39;)  </code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.ParameterizeHost"><code class="flex name class">
<span>class <span class="ident">ParameterizeHost</span></span>
<span>(</span><span>vibrational_scaling, xyz_file='host_qm_coords.xyz', coordinate_file='host_qm_coordinates.txt', unprocessed_hessian_file='host_qm_unprocessed_hessian.txt', bond_list_file='host_qm_bond_list.txt', angle_list_file='host_qm_angle_list.txt', hessian_file='host_qm_hessian.txt', atom_names_file='host_qm_atom_names.txt', bond_parameter_file='host_qm_bonds.txt', angle_parameter_file='host_qm_angles.txt', charge_parameter_file='host_qm_surround_charges.txt', host_qm_pdb='host_qm.pdb')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterizeHost:

    def __init__(self, vibrational_scaling, xyz_file = &#34;host_qm_coords.xyz&#34;, coordinate_file = &#34;host_qm_coordinates.txt&#34;, unprocessed_hessian_file = &#34;host_qm_unprocessed_hessian.txt&#34;, bond_list_file = &#34;host_qm_bond_list.txt&#34;, angle_list_file = &#34;host_qm_angle_list.txt&#34;, hessian_file = &#34;host_qm_hessian.txt&#34;, atom_names_file = &#34;host_qm_atom_names.txt&#34;, bond_parameter_file = &#34;host_qm_bonds.txt&#34;, angle_parameter_file = &#34;host_qm_angles.txt&#34;, charge_parameter_file = &#34;host_qm_surround_charges.txt&#34;, host_qm_pdb = &#34;host_qm.pdb&#34;):
        self.vibrational_scaling = vibrational_scaling
        self.xyz_file = xyz_file
        self.coordinate_file = coordinate_file
        self.unprocessed_hessian_file = unprocessed_hessian_file
        self.bond_list_file = bond_list_file
        self.angle_list_file = angle_list_file
        self.hessian_file = hessian_file
        self.atom_names_file = atom_names_file
        self.bond_parameter_file = bond_parameter_file
        self.angle_parameter_file = angle_parameter_file
        self.charge_parameter_file = charge_parameter_file
        self.host_qm_pdb = host_qm_pdb

    def get_xyz(self):   
        &#34;&#34;&#34;
        This function saves a xyz file from the formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
        with open (fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
                no_coordinates = int(no_coordinates[0])
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                to_begin = int(i)     
        cartesian_coords = lines[to_begin + 1:to_begin + 1 + int(math.ceil(no_coordinates/5))]
        cartesian_list = []
        for i in range(len(cartesian_coords)):
            cartesian_list.append(cartesian_coords[i].strip().split())
        coordinates_list = [item for sublist in cartesian_list for item in sublist]
        list_coords = [float(x)*float(0.529) for x in coordinates_list]
        for i in range(len(lines)):
            if &#34;Atomic numbers&#34; in lines[i]:
                to_begin = int(i) 
            if &#34;Nuclear charges&#34; in lines[i]:
                to_end = int(i)    
        atomic_numbers = lines[to_begin + 1:to_end]
        atom_numbers = []
        for i in range(len(atomic_numbers)):
            atom_numbers.append(atomic_numbers[i].strip().split())
        numbers = [item for sublist in atom_numbers for item in sublist]
        N = int(no_coordinates/3)
        # Opens the new xyz file 
        file = open(self.xyz_file, &#34;w&#34;)
        file.write(str(N) + &#39;\n \n&#39;)
        coords = np.zeros((N,3))
        n = 0
        names = []   
        # Gives name for atomic number
        for x in range(0,len(numbers)):
            names.append(element_list[int(numbers[x]) - 1][1]) 
        # Print coordinates to new input_coords.xyz file
        for i in range(0, N):
            for j in range(0,3):
                coords[i][j] = list_coords[n]
                n = n + 1
            file.write(names[i] + str(round(coords[i][0],3)) + &#39; &#39; + str(round(coords[i][1],3)) + &#39; &#39; + str(round(coords[i][2], 3)) + &#39;\n&#39;)
        file.close()
        np.savetxt(self.coordinate_file, coords, fmt=&#39;%s&#39;)  
        
    def get_unprocessed_hessian(self):   
        &#34;&#34;&#34;
        This function saves a text file of the unprocessed hessian from the formatted checkpoint file.
        &#34;&#34;&#34;    
        fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
        with open (fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Cartesian Force Constants&#34; in lines[i]:
                no_hessian = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
                no_hessian = int(no_hessian[0])
        for i in range(len(lines)):
            if &#34;Cartesian Force Constants&#34; in lines[i]:
                to_begin = int(i)     
        hessian = lines[to_begin + 1:to_begin + 1 + int(math.ceil(no_hessian/5))]
        hessian_list = []
        for i in range(len(hessian)):
            hessian_list.append(hessian[i].strip().split())
        unprocessed_Hessian = [item for sublist in hessian_list for item in sublist]
        np.savetxt(self.unprocessed_hessian_file, unprocessed_Hessian, fmt=&#39;%s&#39;)
        
    def get_bond_angles(self):   
        &#34;&#34;&#34;
        This function saves a text file of the bonds and angles from the gaussian log file.
        &#34;&#34;&#34; 
        log_file = self.host_qm_pdb[:-4] + &#34;.log&#34;
        fid = open(log_file, &#34;r&#34;)
        tline = fid.readline()
        bond_list = []
        angle_list = []
        n = 1
        n_bond = 1
        n_angle = 1
        tmp = &#39;R&#39; # States if bond or angle
        B = []
        # Finds the bond and angles from the .log file
        while tline:
            tline = fid.readline()
            # Line starts at point when bond and angle list occurs
            if len(tline) &gt; 80 and tline[0:81].strip() == &#39;! Name  Definition              Value          Derivative Info.                !&#39;:
                tline = fid.readline()
                tline = fid.readline()
                # Stops when all bond and angles recorded 
                while ( ( tmp[0] == &#39;R&#39; ) or (tmp[0] == &#39;A&#39;) ):
                    line = tline.split()
                    tmp = line[1]
                    # Bond or angles listed as string
                    list_terms = line[2][2:-1]
                    # Bond List 
                    if ( tmp[0] == &#39;R&#39; ): 
                        x = list_terms.split(&#39;,&#39;)
                        # Subtraction due to python array indexing at 0
                        x = [(int(i) - 1 ) for i in x]
                        bond_list.append(x)
                        # Angle List 
                    if (tmp[0] == &#39;A&#39; ): 
                        x = list_terms.split(&#39;,&#39;)
                        # Subtraction due to python array indexing at 0
                        x = [(int(i) - 1 ) for i in x]
                        angle_list.append(x)
                    tline = fid.readline()
                # Leave loop
                tline = -1
        np.savetxt(self.bond_list_file, bond_list, fmt=&#39;%s&#39;)
        np.savetxt(self.angle_list_file, angle_list, fmt=&#39;%s&#39;)
        
    def get_hessian(self):
        &#34;&#34;&#34;
        This function extracts hessian from the unprocessed hessian and saves into a new file.
        &#34;&#34;&#34;       
        unprocessed_Hessian = np.loadtxt(self.unprocessed_hessian_file) 
        fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;     
        with open (fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
                no_coordinates = int(no_coordinates[0])
        N = int(no_coordinates/3)    
        length_hessian = 3 * N
        hessian = np.zeros((length_hessian, length_hessian))
        m = 0
        # Write the hessian in a 2D array format 
        for i in range (0,(length_hessian)):
            for j in range (0,(i + 1)):
                hessian[i][j] = unprocessed_Hessian[m]
                hessian[j][i] = unprocessed_Hessian[m]
                m = m + 1
        hessian = (hessian * (627.509391))/ (0.529**2)  # Change from Hartree/bohr to kcal/mol/ang
        np.savetxt(self.hessian_file, hessian, fmt=&#39;%s&#39;)

    def get_atom_names(self):
        &#34;&#34;&#34;
        This function saves a list of atom names from the formatted checkpoint file.
        &#34;&#34;&#34;
        fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
        with open (fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()    
        for i in range(len(lines)):
            if &#34;Atomic numbers&#34; in lines[i]:
                to_begin = int(i) 
            if &#34;Nuclear charges&#34; in lines[i]:
                to_end = int(i) 
        atomic_numbers = lines[to_begin + 1:to_end]
        atom_numbers = []
        for i in range(len(atomic_numbers)):
            atom_numbers.append(atomic_numbers[i].strip().split())
        numbers = [item for sublist in atom_numbers for item in sublist]
        names = []   
        # Gives name for atomic number
        for x in range(0,len(numbers)):
            names.append(element_list[int(numbers[x]) - 1][1]) 
        atom_names = []
        for i in range(0,len(names)):
            atom_names.append(names[i].strip() + str(i + 1))
        np.savetxt(self.atom_names_file, atom_names, fmt =&#39;%s&#39;)
        
    def get_bond_angle_params(self):  
        &#34;&#34;&#34;
        This function saves the bond and angle parameter files obtained from the formatted checkpoint file. 
        &#34;&#34;&#34;
        fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
        with open (fchk_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Current cartesian coordinates&#34; in lines[i]:
                no_coordinates = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
                no_coordinates = int(no_coordinates[0])    
        N = int(no_coordinates/3)
        coords = np.loadtxt(self.coordinate_file)
        hessian = np.loadtxt(self.hessian_file)
        bond_list = np.loadtxt(self.bond_list_file, dtype = int)
        atom_names = np.loadtxt(self.atom_names_file, dtype = str) 
        # Find bond lengths
        bond_lengths = np.zeros((N, N))
        for i in range (0,N):
            for j in range(0,N):
                diff_i_j = np.array(coords[i,:]) - np.array(coords[j,:])
                bond_lengths[i][j] =  np.linalg.norm(diff_i_j)
        eigenvectors = np.empty((3, 3, N, N), dtype=complex)
        eigenvalues = np.empty((N, N, 3), dtype=complex)
        partial_hessian = np.zeros((3, 3))
        for i in range(0,N):
            for j in range(0,N):
                partial_hessian = hessian[(i * 3):((i + 1)*3),(j * 3):((j + 1)*3)]
                [a, b] = np.linalg.eig(partial_hessian)
                eigenvalues[i,j,:] = (a)
                eigenvectors[:,:,i,j] = (b)
        # Modified Seminario method to find the bond parameters and print them to file
        file_bond = open(self.bond_parameter_file, &#39;w&#39;)
        k_b = np.zeros(len(bond_list))
        bond_length_list = np.zeros(len(bond_list))
        unique_values_bonds = [] # Used to find average values 
        for i in range(0, len(bond_list)):
            AB = force_constant_bond(bond_list[i][0], bond_list[i][1],eigenvalues, eigenvectors, coords)
            BA = force_constant_bond(bond_list[i][1], bond_list[i][0],eigenvalues, eigenvectors, coords)
            # Order of bonds sometimes causes slight differences, find the mean
            k_b[i] = np.real(( AB + BA ) /2); 
            # Vibrational_scaling takes into account DFT deficities/ anharmocity   
            vibrational_scaling_squared = self.vibrational_scaling**2        
            k_b[i] = k_b[i] * vibrational_scaling_squared
            bond_length_list[i] =  bond_lengths[bond_list[i][0]][bond_list[i][1]]
            file_bond.write(atom_names[bond_list[i][0]] + &#39;-&#39; + atom_names[bond_list[i][1]] + &#39;  &#39;)
            file_bond.write(str(&#34;%#.5g&#34; % k_b[i])+ &#39;   &#39; + str(&#34;%#.4g&#34; % bond_length_list[i]) +  &#39;   &#39; + str(bond_list[i][0] + 1) +  &#39;   &#39; + str(bond_list[i][1] + 1))
            file_bond.write(&#39;\n&#39;)
            unique_values_bonds.append([atom_names[bond_list[i][0]], atom_names[bond_list[i][1]], k_b[i], bond_length_list[i], 1 ])
        file_bond.close()
        angle_list = np.loadtxt(self.angle_list_file, dtype = int)
        # Modified Seminario method to find the angle parameters and print them to file
        file_angle = open(self.angle_parameter_file, &#39;w&#39;)
        k_theta = np.zeros(len(angle_list))
        theta_0 = np.zeros(len(angle_list))
        unique_values_angles = [] # Used to find average values
        # Modified Seminario part goes here ...
        # Connectivity information for Modified Seminario Method
        central_atoms_angles = []
        # A structure is created with the index giving the central atom of the angle, an array then lists the angles with that central atom. 
        # i.e. central_atoms_angles{3} contains an array of angles with central atom 3
        for i in range(0, len(coords)):
            central_atoms_angles.append([])
            for j in range(0, len(angle_list)):
                if i == angle_list[j][1]:
                    # For angle ABC, atoms A C are written to array
                    AC_array = [angle_list[j][0],  angle_list[j][2], j]
                    central_atoms_angles[i].append(AC_array)
                    # For angle ABC, atoms C A are written to array
                    CA_array = [angle_list[j][2],  angle_list[j][0], j]
                    central_atoms_angles[i].append(CA_array)
        # Sort rows by atom number
        for i in range(0, len(coords)):
            central_atoms_angles[i] = sorted(central_atoms_angles[i], key=itemgetter(0))
        # Find normals u_PA for each angle
        unit_PA_all_angles = []
        for i in range(0,len(central_atoms_angles)):
            unit_PA_all_angles.append([])
            for j in range(0, len(central_atoms_angles[i])):
                # For the angle at central_atoms_angles[i][j,:] the corresponding u_PA value is found for the plane ABC and bond AB, where ABC corresponds to the order of the arguements. This is why the reverse order was also added
                unit_PA_all_angles[i].append(u_PA_from_angles(central_atoms_angles[i][j][0], i, central_atoms_angles[i][j][1], coords))
        # Finds the contributing factors from the other angle terms scaling_factor_all_angles = cell(max(max(angle_list))); %This array will contain scaling factor and angle list position
        scaling_factor_all_angles = []
        for i in range(0,len(central_atoms_angles)):
            scaling_factor_all_angles.append([])
            for j in range(0,len(central_atoms_angles[i])):
                n = 1
                m = 1
                angles_around = 0 
                additional_contributions = 0 
                scaling_factor_all_angles[i].append([0,0]) 
                # Position in angle list
                scaling_factor_all_angles[i][j][1] =  central_atoms_angles[i][j][2] 
                # Goes through the list of angles with the same central atom and computes the term need for the modified Seminario method    
                # Forwards directions, finds the same bonds with the central atom i  
                while( ( (j + n ) &lt; len(central_atoms_angles[i]) ) and central_atoms_angles[i][j][0] == central_atoms_angles[i][j+n][0] ):
                    additional_contributions = additional_contributions + (abs(np.dot(unit_PA_all_angles[i][j][:], unit_PA_all_angles[i][j + n][:])))**2 
                    n = n + 1
                    angles_around = angles_around + 1
                 # Backwards direction, finds the same bonds with the central atom i   
                while( ( (j - m ) &gt;= 0 ) and central_atoms_angles[i][j][0] == central_atoms_angles[i][j-m][0] ):
                    additional_contributions = additional_contributions + (abs(np.dot(unit_PA_all_angles[i][j][:], unit_PA_all_angles[i][j - m][:] ) ) )**2
                    m = m + 1
                    angles_around =  angles_around + 1
                if (n != 1 or m != 1):
                    # Finds the mean value of the additional contribution to change to normal Seminario method comment out + part 
                    scaling_factor_all_angles[i][j][0] = 1 + ( additional_contributions / (m  + n - 2) )  
                else:
                    scaling_factor_all_angles[i][j][0] = 1
        scaling_factors_angles_list = []
        for i in range(0,len(angle_list) ):
            scaling_factors_angles_list.append([]) 
        # Orders the scaling factors according to the angle list
        for i in range(0,len(central_atoms_angles)):
            for j in range(0,len(central_atoms_angles[i]) ):
                scaling_factors_angles_list[scaling_factor_all_angles[i][j][1]].append(scaling_factor_all_angles[i][j][0]) 
        # Finds the angle force constants with the scaling factors included for each angle
        for i in range(0,len(angle_list) ):
            # Ensures that there is no difference when the ordering is changed 
            [AB_k_theta, AB_theta_0] = force_angle_constant( angle_list[i][0], angle_list[i][1], angle_list[i][2], bond_lengths, eigenvalues, eigenvectors, coords, scaling_factors_angles_list[i][0], scaling_factors_angles_list[i][1] ) 
            [BA_k_theta, BA_theta_0] = force_angle_constant( angle_list[i][2], angle_list[i][1], angle_list[i][0], bond_lengths, eigenvalues, eigenvectors, coords, scaling_factors_angles_list[i][1], scaling_factors_angles_list[i][0] ) 
            k_theta[i] = (AB_k_theta + BA_k_theta ) / 2
            theta_0[i] = (AB_theta_0 +  BA_theta_0 ) / 2
            # Vibrational_scaling takes into account DFT deficities/ anharmonicity 
            k_theta[i] =  k_theta[i] * vibrational_scaling_squared
            file_angle.write(atom_names[angle_list[i][0]] + &#39;-&#39; + atom_names[angle_list[i][1] ] + &#39;-&#39; + atom_names[angle_list[i][2]] + &#39;  &#39; )
            file_angle.write(str(&#34;%#.4g&#34; % k_theta[i]) + &#39;   &#39; + str(&#34;%#.4g&#34; % theta_0[i]) + &#39;   &#39; + str(angle_list[i][0] + 1)  + &#39;   &#39; + str(angle_list[i][1] + 1) + &#39;   &#39; + str(angle_list[i][2] + 1))
            file_angle.write(&#39;\n&#39;)
            unique_values_angles.append([atom_names[angle_list[i][0]], atom_names[angle_list[i][1]], atom_names[angle_list[i][2]], k_theta[i], theta_0[i], 1 ])
        file_angle.close()
        
    def get_charges(self):
        &#34;&#34;&#34;
        This function saves the charges in a text file obtained from the Gaussian log file. 
        &#34;&#34;&#34;
        log_file = self.host_qm_pdb[:-4] + &#34;.log&#34;
        with open (log_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Fitting point charges to electrostatic potential&#34; in lines[i]:
                to_begin = int(i)   
            if &#34; Sum of ESP charges =&#34; in lines[i]:
                to_end = int(i)  
        charges = lines[to_begin + 4: to_end]
        charge_list = []
        for i in range(len(charges)):
            charge_list.append(charges[i].strip().split())
        charge_list_value = []
        atom_list = []
        for i in range(len(charge_list)):
            charge_list_value.append(charge_list[i][2])
            atom_list.append(charge_list[i][1])
        data_tuples = list(zip(atom_list,charge_list_value))
        df_charge = pd.DataFrame(data_tuples, columns=[&#39;Atom&#39;,&#39;Charge&#39;])
        df_charge.to_csv (self.charge_parameter_file, index = False, header = False, sep = &#39; &#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.ParameterizeHost.get_atom_names"><code class="name flex">
<span>def <span class="ident">get_atom_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves a list of atom names from the formatted checkpoint file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_atom_names(self):
    &#34;&#34;&#34;
    This function saves a list of atom names from the formatted checkpoint file.
    &#34;&#34;&#34;
    fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
    with open (fchk_file, &#34;r&#34;) as f:
        lines = f.readlines()    
    for i in range(len(lines)):
        if &#34;Atomic numbers&#34; in lines[i]:
            to_begin = int(i) 
        if &#34;Nuclear charges&#34; in lines[i]:
            to_end = int(i) 
    atomic_numbers = lines[to_begin + 1:to_end]
    atom_numbers = []
    for i in range(len(atomic_numbers)):
        atom_numbers.append(atomic_numbers[i].strip().split())
    numbers = [item for sublist in atom_numbers for item in sublist]
    names = []   
    # Gives name for atomic number
    for x in range(0,len(numbers)):
        names.append(element_list[int(numbers[x]) - 1][1]) 
    atom_names = []
    for i in range(0,len(names)):
        atom_names.append(names[i].strip() + str(i + 1))
    np.savetxt(self.atom_names_file, atom_names, fmt =&#39;%s&#39;)</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeHost.get_bond_angle_params"><code class="name flex">
<span>def <span class="ident">get_bond_angle_params</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves the bond and angle parameter files obtained from the formatted checkpoint file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bond_angle_params(self):  
    &#34;&#34;&#34;
    This function saves the bond and angle parameter files obtained from the formatted checkpoint file. 
    &#34;&#34;&#34;
    fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
    with open (fchk_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Current cartesian coordinates&#34; in lines[i]:
            no_coordinates = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
            no_coordinates = int(no_coordinates[0])    
    N = int(no_coordinates/3)
    coords = np.loadtxt(self.coordinate_file)
    hessian = np.loadtxt(self.hessian_file)
    bond_list = np.loadtxt(self.bond_list_file, dtype = int)
    atom_names = np.loadtxt(self.atom_names_file, dtype = str) 
    # Find bond lengths
    bond_lengths = np.zeros((N, N))
    for i in range (0,N):
        for j in range(0,N):
            diff_i_j = np.array(coords[i,:]) - np.array(coords[j,:])
            bond_lengths[i][j] =  np.linalg.norm(diff_i_j)
    eigenvectors = np.empty((3, 3, N, N), dtype=complex)
    eigenvalues = np.empty((N, N, 3), dtype=complex)
    partial_hessian = np.zeros((3, 3))
    for i in range(0,N):
        for j in range(0,N):
            partial_hessian = hessian[(i * 3):((i + 1)*3),(j * 3):((j + 1)*3)]
            [a, b] = np.linalg.eig(partial_hessian)
            eigenvalues[i,j,:] = (a)
            eigenvectors[:,:,i,j] = (b)
    # Modified Seminario method to find the bond parameters and print them to file
    file_bond = open(self.bond_parameter_file, &#39;w&#39;)
    k_b = np.zeros(len(bond_list))
    bond_length_list = np.zeros(len(bond_list))
    unique_values_bonds = [] # Used to find average values 
    for i in range(0, len(bond_list)):
        AB = force_constant_bond(bond_list[i][0], bond_list[i][1],eigenvalues, eigenvectors, coords)
        BA = force_constant_bond(bond_list[i][1], bond_list[i][0],eigenvalues, eigenvectors, coords)
        # Order of bonds sometimes causes slight differences, find the mean
        k_b[i] = np.real(( AB + BA ) /2); 
        # Vibrational_scaling takes into account DFT deficities/ anharmocity   
        vibrational_scaling_squared = self.vibrational_scaling**2        
        k_b[i] = k_b[i] * vibrational_scaling_squared
        bond_length_list[i] =  bond_lengths[bond_list[i][0]][bond_list[i][1]]
        file_bond.write(atom_names[bond_list[i][0]] + &#39;-&#39; + atom_names[bond_list[i][1]] + &#39;  &#39;)
        file_bond.write(str(&#34;%#.5g&#34; % k_b[i])+ &#39;   &#39; + str(&#34;%#.4g&#34; % bond_length_list[i]) +  &#39;   &#39; + str(bond_list[i][0] + 1) +  &#39;   &#39; + str(bond_list[i][1] + 1))
        file_bond.write(&#39;\n&#39;)
        unique_values_bonds.append([atom_names[bond_list[i][0]], atom_names[bond_list[i][1]], k_b[i], bond_length_list[i], 1 ])
    file_bond.close()
    angle_list = np.loadtxt(self.angle_list_file, dtype = int)
    # Modified Seminario method to find the angle parameters and print them to file
    file_angle = open(self.angle_parameter_file, &#39;w&#39;)
    k_theta = np.zeros(len(angle_list))
    theta_0 = np.zeros(len(angle_list))
    unique_values_angles = [] # Used to find average values
    # Modified Seminario part goes here ...
    # Connectivity information for Modified Seminario Method
    central_atoms_angles = []
    # A structure is created with the index giving the central atom of the angle, an array then lists the angles with that central atom. 
    # i.e. central_atoms_angles{3} contains an array of angles with central atom 3
    for i in range(0, len(coords)):
        central_atoms_angles.append([])
        for j in range(0, len(angle_list)):
            if i == angle_list[j][1]:
                # For angle ABC, atoms A C are written to array
                AC_array = [angle_list[j][0],  angle_list[j][2], j]
                central_atoms_angles[i].append(AC_array)
                # For angle ABC, atoms C A are written to array
                CA_array = [angle_list[j][2],  angle_list[j][0], j]
                central_atoms_angles[i].append(CA_array)
    # Sort rows by atom number
    for i in range(0, len(coords)):
        central_atoms_angles[i] = sorted(central_atoms_angles[i], key=itemgetter(0))
    # Find normals u_PA for each angle
    unit_PA_all_angles = []
    for i in range(0,len(central_atoms_angles)):
        unit_PA_all_angles.append([])
        for j in range(0, len(central_atoms_angles[i])):
            # For the angle at central_atoms_angles[i][j,:] the corresponding u_PA value is found for the plane ABC and bond AB, where ABC corresponds to the order of the arguements. This is why the reverse order was also added
            unit_PA_all_angles[i].append(u_PA_from_angles(central_atoms_angles[i][j][0], i, central_atoms_angles[i][j][1], coords))
    # Finds the contributing factors from the other angle terms scaling_factor_all_angles = cell(max(max(angle_list))); %This array will contain scaling factor and angle list position
    scaling_factor_all_angles = []
    for i in range(0,len(central_atoms_angles)):
        scaling_factor_all_angles.append([])
        for j in range(0,len(central_atoms_angles[i])):
            n = 1
            m = 1
            angles_around = 0 
            additional_contributions = 0 
            scaling_factor_all_angles[i].append([0,0]) 
            # Position in angle list
            scaling_factor_all_angles[i][j][1] =  central_atoms_angles[i][j][2] 
            # Goes through the list of angles with the same central atom and computes the term need for the modified Seminario method    
            # Forwards directions, finds the same bonds with the central atom i  
            while( ( (j + n ) &lt; len(central_atoms_angles[i]) ) and central_atoms_angles[i][j][0] == central_atoms_angles[i][j+n][0] ):
                additional_contributions = additional_contributions + (abs(np.dot(unit_PA_all_angles[i][j][:], unit_PA_all_angles[i][j + n][:])))**2 
                n = n + 1
                angles_around = angles_around + 1
             # Backwards direction, finds the same bonds with the central atom i   
            while( ( (j - m ) &gt;= 0 ) and central_atoms_angles[i][j][0] == central_atoms_angles[i][j-m][0] ):
                additional_contributions = additional_contributions + (abs(np.dot(unit_PA_all_angles[i][j][:], unit_PA_all_angles[i][j - m][:] ) ) )**2
                m = m + 1
                angles_around =  angles_around + 1
            if (n != 1 or m != 1):
                # Finds the mean value of the additional contribution to change to normal Seminario method comment out + part 
                scaling_factor_all_angles[i][j][0] = 1 + ( additional_contributions / (m  + n - 2) )  
            else:
                scaling_factor_all_angles[i][j][0] = 1
    scaling_factors_angles_list = []
    for i in range(0,len(angle_list) ):
        scaling_factors_angles_list.append([]) 
    # Orders the scaling factors according to the angle list
    for i in range(0,len(central_atoms_angles)):
        for j in range(0,len(central_atoms_angles[i]) ):
            scaling_factors_angles_list[scaling_factor_all_angles[i][j][1]].append(scaling_factor_all_angles[i][j][0]) 
    # Finds the angle force constants with the scaling factors included for each angle
    for i in range(0,len(angle_list) ):
        # Ensures that there is no difference when the ordering is changed 
        [AB_k_theta, AB_theta_0] = force_angle_constant( angle_list[i][0], angle_list[i][1], angle_list[i][2], bond_lengths, eigenvalues, eigenvectors, coords, scaling_factors_angles_list[i][0], scaling_factors_angles_list[i][1] ) 
        [BA_k_theta, BA_theta_0] = force_angle_constant( angle_list[i][2], angle_list[i][1], angle_list[i][0], bond_lengths, eigenvalues, eigenvectors, coords, scaling_factors_angles_list[i][1], scaling_factors_angles_list[i][0] ) 
        k_theta[i] = (AB_k_theta + BA_k_theta ) / 2
        theta_0[i] = (AB_theta_0 +  BA_theta_0 ) / 2
        # Vibrational_scaling takes into account DFT deficities/ anharmonicity 
        k_theta[i] =  k_theta[i] * vibrational_scaling_squared
        file_angle.write(atom_names[angle_list[i][0]] + &#39;-&#39; + atom_names[angle_list[i][1] ] + &#39;-&#39; + atom_names[angle_list[i][2]] + &#39;  &#39; )
        file_angle.write(str(&#34;%#.4g&#34; % k_theta[i]) + &#39;   &#39; + str(&#34;%#.4g&#34; % theta_0[i]) + &#39;   &#39; + str(angle_list[i][0] + 1)  + &#39;   &#39; + str(angle_list[i][1] + 1) + &#39;   &#39; + str(angle_list[i][2] + 1))
        file_angle.write(&#39;\n&#39;)
        unique_values_angles.append([atom_names[angle_list[i][0]], atom_names[angle_list[i][1]], atom_names[angle_list[i][2]], k_theta[i], theta_0[i], 1 ])
    file_angle.close()</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeHost.get_bond_angles"><code class="name flex">
<span>def <span class="ident">get_bond_angles</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves a text file of the bonds and angles from the gaussian log file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bond_angles(self):   
    &#34;&#34;&#34;
    This function saves a text file of the bonds and angles from the gaussian log file.
    &#34;&#34;&#34; 
    log_file = self.host_qm_pdb[:-4] + &#34;.log&#34;
    fid = open(log_file, &#34;r&#34;)
    tline = fid.readline()
    bond_list = []
    angle_list = []
    n = 1
    n_bond = 1
    n_angle = 1
    tmp = &#39;R&#39; # States if bond or angle
    B = []
    # Finds the bond and angles from the .log file
    while tline:
        tline = fid.readline()
        # Line starts at point when bond and angle list occurs
        if len(tline) &gt; 80 and tline[0:81].strip() == &#39;! Name  Definition              Value          Derivative Info.                !&#39;:
            tline = fid.readline()
            tline = fid.readline()
            # Stops when all bond and angles recorded 
            while ( ( tmp[0] == &#39;R&#39; ) or (tmp[0] == &#39;A&#39;) ):
                line = tline.split()
                tmp = line[1]
                # Bond or angles listed as string
                list_terms = line[2][2:-1]
                # Bond List 
                if ( tmp[0] == &#39;R&#39; ): 
                    x = list_terms.split(&#39;,&#39;)
                    # Subtraction due to python array indexing at 0
                    x = [(int(i) - 1 ) for i in x]
                    bond_list.append(x)
                    # Angle List 
                if (tmp[0] == &#39;A&#39; ): 
                    x = list_terms.split(&#39;,&#39;)
                    # Subtraction due to python array indexing at 0
                    x = [(int(i) - 1 ) for i in x]
                    angle_list.append(x)
                tline = fid.readline()
            # Leave loop
            tline = -1
    np.savetxt(self.bond_list_file, bond_list, fmt=&#39;%s&#39;)
    np.savetxt(self.angle_list_file, angle_list, fmt=&#39;%s&#39;)</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeHost.get_charges"><code class="name flex">
<span>def <span class="ident">get_charges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves the charges in a text file obtained from the Gaussian log file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_charges(self):
    &#34;&#34;&#34;
    This function saves the charges in a text file obtained from the Gaussian log file. 
    &#34;&#34;&#34;
    log_file = self.host_qm_pdb[:-4] + &#34;.log&#34;
    with open (log_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Fitting point charges to electrostatic potential&#34; in lines[i]:
            to_begin = int(i)   
        if &#34; Sum of ESP charges =&#34; in lines[i]:
            to_end = int(i)  
    charges = lines[to_begin + 4: to_end]
    charge_list = []
    for i in range(len(charges)):
        charge_list.append(charges[i].strip().split())
    charge_list_value = []
    atom_list = []
    for i in range(len(charge_list)):
        charge_list_value.append(charge_list[i][2])
        atom_list.append(charge_list[i][1])
    data_tuples = list(zip(atom_list,charge_list_value))
    df_charge = pd.DataFrame(data_tuples, columns=[&#39;Atom&#39;,&#39;Charge&#39;])
    df_charge.to_csv (self.charge_parameter_file, index = False, header = False, sep = &#39; &#39;)</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeHost.get_hessian"><code class="name flex">
<span>def <span class="ident">get_hessian</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function extracts hessian from the unprocessed hessian and saves into a new file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hessian(self):
    &#34;&#34;&#34;
    This function extracts hessian from the unprocessed hessian and saves into a new file.
    &#34;&#34;&#34;       
    unprocessed_Hessian = np.loadtxt(self.unprocessed_hessian_file) 
    fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;     
    with open (fchk_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Current cartesian coordinates&#34; in lines[i]:
            no_coordinates = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
            no_coordinates = int(no_coordinates[0])
    N = int(no_coordinates/3)    
    length_hessian = 3 * N
    hessian = np.zeros((length_hessian, length_hessian))
    m = 0
    # Write the hessian in a 2D array format 
    for i in range (0,(length_hessian)):
        for j in range (0,(i + 1)):
            hessian[i][j] = unprocessed_Hessian[m]
            hessian[j][i] = unprocessed_Hessian[m]
            m = m + 1
    hessian = (hessian * (627.509391))/ (0.529**2)  # Change from Hartree/bohr to kcal/mol/ang
    np.savetxt(self.hessian_file, hessian, fmt=&#39;%s&#39;)</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeHost.get_unprocessed_hessian"><code class="name flex">
<span>def <span class="ident">get_unprocessed_hessian</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves a text file of the unprocessed hessian from the formatted checkpoint file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_unprocessed_hessian(self):   
    &#34;&#34;&#34;
    This function saves a text file of the unprocessed hessian from the formatted checkpoint file.
    &#34;&#34;&#34;    
    fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
    with open (fchk_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Cartesian Force Constants&#34; in lines[i]:
            no_hessian = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
            no_hessian = int(no_hessian[0])
    for i in range(len(lines)):
        if &#34;Cartesian Force Constants&#34; in lines[i]:
            to_begin = int(i)     
    hessian = lines[to_begin + 1:to_begin + 1 + int(math.ceil(no_hessian/5))]
    hessian_list = []
    for i in range(len(hessian)):
        hessian_list.append(hessian[i].strip().split())
    unprocessed_Hessian = [item for sublist in hessian_list for item in sublist]
    np.savetxt(self.unprocessed_hessian_file, unprocessed_Hessian, fmt=&#39;%s&#39;)</code></pre>
</details>
</dd>
<dt id="parameterize.ParameterizeHost.get_xyz"><code class="name flex">
<span>def <span class="ident">get_xyz</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves a xyz file from the formatted checkpoint file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_xyz(self):   
    &#34;&#34;&#34;
    This function saves a xyz file from the formatted checkpoint file.
    &#34;&#34;&#34;
    fchk_file = self.host_qm_pdb[:-4] + &#34;.fchk&#34;
    with open (fchk_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Current cartesian coordinates&#34; in lines[i]:
            no_coordinates = re.findall(r&#39;\d+|\d+.\d+&#39;, lines[i])
            no_coordinates = int(no_coordinates[0])
    for i in range(len(lines)):
        if &#34;Current cartesian coordinates&#34; in lines[i]:
            to_begin = int(i)     
    cartesian_coords = lines[to_begin + 1:to_begin + 1 + int(math.ceil(no_coordinates/5))]
    cartesian_list = []
    for i in range(len(cartesian_coords)):
        cartesian_list.append(cartesian_coords[i].strip().split())
    coordinates_list = [item for sublist in cartesian_list for item in sublist]
    list_coords = [float(x)*float(0.529) for x in coordinates_list]
    for i in range(len(lines)):
        if &#34;Atomic numbers&#34; in lines[i]:
            to_begin = int(i) 
        if &#34;Nuclear charges&#34; in lines[i]:
            to_end = int(i)    
    atomic_numbers = lines[to_begin + 1:to_end]
    atom_numbers = []
    for i in range(len(atomic_numbers)):
        atom_numbers.append(atomic_numbers[i].strip().split())
    numbers = [item for sublist in atom_numbers for item in sublist]
    N = int(no_coordinates/3)
    # Opens the new xyz file 
    file = open(self.xyz_file, &#34;w&#34;)
    file.write(str(N) + &#39;\n \n&#39;)
    coords = np.zeros((N,3))
    n = 0
    names = []   
    # Gives name for atomic number
    for x in range(0,len(numbers)):
        names.append(element_list[int(numbers[x]) - 1][1]) 
    # Print coordinates to new input_coords.xyz file
    for i in range(0, N):
        for j in range(0,3):
            coords[i][j] = list_coords[n]
            n = n + 1
        file.write(names[i] + str(round(coords[i][0],3)) + &#39; &#39; + str(round(coords[i][1],3)) + &#39; &#39; + str(round(coords[i][2], 3)) + &#39;\n&#39;)
    file.close()
    np.savetxt(self.coordinate_file, coords, fmt=&#39;%s&#39;)  </code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.PrepareGaussianGuest"><code class="flex name class">
<span>class <span class="ident">PrepareGaussianGuest</span></span>
<span>(</span><span>charge, multiplicity, guest_pdb='guest_init_II.pdb', n_processors=12, memory=50, functional='B3LYP', basis_set='6-31G', optimisation='OPT', frequency='FREQ', add_keywords_I='Integral=(Grid=UltraFine)', add_keywords_II='Pop(MK,ReadRadii)', add_keywords_III='IOp(6/33=2,6/42=6)', gauss_out_file='guest.out', fchk_out_file='guest_fchk.out')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrepareGaussianGuest:
    
    def __init__(self, charge, multiplicity, guest_pdb = &#34;guest_init_II.pdb&#34;, n_processors = 12, memory = 50, functional = &#34;B3LYP&#34;, basis_set = &#34;6-31G&#34;, optimisation = &#34;OPT&#34;, frequency = &#34;FREQ&#34;, add_keywords_I = &#34;Integral=(Grid=UltraFine)&#34;, add_keywords_II = &#34;Pop(MK,ReadRadii)&#34;, add_keywords_III = &#34;IOp(6/33=2,6/42=6)&#34;, gauss_out_file = &#34;guest.out&#34;, fchk_out_file = &#34;guest_fchk.out&#34;):
        self.charge = charge
        self.multiplicity = multiplicity
        self.guest_pdb = guest_pdb
        self.n_processors = n_processors
        self.memory = memory
        self.functional = functional
        self.basis_set  = basis_set
        self.optimisation = optimisation
        self.frequency = frequency
        self.gauss_out_file = gauss_out_file
        self.fchk_out_file = fchk_out_file
        self.add_keywords_I = add_keywords_I
        self.add_keywords_II = add_keywords_II
        self.add_keywords_III = add_keywords_III
        
    def write_input(self):   
        &#34;&#34;&#34;
        This function prints out the commands section of the gaussian input file.
        &#34;&#34;&#34;
        command_line_1 = &#34;%Chk = &#34; + self.guest_pdb[:-4] + &#34;.chk&#34; 
        command_line_2 = &#34;%Mem = &#34; + str(self.memory) + &#34;GB&#34;
        command_line_3 = &#34;%NProcShared = &#34; + str(self.n_processors)
        command_line_4 = &#34;# &#34; + self.functional + &#34; &#34; + self.basis_set + &#34; &#34; + self.optimisation + &#34; &#34; + self.frequency + &#34; &#34; + self.add_keywords_I + &#34; &#34; + self.add_keywords_II + &#34; &#34; + self.add_keywords_III
        command_line_5 = &#34; &#34;
        command_line_6 = self.guest_pdb[:-4] + &#34; &#34;  + &#34;gaussian input file&#34;
        command_line_7 = &#34; &#34;
        command_line_8 = str(self.charge) + &#34; &#34;  + str(self.multiplicity)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_pdb)
        df = ppdb.df[&#39;ATOM&#39;]
        df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
        df_1.columns = [&#39;atom&#39;]
        df_2 = df[[&#39;x_coord&#39;, &#39;y_coord&#39;, &#39;z_coord&#39;]]
        df_merged = pd.concat([df_1, df_2], axis=1)
        command_line_9 = df_merged.to_string(header = False, index = False)
        command_line_10 = &#34; &#34;
        command = [command_line_1, command_line_2, command_line_3, command_line_4, 
                   command_line_5, command_line_6, command_line_7, command_line_8, 
                   command_line_9, command_line_10]
        commands = &#39;\n&#39;.join(command)
        with open(self.guest_pdb[:-4] + &#34;.com&#34;, &#34;w&#34;) as f:
            f.write(commands)
            
    def run_gaussian(self):   
        &#34;&#34;&#34;
        This function runs the gaussian QM calculation.
        &#34;&#34;&#34;
        execute_command = &#34;g16&#34; + &#34; &lt; &#34; + self.guest_pdb[:-4] + &#34;.com&#34;  + &#34; &gt; &#34;  + self.guest_pdb[:-4] + &#34;.log&#34; 
        with open(self.gauss_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell = True, stdout = f, stderr = sp.STDOUT)
        
    def get_fchk(self):   
        &#34;&#34;&#34;
        This function converts the checkpoint file file into the formatted chechkpoint file.
        &#34;&#34;&#34;
        execute_command = &#34;formchk&#34;+ &#34; &#34; + self.guest_pdb[:-4] + &#34;.chk&#34; + &#34; &#34; + self.guest_pdb[:-4] + &#34;.fchk&#34;
        with open(self.fchk_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell = True, stdout = f, stderr = sp.STDOUT)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.PrepareGaussianGuest.get_fchk"><code class="name flex">
<span>def <span class="ident">get_fchk</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function converts the checkpoint file file into the formatted chechkpoint file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fchk(self):   
    &#34;&#34;&#34;
    This function converts the checkpoint file file into the formatted chechkpoint file.
    &#34;&#34;&#34;
    execute_command = &#34;formchk&#34;+ &#34; &#34; + self.guest_pdb[:-4] + &#34;.chk&#34; + &#34; &#34; + self.guest_pdb[:-4] + &#34;.fchk&#34;
    with open(self.fchk_out_file, &#34;w+&#34;) as f:
        sp.run(execute_command, shell = True, stdout = f, stderr = sp.STDOUT)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareGaussianGuest.run_gaussian"><code class="name flex">
<span>def <span class="ident">run_gaussian</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function runs the gaussian QM calculation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_gaussian(self):   
    &#34;&#34;&#34;
    This function runs the gaussian QM calculation.
    &#34;&#34;&#34;
    execute_command = &#34;g16&#34; + &#34; &lt; &#34; + self.guest_pdb[:-4] + &#34;.com&#34;  + &#34; &gt; &#34;  + self.guest_pdb[:-4] + &#34;.log&#34; 
    with open(self.gauss_out_file, &#34;w+&#34;) as f:
        sp.run(execute_command, shell = True, stdout = f, stderr = sp.STDOUT)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareGaussianGuest.write_input"><code class="name flex">
<span>def <span class="ident">write_input</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function prints out the commands section of the gaussian input file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_input(self):   
    &#34;&#34;&#34;
    This function prints out the commands section of the gaussian input file.
    &#34;&#34;&#34;
    command_line_1 = &#34;%Chk = &#34; + self.guest_pdb[:-4] + &#34;.chk&#34; 
    command_line_2 = &#34;%Mem = &#34; + str(self.memory) + &#34;GB&#34;
    command_line_3 = &#34;%NProcShared = &#34; + str(self.n_processors)
    command_line_4 = &#34;# &#34; + self.functional + &#34; &#34; + self.basis_set + &#34; &#34; + self.optimisation + &#34; &#34; + self.frequency + &#34; &#34; + self.add_keywords_I + &#34; &#34; + self.add_keywords_II + &#34; &#34; + self.add_keywords_III
    command_line_5 = &#34; &#34;
    command_line_6 = self.guest_pdb[:-4] + &#34; &#34;  + &#34;gaussian input file&#34;
    command_line_7 = &#34; &#34;
    command_line_8 = str(self.charge) + &#34; &#34;  + str(self.multiplicity)
    ppdb = PandasPdb()
    ppdb.read_pdb(self.guest_pdb)
    df = ppdb.df[&#39;ATOM&#39;]
    df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
    df_1.columns = [&#39;atom&#39;]
    df_2 = df[[&#39;x_coord&#39;, &#39;y_coord&#39;, &#39;z_coord&#39;]]
    df_merged = pd.concat([df_1, df_2], axis=1)
    command_line_9 = df_merged.to_string(header = False, index = False)
    command_line_10 = &#34; &#34;
    command = [command_line_1, command_line_2, command_line_3, command_line_4, 
               command_line_5, command_line_6, command_line_7, command_line_8, 
               command_line_9, command_line_10]
    commands = &#39;\n&#39;.join(command)
    with open(self.guest_pdb[:-4] + &#34;.com&#34;, &#34;w&#34;) as f:
        f.write(commands)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.PrepareGaussianHost"><code class="flex name class">
<span>class <span class="ident">PrepareGaussianHost</span></span>
<span>(</span><span>charge, multiplicity, host_qm_pdb='host_qm.pdb', n_processors=12, memory=50, functional='B3LYP', basis_set='6-31G', optimisation='OPT', frequency='FREQ', add_keywords_I='Integral=(Grid=UltraFine)', add_keywords_II='Pop(MK,ReadRadii)', add_keywords_III='IOp(6/33=2,6/42=6)', gauss_out_file='host_qm.out', fchk_out_file='host_qm_fchk.out')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrepareGaussianHost:
  
    def __init__(self, charge, multiplicity, host_qm_pdb = &#34;host_qm.pdb&#34;, n_processors = 12, memory = 50, functional = &#34;B3LYP&#34;, basis_set = &#34;6-31G&#34;, optimisation = &#34;OPT&#34;, frequency = &#34;FREQ&#34;, add_keywords_I = &#34;Integral=(Grid=UltraFine)&#34;, add_keywords_II = &#34;Pop(MK,ReadRadii)&#34;, add_keywords_III = &#34;IOp(6/33=2,6/42=6)&#34;, gauss_out_file = &#34;host_qm.out&#34;, fchk_out_file = &#34;host_qm_fchk.out&#34;):
        self.charge = charge
        self.multiplicity = multiplicity
        self.host_qm_pdb = host_qm_pdb
        self.n_processors = n_processors
        self.memory = memory
        self.functional = functional
        self.basis_set  = basis_set
        self.optimisation = optimisation
        self.frequency = frequency
        self.gauss_out_file = gauss_out_file
        self.fchk_out_file = fchk_out_file
        self.add_keywords_I = add_keywords_I
        self.add_keywords_II = add_keywords_II
        self.add_keywords_III = add_keywords_III
        
    def write_input(self):   
        &#34;&#34;&#34;
        This function prints out the commands section of the gaussian input file.
        &#34;&#34;&#34;
        command_line_1 = &#34;%Chk = &#34; + self.host_qm_pdb[:-4] + &#34;.chk&#34; 
        command_line_2 = &#34;%Mem = &#34; + str(self.memory) + &#34;GB&#34;
        command_line_3 = &#34;%NProcShared = &#34; + str(self.n_processors)
        command_line_4 = &#34;# &#34; + self.functional + &#34; &#34; + self.basis_set + &#34; &#34; + self.optimisation + &#34; &#34; + self.frequency + &#34; &#34; + self.add_keywords_I + &#34; &#34; + self.add_keywords_II + &#34; &#34; + self.add_keywords_III
        command_line_5 = &#34; &#34;
        command_line_6 = self.host_qm_pdb[:-4] + &#34; &#34;  + &#34;gaussian input file&#34;
        command_line_7 = &#34; &#34;
        command_line_8 = str(self.charge) + &#34; &#34;  + str(self.multiplicity)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_qm_pdb)
        df = ppdb.df[&#39;ATOM&#39;]
        df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
        df_1.columns = [&#39;atom&#39;]
        df_2 = df[[&#39;x_coord&#39;, &#39;y_coord&#39;, &#39;z_coord&#39;]]
        df_merged = pd.concat([df_1, df_2], axis=1)
        command_line_9 = df_merged.to_string(header = False, index = False)
        command_line_10 = &#34; &#34;
        command = [command_line_1, command_line_2, command_line_3, command_line_4, 
                   command_line_5, command_line_6, command_line_7, command_line_8, 
                   command_line_9, command_line_10]
        commands = &#39;\n&#39;.join(command)
        with open(self.host_qm_pdb[:-4] + &#34;.com&#34;, &#34;w&#34;) as f:
            f.write(commands)
            
    def run_gaussian(self):   
        &#34;&#34;&#34;
        This function runs the gaussian QM calculation.
        &#34;&#34;&#34;
        execute_command = &#34;g16&#34; + &#34; &lt; &#34; + self.host_qm_pdb[:-4] + &#34;.com&#34;  + &#34; &gt; &#34;  + self.host_qm_pdb[:-4] + &#34;.log&#34; 
        with open(self.gauss_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell = True, stdout = f, stderr = sp.STDOUT)
        
    def get_fchk(self):   
        &#34;&#34;&#34;
        This function converts the checkpoint file file into the formatted chechkpoint file.
        &#34;&#34;&#34;
        execute_command = &#34;formchk&#34;+ &#34; &#34; + self.host_qm_pdb[:-4] + &#34;.chk&#34; + &#34; &#34; + self.host_qm_pdb[:-4] + &#34;.fchk&#34;
        with open(self.fchk_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell = True, stdout = f, stderr = sp.STDOUT)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.PrepareGaussianHost.get_fchk"><code class="name flex">
<span>def <span class="ident">get_fchk</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function converts the checkpoint file file into the formatted chechkpoint file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fchk(self):   
    &#34;&#34;&#34;
    This function converts the checkpoint file file into the formatted chechkpoint file.
    &#34;&#34;&#34;
    execute_command = &#34;formchk&#34;+ &#34; &#34; + self.host_qm_pdb[:-4] + &#34;.chk&#34; + &#34; &#34; + self.host_qm_pdb[:-4] + &#34;.fchk&#34;
    with open(self.fchk_out_file, &#34;w+&#34;) as f:
        sp.run(execute_command, shell = True, stdout = f, stderr = sp.STDOUT)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareGaussianHost.run_gaussian"><code class="name flex">
<span>def <span class="ident">run_gaussian</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function runs the gaussian QM calculation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_gaussian(self):   
    &#34;&#34;&#34;
    This function runs the gaussian QM calculation.
    &#34;&#34;&#34;
    execute_command = &#34;g16&#34; + &#34; &lt; &#34; + self.host_qm_pdb[:-4] + &#34;.com&#34;  + &#34; &gt; &#34;  + self.host_qm_pdb[:-4] + &#34;.log&#34; 
    with open(self.gauss_out_file, &#34;w+&#34;) as f:
        sp.run(execute_command, shell = True, stdout = f, stderr = sp.STDOUT)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareGaussianHost.write_input"><code class="name flex">
<span>def <span class="ident">write_input</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function prints out the commands section of the gaussian input file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_input(self):   
    &#34;&#34;&#34;
    This function prints out the commands section of the gaussian input file.
    &#34;&#34;&#34;
    command_line_1 = &#34;%Chk = &#34; + self.host_qm_pdb[:-4] + &#34;.chk&#34; 
    command_line_2 = &#34;%Mem = &#34; + str(self.memory) + &#34;GB&#34;
    command_line_3 = &#34;%NProcShared = &#34; + str(self.n_processors)
    command_line_4 = &#34;# &#34; + self.functional + &#34; &#34; + self.basis_set + &#34; &#34; + self.optimisation + &#34; &#34; + self.frequency + &#34; &#34; + self.add_keywords_I + &#34; &#34; + self.add_keywords_II + &#34; &#34; + self.add_keywords_III
    command_line_5 = &#34; &#34;
    command_line_6 = self.host_qm_pdb[:-4] + &#34; &#34;  + &#34;gaussian input file&#34;
    command_line_7 = &#34; &#34;
    command_line_8 = str(self.charge) + &#34; &#34;  + str(self.multiplicity)
    ppdb = PandasPdb()
    ppdb.read_pdb(self.host_qm_pdb)
    df = ppdb.df[&#39;ATOM&#39;]
    df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
    df_1.columns = [&#39;atom&#39;]
    df_2 = df[[&#39;x_coord&#39;, &#39;y_coord&#39;, &#39;z_coord&#39;]]
    df_merged = pd.concat([df_1, df_2], axis=1)
    command_line_9 = df_merged.to_string(header = False, index = False)
    command_line_10 = &#34; &#34;
    command = [command_line_1, command_line_2, command_line_3, command_line_4, 
               command_line_5, command_line_6, command_line_7, command_line_8, 
               command_line_9, command_line_10]
    commands = &#39;\n&#39;.join(command)
    with open(self.host_qm_pdb[:-4] + &#34;.com&#34;, &#34;w&#34;) as f:
        f.write(commands)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.PrepareGaussianHostGuest"><code class="flex name class">
<span>class <span class="ident">PrepareGaussianHostGuest</span></span>
<span>(</span><span>charge, multiplicity, guest_pdb='guest_init_II.pdb', host_qm_pdb='host_qm.pdb', n_processors=12, memory=50, functional='B3LYP', basis_set='6-31G', optimisation='', frequency='', add_keywords_I='Integral=(Grid=UltraFine)', add_keywords_II='Pop(MK,ReadRadii)', add_keywords_III='IOp(6/33=2,6/42=6)', gauss_system_out_file='system_qm.out', fchk_system_out_file='system_qm_fchk.out', host_guest_input='host_guest.com', qm_guest_charge_parameter_file='guest_qm_surround_charges.txt', qm_host_charge_parameter_file='host_qm_surround_charges.txt', qm_guest_atom_charge_parameter_file='guest_qm_atom_surround_charges.txt')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrepareGaussianHostGuest:

    def __init__(self, charge, multiplicity, guest_pdb = &#34;guest_init_II.pdb&#34;, host_qm_pdb = &#34;host_qm.pdb&#34;, n_processors = 12, memory = 50, functional = &#34;B3LYP&#34;, basis_set = &#34;6-31G&#34;, optimisation = &#34;&#34;, frequency = &#34;&#34;, add_keywords_I = &#34;Integral=(Grid=UltraFine)&#34;, add_keywords_II = &#34;Pop(MK,ReadRadii)&#34;, add_keywords_III = &#34;IOp(6/33=2,6/42=6)&#34;, gauss_system_out_file = &#34;system_qm.out&#34;, fchk_system_out_file = &#34;system_qm_fchk.out&#34;, host_guest_input = &#34;host_guest.com&#34;, qm_guest_charge_parameter_file = &#34;guest_qm_surround_charges.txt&#34;, qm_host_charge_parameter_file = &#34;host_qm_surround_charges.txt&#34;, qm_guest_atom_charge_parameter_file = &#34;guest_qm_atom_surround_charges.txt&#34;):
        self.charge = charge
        self.multiplicity = multiplicity
        self.guest_pdb = guest_pdb
        self.host_qm_pdb = host_qm_pdb
        self.n_processors = n_processors
        self.memory = memory
        self.functional = functional
        self.basis_set  = basis_set
        self.optimisation = optimisation
        self.frequency = frequency
        self.add_keywords_I = add_keywords_I
        self.add_keywords_II = add_keywords_II
        self.add_keywords_III = add_keywords_III
        self.gauss_system_out_file = gauss_system_out_file
        self.fchk_system_out_file = fchk_system_out_file
        self.host_guest_input = host_guest_input
        self.qm_guest_charge_parameter_file = qm_guest_charge_parameter_file
        self.qm_host_charge_parameter_file = qm_host_charge_parameter_file
        self.qm_guest_atom_charge_parameter_file = qm_guest_atom_charge_parameter_file
        
    def write_input(self):   
        &#34;&#34;&#34;
        This function prints out the commands section of the gaussian input file.
        &#34;&#34;&#34;
        command_line_1 = &#34;%Chk = &#34; + self.host_guest_input[:-4] + &#34;.chk&#34; 
        command_line_2 = &#34;%Mem = &#34; + str(self.memory) + &#34;GB&#34;
        command_line_3 = &#34;%NProcShared = &#34; + str(self.n_processors)
        command_line_4 = &#34;# &#34; + self.functional + &#34; &#34; + self.basis_set + &#34; &#34; + self.optimisation + &#34; &#34; + self.frequency + &#34; &#34; + self.add_keywords_I + &#34; &#34; + self.add_keywords_II + &#34; &#34; + self.add_keywords_III
        command_line_5 = &#34; &#34;
        command_line_6 = &#34;Gaussian Input File&#34;
        command_line_7 = &#34; &#34;
        command_line_8 = str(self.charge) + &#34; &#34;  + str(self.multiplicity)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_pdb)
        df = ppdb.df[&#39;ATOM&#39;]
        df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
        df_1.columns = [&#39;atom&#39;]
        df_3 = df[[&#39;x_coord&#39;, &#39;y_coord&#39;, &#39;z_coord&#39;]]
        df_2 = pd.Series([&#34;0&#34;] * len(df), name=&#39;decide_freeze&#39;) 
        df_merged_1 = pd.concat([df_1, df_2, df_3], axis=1)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_qm_pdb)
        df = ppdb.df[&#39;ATOM&#39;]
        df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
        df_1.columns = [&#39;atom&#39;]
        df_3 = df[[&#39;x_coord&#39;, &#39;y_coord&#39;, &#39;z_coord&#39;]]
        df_2 = pd.Series([&#34;0&#34;] * len(df), name=&#39;decide_freeze&#39;) 
        df_merged_2 = pd.concat([df_1, df_2, df_3], axis=1)    
        df_merged = pd.concat([df_merged_1, df_merged_2], axis=0)
        command_line_9 = df_merged.to_string(header = False, index = False)
        command_line_10 = &#34; &#34;
        command = [command_line_1, command_line_2, command_line_3, command_line_4, 
                   command_line_5, command_line_6, command_line_7, command_line_8, 
                   command_line_9, command_line_10]
        commands = &#39;\n&#39;.join(command)
       
        with open(self.host_guest_input, &#34;w&#34;) as f:
            f.write(commands)
           
    def run_gaussian(self):   
        &#34;&#34;&#34;
        This function runs the gaussian QM calculation.
        &#34;&#34;&#34;
        execute_command = &#34;g16&#34; + &#34; &lt; &#34; + self.host_guest_input + &#34; &gt; &#34;  + self.host_guest_input[:-4] + &#34;.log&#34; 
        with open(self.gauss_system_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell = True, stdout = f, stderr = sp.STDOUT)
            
    def get_fchk(self):   
        &#34;&#34;&#34;
        This function converts the checkpoint file file into the formatted chechkpoint file.
        &#34;&#34;&#34;
        execute_command = &#34;formchk&#34;+ &#34; &#34; + self.host_guest_input[:-4] + &#34;.chk&#34; + &#34; &#34; + self.host_guest_input[:-4] + &#34;.fchk&#34;
        with open(self.fchk_system_out_file, &#34;w+&#34;) as f:
            sp.run(execute_command, shell = True, stdout = f, stderr = sp.STDOUT)

    def get_qm_host_guest_charges(self):
        &#34;&#34;&#34;This function extracts charges and saves them separately for the host and guest&#34;&#34;&#34;
        log_file = self.host_guest_input[:-4] + &#34;.log&#34;
        with open (log_file, &#34;r&#34;) as f:
            lines = f.readlines()
        for i in range(len(lines)):
            if &#34;Fitting point charges to electrostatic potential&#34; in lines[i]:
                to_begin = int(i)   
            if &#34; Sum of ESP charges =&#34; in lines[i]:
                to_end = int(i)  
        charges = lines[to_begin + 4: to_end]
        charge_list = []
        for i in range(len(charges)):
            charge_list.append(charges[i].strip().split())
        charge_list_value = []
        atom_list = []
        for i in range(len(charge_list)):
            charge_list_value.append(charge_list[i][2])
            atom_list.append(charge_list[i][1])
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_pdb)
        df_guest = ppdb.df[&#39;ATOM&#39;]
        number_guest_atoms = df_guest.shape[0]
        data_tuples = list(zip(atom_list,charge_list_value))
        df_charge = pd.DataFrame(data_tuples, columns=[&#39;Atom&#39;,&#39;Charge&#39;])
        number_host_atoms = df_charge.shape[0] - number_guest_atoms
        df_charge_guest = df_charge.head(number_guest_atoms)
        df_charge_host = df_charge.tail(number_host_atoms)
        df_charge_only_guest = df_charge_guest[&#34;Charge&#34;]
        df_charge_guest.to_csv (self.qm_guest_charge_parameter_file, index = False, header = False, sep = &#39; &#39;)
        df_charge_host.to_csv (self.qm_host_charge_parameter_file, index = False, header = False, sep = &#39; &#39;)
        df_charge_only_guest.to_csv (self.qm_guest_atom_charge_parameter_file, index = False, header = False, sep = &#39; &#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.PrepareGaussianHostGuest.get_fchk"><code class="name flex">
<span>def <span class="ident">get_fchk</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function converts the checkpoint file file into the formatted chechkpoint file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fchk(self):   
    &#34;&#34;&#34;
    This function converts the checkpoint file file into the formatted chechkpoint file.
    &#34;&#34;&#34;
    execute_command = &#34;formchk&#34;+ &#34; &#34; + self.host_guest_input[:-4] + &#34;.chk&#34; + &#34; &#34; + self.host_guest_input[:-4] + &#34;.fchk&#34;
    with open(self.fchk_system_out_file, &#34;w+&#34;) as f:
        sp.run(execute_command, shell = True, stdout = f, stderr = sp.STDOUT)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareGaussianHostGuest.get_qm_host_guest_charges"><code class="name flex">
<span>def <span class="ident">get_qm_host_guest_charges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function extracts charges and saves them separately for the host and guest</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_qm_host_guest_charges(self):
    &#34;&#34;&#34;This function extracts charges and saves them separately for the host and guest&#34;&#34;&#34;
    log_file = self.host_guest_input[:-4] + &#34;.log&#34;
    with open (log_file, &#34;r&#34;) as f:
        lines = f.readlines()
    for i in range(len(lines)):
        if &#34;Fitting point charges to electrostatic potential&#34; in lines[i]:
            to_begin = int(i)   
        if &#34; Sum of ESP charges =&#34; in lines[i]:
            to_end = int(i)  
    charges = lines[to_begin + 4: to_end]
    charge_list = []
    for i in range(len(charges)):
        charge_list.append(charges[i].strip().split())
    charge_list_value = []
    atom_list = []
    for i in range(len(charge_list)):
        charge_list_value.append(charge_list[i][2])
        atom_list.append(charge_list[i][1])
    ppdb = PandasPdb()
    ppdb.read_pdb(self.guest_pdb)
    df_guest = ppdb.df[&#39;ATOM&#39;]
    number_guest_atoms = df_guest.shape[0]
    data_tuples = list(zip(atom_list,charge_list_value))
    df_charge = pd.DataFrame(data_tuples, columns=[&#39;Atom&#39;,&#39;Charge&#39;])
    number_host_atoms = df_charge.shape[0] - number_guest_atoms
    df_charge_guest = df_charge.head(number_guest_atoms)
    df_charge_host = df_charge.tail(number_host_atoms)
    df_charge_only_guest = df_charge_guest[&#34;Charge&#34;]
    df_charge_guest.to_csv (self.qm_guest_charge_parameter_file, index = False, header = False, sep = &#39; &#39;)
    df_charge_host.to_csv (self.qm_host_charge_parameter_file, index = False, header = False, sep = &#39; &#39;)
    df_charge_only_guest.to_csv (self.qm_guest_atom_charge_parameter_file, index = False, header = False, sep = &#39; &#39;)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareGaussianHostGuest.run_gaussian"><code class="name flex">
<span>def <span class="ident">run_gaussian</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function runs the gaussian QM calculation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_gaussian(self):   
    &#34;&#34;&#34;
    This function runs the gaussian QM calculation.
    &#34;&#34;&#34;
    execute_command = &#34;g16&#34; + &#34; &lt; &#34; + self.host_guest_input + &#34; &gt; &#34;  + self.host_guest_input[:-4] + &#34;.log&#34; 
    with open(self.gauss_system_out_file, &#34;w+&#34;) as f:
        sp.run(execute_command, shell = True, stdout = f, stderr = sp.STDOUT)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareGaussianHostGuest.write_input"><code class="name flex">
<span>def <span class="ident">write_input</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function prints out the commands section of the gaussian input file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_input(self):   
    &#34;&#34;&#34;
    This function prints out the commands section of the gaussian input file.
    &#34;&#34;&#34;
    command_line_1 = &#34;%Chk = &#34; + self.host_guest_input[:-4] + &#34;.chk&#34; 
    command_line_2 = &#34;%Mem = &#34; + str(self.memory) + &#34;GB&#34;
    command_line_3 = &#34;%NProcShared = &#34; + str(self.n_processors)
    command_line_4 = &#34;# &#34; + self.functional + &#34; &#34; + self.basis_set + &#34; &#34; + self.optimisation + &#34; &#34; + self.frequency + &#34; &#34; + self.add_keywords_I + &#34; &#34; + self.add_keywords_II + &#34; &#34; + self.add_keywords_III
    command_line_5 = &#34; &#34;
    command_line_6 = &#34;Gaussian Input File&#34;
    command_line_7 = &#34; &#34;
    command_line_8 = str(self.charge) + &#34; &#34;  + str(self.multiplicity)
    ppdb = PandasPdb()
    ppdb.read_pdb(self.guest_pdb)
    df = ppdb.df[&#39;ATOM&#39;]
    df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
    df_1.columns = [&#39;atom&#39;]
    df_3 = df[[&#39;x_coord&#39;, &#39;y_coord&#39;, &#39;z_coord&#39;]]
    df_2 = pd.Series([&#34;0&#34;] * len(df), name=&#39;decide_freeze&#39;) 
    df_merged_1 = pd.concat([df_1, df_2, df_3], axis=1)
    ppdb = PandasPdb()
    ppdb.read_pdb(self.host_qm_pdb)
    df = ppdb.df[&#39;ATOM&#39;]
    df_1 = ppdb.df[&#34;ATOM&#34;][&#34;element_symbol&#34;]
    df_1.columns = [&#39;atom&#39;]
    df_3 = df[[&#39;x_coord&#39;, &#39;y_coord&#39;, &#39;z_coord&#39;]]
    df_2 = pd.Series([&#34;0&#34;] * len(df), name=&#39;decide_freeze&#39;) 
    df_merged_2 = pd.concat([df_1, df_2, df_3], axis=1)    
    df_merged = pd.concat([df_merged_1, df_merged_2], axis=0)
    command_line_9 = df_merged.to_string(header = False, index = False)
    command_line_10 = &#34; &#34;
    command = [command_line_1, command_line_2, command_line_3, command_line_4, 
               command_line_5, command_line_6, command_line_7, command_line_8, 
               command_line_9, command_line_10]
    commands = &#39;\n&#39;.join(command)
   
    with open(self.host_guest_input, &#34;w&#34;) as f:
        f.write(commands)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.PrepareQMMM"><code class="flex name class">
<span>class <span class="ident">PrepareQMMM</span></span>
<span>(</span><span>init_pdb, distance, num_residues, guest_resname, cleaned_pdb='system.pdb', guest_init_pdb='guest_init.pdb', host_pdb='host.pdb', guest_pdb='guest_init_II.pdb', guest_xyz='guest_coord.txt', residue_list='residue_list.txt', host_qm_atoms='host_qm.txt', host_mm_atoms='host_mm.txt', host_qm_pdb='host_qm.pdb', host_mm_pdb='host_mm.pdb', qm_pdb='qm.pdb', mm_pdb='mm.pdb', host_mm_region_I_atoms='host_mm_region_I.txt', host_mm_region_II_atoms='host_mm_region_II.txt', host_mm_region_I_pdb='host_mm_region_I.pdb', host_mm_region_II_pdb='host_mm_region_II.pdb')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrepareQMMM:
 
    def __init__(self, init_pdb, distance, num_residues, guest_resname, cleaned_pdb = &#34;system.pdb&#34;, guest_init_pdb = &#34;guest_init.pdb&#34;, host_pdb = &#34;host.pdb&#34;, guest_pdb = &#34;guest_init_II.pdb&#34;, guest_xyz = &#34;guest_coord.txt&#34;, residue_list = &#34;residue_list.txt&#34;, host_qm_atoms = &#34;host_qm.txt&#34;, host_mm_atoms = &#34;host_mm.txt&#34;, host_qm_pdb = &#34;host_qm.pdb&#34;, host_mm_pdb = &#34;host_mm.pdb&#34;, qm_pdb = &#34;qm.pdb&#34;, mm_pdb = &#34;mm.pdb&#34;, host_mm_region_I_atoms = &#34;host_mm_region_I.txt&#34;, host_mm_region_II_atoms = &#34;host_mm_region_II.txt&#34;, host_mm_region_I_pdb = &#34;host_mm_region_I.pdb&#34;, host_mm_region_II_pdb = &#34;host_mm_region_II.pdb&#34;):
        self.init_pdb = init_pdb
        self.distance = distance
        self.num_residues = num_residues
        self.guest_resname = guest_resname
        self.cleaned_pdb = cleaned_pdb
        self.guest_init_pdb = guest_init_pdb
        self.host_pdb = host_pdb
        self.guest_pdb = guest_pdb
        self.guest_xyz  = guest_xyz
        self.residue_list = residue_list
        self.host_qm_atoms = host_qm_atoms
        self.host_mm_atoms = host_mm_atoms
        self.host_qm_pdb = host_qm_pdb
        self.host_mm_pdb = host_mm_pdb
        self.qm_pdb = qm_pdb
        self.mm_pdb = mm_pdb
        self.host_mm_region_I_atoms = host_mm_region_I_atoms
        self.host_mm_region_II_atoms = host_mm_region_II_atoms
        self.host_mm_region_I_pdb = host_mm_region_I_pdb
        self.host_mm_region_II_pdb = host_mm_region_II_pdb

    def clean_up(self):   
        &#34;&#34;&#34;
        This function removes everything from the initial pdb file except the host and guest molecules from the system and saves a pdb file.
        &#34;&#34;&#34;
        ions = [&#34;Na+&#34;, &#34;Cs+&#34;, &#34;K+&#34;,&#34;Li+&#34;, &#34;Rb+&#34;, &#34;Cl-&#34;, &#34;Br-&#34;, &#34;F-&#34;, &#34;I-&#34;, &#34;Ca2&#34;]
        intermediate_file_1 = self.cleaned_pdb[:-4] + &#34;_intermediate_1.pdb&#34;
        intermediate_file_2 = self.cleaned_pdb[:-4] + &#34;_intermediate_2.pdb&#34;
        command = &#34;pdb4amber -i &#34; + self.init_pdb + &#34; -o &#34; + intermediate_file_1 + &#34; --noter --dry&#34;
        os.system(command)
        to_delete = intermediate_file_1[:-4] + &#34;_nonprot.pdb&#34; , intermediate_file_1[:-4] + &#34;_renum.txt&#34;, intermediate_file_1[:-4] + &#34;_sslink&#34;, intermediate_file_1[:-4] + &#34;_water.pdb&#34;   
        os.system(&#34;rm -rf &#34; + to_delete[0] + &#34; &#34; + to_delete[1] + &#34; &#34; + to_delete[2] + &#34; &#34; + to_delete[3])  
        with open(intermediate_file_1) as f1, open(intermediate_file_2, &#39;w&#39;) as f2:
            for line in f1:
                if not any(ion in line for ion in ions):
                    f2.write(line)                
        with open(intermediate_file_2, &#39;r&#39;) as f1 :
            filedata = f1.read()
        filedata = filedata.replace(&#39;HETATM&#39;, &#39;ATOM  &#39;)
        with open(self.cleaned_pdb, &#39;w&#39;) as f2:
            f2.write(filedata)
        command = &#34;rm -rf &#34; + intermediate_file_1 + &#34; &#34; + intermediate_file_2
        os.system(command)
    
    def create_host_guest(self):   
        &#34;&#34;&#34;
        This function creates separate host and guest pdb files.
        &#34;&#34;&#34;
        with open(self.cleaned_pdb) as f1, open(self.host_pdb, &#39;w&#39;) as f2:
            for line in f1:
                if not self.guest_resname in line and not &#34;CRYST1&#34; in line:
                    f2.write(line)           
        with open(self.cleaned_pdb) as f1, open(self.guest_init_pdb, &#39;w&#39;) as f2:
            for line in f1:
                if self.guest_resname in line or &#34;END&#34; in line:
                    f2.write(line)
                    
    def realign_guest(self):   
        &#34;&#34;&#34;
        This function realigns the atom numbers in the initial guest pdb file given the assumption that the original pdb file had the host molecule followed by the guest molecule.
        &#34;&#34;&#34;
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_init_pdb)
        to_substract = min(ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;]) - 1 
        ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] - to_substract
        intermediate_file_1 = self.guest_pdb[:-4] + &#34;_intermediate_1.pdb&#34;
        intermediate_file_2 = self.guest_pdb[:-4] + &#34;_intermediate_2.pdb&#34;
        ppdb.to_pdb(path = intermediate_file_1)
        command = &#34;pdb4amber -i &#34; + intermediate_file_1 +  &#34; -o &#34; + intermediate_file_2
        os.system(command)
        to_delete = intermediate_file_2[:-4] + &#34;_nonprot.pdb&#34; , intermediate_file_2[:-4] + &#34;_renum.txt&#34;, intermediate_file_2[:-4] + &#34;_sslink&#34;
        os.system(&#34;rm -rf &#34; + to_delete[0] + &#34; &#34; + to_delete[1] + &#34; &#34; + to_delete[2])  
        with open(intermediate_file_2, &#39;r&#39;) as f1 :
            filedata = f1.read()
        filedata = filedata.replace(&#39;HETATM&#39;, &#39;ATOM  &#39;)
        with open(self.guest_pdb, &#39;w&#39;) as f2:
            f2.write(filedata)
        command = &#34;rm -rf &#34; + intermediate_file_1 + &#34; &#34; + intermediate_file_2
        os.system(command)
        
    def get_guest_coord(self):   
        &#34;&#34;&#34;
        This function saves a list of xyz coordinates from the pdb file.
        &#34;&#34;&#34;
        ppdb = PandasPdb()
        ppdb.read_pdb(self.guest_pdb)
        xyz = ppdb.df[&#39;ATOM&#39;][[&#34;x_coord&#34;,&#34;y_coord&#34;,&#34;z_coord&#34;]]
        xyz_to_list = xyz.values.tolist()
        np.savetxt(self.guest_xyz, xyz_to_list)
        
    def get_qm_resids(self):  
        &#34;&#34;&#34;
        This function saves a list of residue numbers of the residues in the host molecule surrounding the guest within a mentioned distance from any of the atom in the guest molecule.
        &#34;&#34;&#34;
        guest_coord_list = np.loadtxt(self.guest_xyz)
        host_atom_list = []
        for i in range(len(guest_coord_list)):
            reference_point = guest_coord_list[i]
            ppdb = PandasPdb()
            ppdb.read_pdb(self.host_pdb)
            distances = ppdb.distance(xyz=reference_point, records=(&#39;ATOM&#39;))
            all_within_distance = ppdb.df[&#39;ATOM&#39;][distances &lt; float(self.distance)]
            host_df = all_within_distance[&#34;atom_number&#34;]
            host_list = host_df.values.tolist()
            host_atom_list.append(host_list)
        host_atom_list = list(itertools.chain(*host_atom_list))
        host_atom_list = set(host_atom_list)
        host_atom_list = list(host_atom_list)
        host_atom_list.sort() 
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        df = ppdb.df[&#39;ATOM&#39;][[&#39;atom_number&#39;,&#39;residue_number&#39;,&#39;residue_name&#39;]]
        index_list = []
        for i in host_atom_list:
            indices = np.where(df[&#34;atom_number&#34;] == i)
            indices = list(indices)[0]
            indices = list(indices)
            index_list.append(indices)
        index_list = list(itertools.chain.from_iterable(index_list))
        df1 = df.iloc[index_list,] 
        resid_num = list(df1.residue_number.unique())
        np.savetxt(self.residue_list, resid_num)
        
    def get_host_qm_mm_atoms(self):  
        &#34;&#34;&#34;
        This function saves a list of atom numbers of the residues in the host molecule surrounding the guest within a certain mentioned distance from any of the atom in the guest molecule.
        &#34;&#34;&#34;
        resid_num = np.loadtxt(self.residue_list)
        #approximated_res_list = [int(i) for i in resid_num]
        approximated_res_list = []
        for i in range(int(statistics.median(resid_num)) - int(int(self.num_residues)/2), int(statistics.median(resid_num)) + int(int(self.num_residues)/2)):
            approximated_res_list.append(i)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        df = ppdb.df[&#39;ATOM&#39;][[&#39;atom_number&#39;,&#39;residue_number&#39;,&#39;residue_name&#39;]]
        host_index_nested_list = []
        for i in approximated_res_list:
            indices = np.where(df[&#34;residue_number&#34;] == i)
            indices = list(indices)[0]
            indices = list(indices)
            host_index_nested_list.append(indices)  
        host_index_list = list(itertools.chain.from_iterable(host_index_nested_list))
        df_atom = df.iloc[host_index_list] 
        df_atom_number = df_atom[&#39;atom_number&#39;]
        host_atom_list = df_atom_number.values.tolist()
        selected_atoms = []
        selected_atoms.extend(host_atom_list)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        len_atoms = []
        for i in range(len(ppdb.df[&#39;ATOM&#39;])):
            len_atoms.append(i+1)
        non_selected_atoms = list(set(len_atoms).difference(selected_atoms))
        if len(non_selected_atoms) + len(selected_atoms) == len(len_atoms):
            print(&#34;Sum of the selected and non-selected region equals the length of list of total atoms&#34;)
        else:
            print(&#34;Error&#34;)
        np.savetxt(self.host_qm_atoms, selected_atoms)  
        np.savetxt(self.host_mm_atoms, non_selected_atoms) 
        
    def save_host_pdbs(self):  
        &#34;&#34;&#34;
        This function saves a host pdb file of selected region and another host pdb file non-selected region. 
        &#34;&#34;&#34;
        selected_atoms = np.loadtxt(self.host_qm_atoms)
        selected_atoms = [int(i) for i in selected_atoms]
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        for i in selected_atoms:
            ppdb.df[&#39;ATOM&#39;] = ppdb.df[&#39;ATOM&#39;][ppdb.df[&#39;ATOM&#39;][&#39;atom_number&#39;] != i]
        ppdb.to_pdb(path = self.host_mm_pdb, records = None, gz = False, append_newline = True)
        non_selected_atoms = np.loadtxt(self.host_mm_atoms)
        non_selected_atoms = [int(i) for i in non_selected_atoms]
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        for i in non_selected_atoms:
            ppdb.df[&#39;ATOM&#39;] = ppdb.df[&#39;ATOM&#39;][ppdb.df[&#39;ATOM&#39;][&#39;atom_number&#39;] != i]
        ppdb.to_pdb(path = self.host_qm_pdb, records = None, gz = False, append_newline = True)

    def get_host_mm_region_atoms(self):  
        &#34;&#34;&#34;
        This function divides the host MM region into two sections, i.e. one preceding the QM region and one successing the QM region.
        &#34;&#34;&#34;
        resid_num = np.loadtxt(self.residue_list)
        approximated_res_list = []
        for i in range(int(statistics.median(resid_num)) - int(int(self.num_residues)/2), int(statistics.median(resid_num)) + int(int(self.num_residues)/2)):
            approximated_res_list.append(i)
        #print(approximated_res_list)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        df = ppdb.df[&#39;ATOM&#39;][[&#39;residue_number&#39;]]
        res_list = list(set(df[&#39;residue_number&#39;].to_list()))
        res_mm_list = list(set(res_list).difference(approximated_res_list))
        #print(res_mm_list)
        res_mm_region_I_list = []
        for i in res_mm_list:
            for j in approximated_res_list:
                if i &lt; j:
                    res_mm_region_I_list.append(i)
        res_mm_region_I_list = list(set(res_mm_region_I_list))
        #print(res_mm_region_I_list)
        res_mm_region_II_list = list(set(res_mm_list).difference(res_mm_region_I_list))
        #print(res_mm_region_II_list)
        ppdb.read_pdb(self.host_mm_pdb)
        df = ppdb.df[&#39;ATOM&#39;][[&#39;atom_number&#39;,&#39;residue_number&#39;,&#39;residue_name&#39;]]
        mm_region_I_index_nested_list = []
        for i in res_mm_region_I_list:
            indices = np.where(df[&#34;residue_number&#34;] == i)
            indices = list(indices)[0]
            indices = list(indices)
            mm_region_I_index_nested_list.append(indices)  
        mm_region_I_index_list = list(itertools.chain.from_iterable(mm_region_I_index_nested_list))
        df_atom = df.iloc[mm_region_I_index_list] 
        df_atom_number = df_atom[&#39;atom_number&#39;]
        mm_region_I_atom_list = df_atom_number.values.tolist()
        mm_region_I_atoms = []
        mm_region_I_atoms.extend(mm_region_I_atom_list)
        mm_region_II_index_nested_list = []
        for i in res_mm_region_II_list:
            indices = np.where(df[&#34;residue_number&#34;] == i)
            indices = list(indices)[0]
            indices = list(indices)
            mm_region_II_index_nested_list.append(indices)  
        mm_region_II_index_list = list(itertools.chain.from_iterable(mm_region_II_index_nested_list))
        df_atom = df.iloc[mm_region_II_index_list] 
        df_atom_number = df_atom[&#39;atom_number&#39;]
        mm_region_II_atom_list = df_atom_number.values.tolist()
        mm_region_II_atoms = []
        mm_region_II_atoms.extend(mm_region_II_atom_list)
        ppdb.read_pdb(self.host_mm_pdb)
        len_atoms = []
        for i in range(len(ppdb.df[&#39;ATOM&#39;])):
            len_atoms.append(i+1)
        if len(mm_region_I_atoms) + len(mm_region_II_atoms) == len(len_atoms):
            print(&#34;Sum of the MM region I atoms and  MM region II atoms equals the length of list of total MM atoms&#34;)
        else:
            print(&#34;Error&#34;)
        np.savetxt(self.host_mm_region_I_atoms, mm_region_I_atoms)  
        np.savetxt(self.host_mm_region_II_atoms, mm_region_II_atoms) 

    def save_host_mm_regions_pdbs(self):  
        &#34;&#34;&#34;
        This function saves two pdb files, one pdb preceding the QM region and one pdb file succeeding the QM region.
        &#34;&#34;&#34;
        mm_region_I_atoms = np.loadtxt(self.host_mm_region_I_atoms)
        mm_region_I_atoms = [int(i) for i in mm_region_I_atoms]
        mm_region_II_atoms = np.loadtxt(self.host_mm_region_II_atoms)
        mm_region_II_atoms = [int(i) for i in mm_region_II_atoms]
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_mm_pdb)
        for i in mm_region_II_atoms:
            ppdb.df[&#39;ATOM&#39;] = ppdb.df[&#39;ATOM&#39;][ppdb.df[&#39;ATOM&#39;][&#39;atom_number&#39;] != i]
        ppdb.to_pdb(path = self.host_mm_region_I_pdb, records = None, gz = False, append_newline = True)
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_mm_pdb)
        for i in mm_region_I_atoms:
            ppdb.df[&#39;ATOM&#39;] = ppdb.df[&#39;ATOM&#39;][ppdb.df[&#39;ATOM&#39;][&#39;atom_number&#39;] != i]
        ppdb.to_pdb(path = self.host_mm_region_II_pdb, records = None, gz = False, append_newline = True)        
        
    def get_qm_mm_regions(self):  
        &#34;&#34;&#34;
        This function saves a qm region comprising of the guest molecule and the selected atoms of the host molecule and a mm region comprising of the unselected atoms of the host molecule. When merging two pdb files, all lines beginning from &#34;ATOM&#34; will be selected and it would end with the &#34;END&#34;
        &#34;&#34;&#34;
        with open(self.host_qm_pdb) as f1, open(self.qm_pdb, &#39;w&#39;) as f2:
            for line in f1:
                if &#34;ATOM&#34; in line:
                    f2.write(line)  
        with open(self.guest_pdb) as f1, open(self.qm_pdb, &#39;a&#39;) as f2:
            for line in f1:
                if &#34;ATOM&#34; in line:
                    f2.write(line) 
        with open(self.qm_pdb, &#39;a&#39;) as f:
            f.write(&#34;END&#34;)
        with open(self.host_mm_pdb) as f1, open(self.mm_pdb, &#39;w&#39;) as f2:
            for line in f1:
                if &#34;ATOM&#34; in line:
                    f2.write(line)  
        with open(self.mm_pdb, &#39;a&#39;) as f:
            f.write(&#34;END&#34;)  </code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.PrepareQMMM.clean_up"><code class="name flex">
<span>def <span class="ident">clean_up</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function removes everything from the initial pdb file except the host and guest molecules from the system and saves a pdb file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_up(self):   
    &#34;&#34;&#34;
    This function removes everything from the initial pdb file except the host and guest molecules from the system and saves a pdb file.
    &#34;&#34;&#34;
    ions = [&#34;Na+&#34;, &#34;Cs+&#34;, &#34;K+&#34;,&#34;Li+&#34;, &#34;Rb+&#34;, &#34;Cl-&#34;, &#34;Br-&#34;, &#34;F-&#34;, &#34;I-&#34;, &#34;Ca2&#34;]
    intermediate_file_1 = self.cleaned_pdb[:-4] + &#34;_intermediate_1.pdb&#34;
    intermediate_file_2 = self.cleaned_pdb[:-4] + &#34;_intermediate_2.pdb&#34;
    command = &#34;pdb4amber -i &#34; + self.init_pdb + &#34; -o &#34; + intermediate_file_1 + &#34; --noter --dry&#34;
    os.system(command)
    to_delete = intermediate_file_1[:-4] + &#34;_nonprot.pdb&#34; , intermediate_file_1[:-4] + &#34;_renum.txt&#34;, intermediate_file_1[:-4] + &#34;_sslink&#34;, intermediate_file_1[:-4] + &#34;_water.pdb&#34;   
    os.system(&#34;rm -rf &#34; + to_delete[0] + &#34; &#34; + to_delete[1] + &#34; &#34; + to_delete[2] + &#34; &#34; + to_delete[3])  
    with open(intermediate_file_1) as f1, open(intermediate_file_2, &#39;w&#39;) as f2:
        for line in f1:
            if not any(ion in line for ion in ions):
                f2.write(line)                
    with open(intermediate_file_2, &#39;r&#39;) as f1 :
        filedata = f1.read()
    filedata = filedata.replace(&#39;HETATM&#39;, &#39;ATOM  &#39;)
    with open(self.cleaned_pdb, &#39;w&#39;) as f2:
        f2.write(filedata)
    command = &#34;rm -rf &#34; + intermediate_file_1 + &#34; &#34; + intermediate_file_2
    os.system(command)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareQMMM.create_host_guest"><code class="name flex">
<span>def <span class="ident">create_host_guest</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function creates separate host and guest pdb files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_host_guest(self):   
    &#34;&#34;&#34;
    This function creates separate host and guest pdb files.
    &#34;&#34;&#34;
    with open(self.cleaned_pdb) as f1, open(self.host_pdb, &#39;w&#39;) as f2:
        for line in f1:
            if not self.guest_resname in line and not &#34;CRYST1&#34; in line:
                f2.write(line)           
    with open(self.cleaned_pdb) as f1, open(self.guest_init_pdb, &#39;w&#39;) as f2:
        for line in f1:
            if self.guest_resname in line or &#34;END&#34; in line:
                f2.write(line)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareQMMM.get_guest_coord"><code class="name flex">
<span>def <span class="ident">get_guest_coord</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves a list of xyz coordinates from the pdb file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_guest_coord(self):   
    &#34;&#34;&#34;
    This function saves a list of xyz coordinates from the pdb file.
    &#34;&#34;&#34;
    ppdb = PandasPdb()
    ppdb.read_pdb(self.guest_pdb)
    xyz = ppdb.df[&#39;ATOM&#39;][[&#34;x_coord&#34;,&#34;y_coord&#34;,&#34;z_coord&#34;]]
    xyz_to_list = xyz.values.tolist()
    np.savetxt(self.guest_xyz, xyz_to_list)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareQMMM.get_host_mm_region_atoms"><code class="name flex">
<span>def <span class="ident">get_host_mm_region_atoms</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function divides the host MM region into two sections, i.e. one preceding the QM region and one successing the QM region.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_host_mm_region_atoms(self):  
    &#34;&#34;&#34;
    This function divides the host MM region into two sections, i.e. one preceding the QM region and one successing the QM region.
    &#34;&#34;&#34;
    resid_num = np.loadtxt(self.residue_list)
    approximated_res_list = []
    for i in range(int(statistics.median(resid_num)) - int(int(self.num_residues)/2), int(statistics.median(resid_num)) + int(int(self.num_residues)/2)):
        approximated_res_list.append(i)
    #print(approximated_res_list)
    ppdb = PandasPdb()
    ppdb.read_pdb(self.host_pdb)
    df = ppdb.df[&#39;ATOM&#39;][[&#39;residue_number&#39;]]
    res_list = list(set(df[&#39;residue_number&#39;].to_list()))
    res_mm_list = list(set(res_list).difference(approximated_res_list))
    #print(res_mm_list)
    res_mm_region_I_list = []
    for i in res_mm_list:
        for j in approximated_res_list:
            if i &lt; j:
                res_mm_region_I_list.append(i)
    res_mm_region_I_list = list(set(res_mm_region_I_list))
    #print(res_mm_region_I_list)
    res_mm_region_II_list = list(set(res_mm_list).difference(res_mm_region_I_list))
    #print(res_mm_region_II_list)
    ppdb.read_pdb(self.host_mm_pdb)
    df = ppdb.df[&#39;ATOM&#39;][[&#39;atom_number&#39;,&#39;residue_number&#39;,&#39;residue_name&#39;]]
    mm_region_I_index_nested_list = []
    for i in res_mm_region_I_list:
        indices = np.where(df[&#34;residue_number&#34;] == i)
        indices = list(indices)[0]
        indices = list(indices)
        mm_region_I_index_nested_list.append(indices)  
    mm_region_I_index_list = list(itertools.chain.from_iterable(mm_region_I_index_nested_list))
    df_atom = df.iloc[mm_region_I_index_list] 
    df_atom_number = df_atom[&#39;atom_number&#39;]
    mm_region_I_atom_list = df_atom_number.values.tolist()
    mm_region_I_atoms = []
    mm_region_I_atoms.extend(mm_region_I_atom_list)
    mm_region_II_index_nested_list = []
    for i in res_mm_region_II_list:
        indices = np.where(df[&#34;residue_number&#34;] == i)
        indices = list(indices)[0]
        indices = list(indices)
        mm_region_II_index_nested_list.append(indices)  
    mm_region_II_index_list = list(itertools.chain.from_iterable(mm_region_II_index_nested_list))
    df_atom = df.iloc[mm_region_II_index_list] 
    df_atom_number = df_atom[&#39;atom_number&#39;]
    mm_region_II_atom_list = df_atom_number.values.tolist()
    mm_region_II_atoms = []
    mm_region_II_atoms.extend(mm_region_II_atom_list)
    ppdb.read_pdb(self.host_mm_pdb)
    len_atoms = []
    for i in range(len(ppdb.df[&#39;ATOM&#39;])):
        len_atoms.append(i+1)
    if len(mm_region_I_atoms) + len(mm_region_II_atoms) == len(len_atoms):
        print(&#34;Sum of the MM region I atoms and  MM region II atoms equals the length of list of total MM atoms&#34;)
    else:
        print(&#34;Error&#34;)
    np.savetxt(self.host_mm_region_I_atoms, mm_region_I_atoms)  
    np.savetxt(self.host_mm_region_II_atoms, mm_region_II_atoms) </code></pre>
</details>
</dd>
<dt id="parameterize.PrepareQMMM.get_host_qm_mm_atoms"><code class="name flex">
<span>def <span class="ident">get_host_qm_mm_atoms</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves a list of atom numbers of the residues in the host molecule surrounding the guest within a certain mentioned distance from any of the atom in the guest molecule.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_host_qm_mm_atoms(self):  
    &#34;&#34;&#34;
    This function saves a list of atom numbers of the residues in the host molecule surrounding the guest within a certain mentioned distance from any of the atom in the guest molecule.
    &#34;&#34;&#34;
    resid_num = np.loadtxt(self.residue_list)
    #approximated_res_list = [int(i) for i in resid_num]
    approximated_res_list = []
    for i in range(int(statistics.median(resid_num)) - int(int(self.num_residues)/2), int(statistics.median(resid_num)) + int(int(self.num_residues)/2)):
        approximated_res_list.append(i)
    ppdb = PandasPdb()
    ppdb.read_pdb(self.host_pdb)
    df = ppdb.df[&#39;ATOM&#39;][[&#39;atom_number&#39;,&#39;residue_number&#39;,&#39;residue_name&#39;]]
    host_index_nested_list = []
    for i in approximated_res_list:
        indices = np.where(df[&#34;residue_number&#34;] == i)
        indices = list(indices)[0]
        indices = list(indices)
        host_index_nested_list.append(indices)  
    host_index_list = list(itertools.chain.from_iterable(host_index_nested_list))
    df_atom = df.iloc[host_index_list] 
    df_atom_number = df_atom[&#39;atom_number&#39;]
    host_atom_list = df_atom_number.values.tolist()
    selected_atoms = []
    selected_atoms.extend(host_atom_list)
    ppdb = PandasPdb()
    ppdb.read_pdb(self.host_pdb)
    len_atoms = []
    for i in range(len(ppdb.df[&#39;ATOM&#39;])):
        len_atoms.append(i+1)
    non_selected_atoms = list(set(len_atoms).difference(selected_atoms))
    if len(non_selected_atoms) + len(selected_atoms) == len(len_atoms):
        print(&#34;Sum of the selected and non-selected region equals the length of list of total atoms&#34;)
    else:
        print(&#34;Error&#34;)
    np.savetxt(self.host_qm_atoms, selected_atoms)  
    np.savetxt(self.host_mm_atoms, non_selected_atoms) </code></pre>
</details>
</dd>
<dt id="parameterize.PrepareQMMM.get_qm_mm_regions"><code class="name flex">
<span>def <span class="ident">get_qm_mm_regions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves a qm region comprising of the guest molecule and the selected atoms of the host molecule and a mm region comprising of the unselected atoms of the host molecule. When merging two pdb files, all lines beginning from "ATOM" will be selected and it would end with the "END"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_qm_mm_regions(self):  
    &#34;&#34;&#34;
    This function saves a qm region comprising of the guest molecule and the selected atoms of the host molecule and a mm region comprising of the unselected atoms of the host molecule. When merging two pdb files, all lines beginning from &#34;ATOM&#34; will be selected and it would end with the &#34;END&#34;
    &#34;&#34;&#34;
    with open(self.host_qm_pdb) as f1, open(self.qm_pdb, &#39;w&#39;) as f2:
        for line in f1:
            if &#34;ATOM&#34; in line:
                f2.write(line)  
    with open(self.guest_pdb) as f1, open(self.qm_pdb, &#39;a&#39;) as f2:
        for line in f1:
            if &#34;ATOM&#34; in line:
                f2.write(line) 
    with open(self.qm_pdb, &#39;a&#39;) as f:
        f.write(&#34;END&#34;)
    with open(self.host_mm_pdb) as f1, open(self.mm_pdb, &#39;w&#39;) as f2:
        for line in f1:
            if &#34;ATOM&#34; in line:
                f2.write(line)  
    with open(self.mm_pdb, &#39;a&#39;) as f:
        f.write(&#34;END&#34;)  </code></pre>
</details>
</dd>
<dt id="parameterize.PrepareQMMM.get_qm_resids"><code class="name flex">
<span>def <span class="ident">get_qm_resids</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves a list of residue numbers of the residues in the host molecule surrounding the guest within a mentioned distance from any of the atom in the guest molecule.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_qm_resids(self):  
    &#34;&#34;&#34;
    This function saves a list of residue numbers of the residues in the host molecule surrounding the guest within a mentioned distance from any of the atom in the guest molecule.
    &#34;&#34;&#34;
    guest_coord_list = np.loadtxt(self.guest_xyz)
    host_atom_list = []
    for i in range(len(guest_coord_list)):
        reference_point = guest_coord_list[i]
        ppdb = PandasPdb()
        ppdb.read_pdb(self.host_pdb)
        distances = ppdb.distance(xyz=reference_point, records=(&#39;ATOM&#39;))
        all_within_distance = ppdb.df[&#39;ATOM&#39;][distances &lt; float(self.distance)]
        host_df = all_within_distance[&#34;atom_number&#34;]
        host_list = host_df.values.tolist()
        host_atom_list.append(host_list)
    host_atom_list = list(itertools.chain(*host_atom_list))
    host_atom_list = set(host_atom_list)
    host_atom_list = list(host_atom_list)
    host_atom_list.sort() 
    ppdb = PandasPdb()
    ppdb.read_pdb(self.host_pdb)
    df = ppdb.df[&#39;ATOM&#39;][[&#39;atom_number&#39;,&#39;residue_number&#39;,&#39;residue_name&#39;]]
    index_list = []
    for i in host_atom_list:
        indices = np.where(df[&#34;atom_number&#34;] == i)
        indices = list(indices)[0]
        indices = list(indices)
        index_list.append(indices)
    index_list = list(itertools.chain.from_iterable(index_list))
    df1 = df.iloc[index_list,] 
    resid_num = list(df1.residue_number.unique())
    np.savetxt(self.residue_list, resid_num)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareQMMM.realign_guest"><code class="name flex">
<span>def <span class="ident">realign_guest</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function realigns the atom numbers in the initial guest pdb file given the assumption that the original pdb file had the host molecule followed by the guest molecule.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def realign_guest(self):   
    &#34;&#34;&#34;
    This function realigns the atom numbers in the initial guest pdb file given the assumption that the original pdb file had the host molecule followed by the guest molecule.
    &#34;&#34;&#34;
    ppdb = PandasPdb()
    ppdb.read_pdb(self.guest_init_pdb)
    to_substract = min(ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;]) - 1 
    ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] = ppdb.df[&#34;ATOM&#34;][&#34;atom_number&#34;] - to_substract
    intermediate_file_1 = self.guest_pdb[:-4] + &#34;_intermediate_1.pdb&#34;
    intermediate_file_2 = self.guest_pdb[:-4] + &#34;_intermediate_2.pdb&#34;
    ppdb.to_pdb(path = intermediate_file_1)
    command = &#34;pdb4amber -i &#34; + intermediate_file_1 +  &#34; -o &#34; + intermediate_file_2
    os.system(command)
    to_delete = intermediate_file_2[:-4] + &#34;_nonprot.pdb&#34; , intermediate_file_2[:-4] + &#34;_renum.txt&#34;, intermediate_file_2[:-4] + &#34;_sslink&#34;
    os.system(&#34;rm -rf &#34; + to_delete[0] + &#34; &#34; + to_delete[1] + &#34; &#34; + to_delete[2])  
    with open(intermediate_file_2, &#39;r&#39;) as f1 :
        filedata = f1.read()
    filedata = filedata.replace(&#39;HETATM&#39;, &#39;ATOM  &#39;)
    with open(self.guest_pdb, &#39;w&#39;) as f2:
        f2.write(filedata)
    command = &#34;rm -rf &#34; + intermediate_file_1 + &#34; &#34; + intermediate_file_2
    os.system(command)</code></pre>
</details>
</dd>
<dt id="parameterize.PrepareQMMM.save_host_mm_regions_pdbs"><code class="name flex">
<span>def <span class="ident">save_host_mm_regions_pdbs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves two pdb files, one pdb preceding the QM region and one pdb file succeeding the QM region.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_host_mm_regions_pdbs(self):  
    &#34;&#34;&#34;
    This function saves two pdb files, one pdb preceding the QM region and one pdb file succeeding the QM region.
    &#34;&#34;&#34;
    mm_region_I_atoms = np.loadtxt(self.host_mm_region_I_atoms)
    mm_region_I_atoms = [int(i) for i in mm_region_I_atoms]
    mm_region_II_atoms = np.loadtxt(self.host_mm_region_II_atoms)
    mm_region_II_atoms = [int(i) for i in mm_region_II_atoms]
    ppdb = PandasPdb()
    ppdb.read_pdb(self.host_mm_pdb)
    for i in mm_region_II_atoms:
        ppdb.df[&#39;ATOM&#39;] = ppdb.df[&#39;ATOM&#39;][ppdb.df[&#39;ATOM&#39;][&#39;atom_number&#39;] != i]
    ppdb.to_pdb(path = self.host_mm_region_I_pdb, records = None, gz = False, append_newline = True)
    ppdb = PandasPdb()
    ppdb.read_pdb(self.host_mm_pdb)
    for i in mm_region_I_atoms:
        ppdb.df[&#39;ATOM&#39;] = ppdb.df[&#39;ATOM&#39;][ppdb.df[&#39;ATOM&#39;][&#39;atom_number&#39;] != i]
    ppdb.to_pdb(path = self.host_mm_region_II_pdb, records = None, gz = False, append_newline = True)        </code></pre>
</details>
</dd>
<dt id="parameterize.PrepareQMMM.save_host_pdbs"><code class="name flex">
<span>def <span class="ident">save_host_pdbs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves a host pdb file of selected region and another host pdb file non-selected region.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_host_pdbs(self):  
    &#34;&#34;&#34;
    This function saves a host pdb file of selected region and another host pdb file non-selected region. 
    &#34;&#34;&#34;
    selected_atoms = np.loadtxt(self.host_qm_atoms)
    selected_atoms = [int(i) for i in selected_atoms]
    ppdb = PandasPdb()
    ppdb.read_pdb(self.host_pdb)
    for i in selected_atoms:
        ppdb.df[&#39;ATOM&#39;] = ppdb.df[&#39;ATOM&#39;][ppdb.df[&#39;ATOM&#39;][&#39;atom_number&#39;] != i]
    ppdb.to_pdb(path = self.host_mm_pdb, records = None, gz = False, append_newline = True)
    non_selected_atoms = np.loadtxt(self.host_mm_atoms)
    non_selected_atoms = [int(i) for i in non_selected_atoms]
    ppdb = PandasPdb()
    ppdb.read_pdb(self.host_pdb)
    for i in non_selected_atoms:
        ppdb.df[&#39;ATOM&#39;] = ppdb.df[&#39;ATOM&#39;][ppdb.df[&#39;ATOM&#39;][&#39;atom_number&#39;] != i]
    ppdb.to_pdb(path = self.host_qm_pdb, records = None, gz = False, append_newline = True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.RunOpenMMSims"><code class="flex name class">
<span>class <span class="ident">RunOpenMMSims</span></span>
<span>(</span><span>system_prmtop, system_inpcrd, system_pdb, system_output='sim_output.pdb', sim_steps=1000)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RunOpenMMSims:

    def __init__(self, system_prmtop, system_inpcrd, system_pdb, system_output =  &#34;sim_output.pdb&#34;, sim_steps = 1000):   
        self.system_prmtop = system_prmtop
        self.system_inpcrd = system_inpcrd
        self.system_pdb = system_pdb
        self.system_output = system_output
        self.sim_steps = sim_steps

    def run_openmm_prmtop_inpcrd(self):
        print(&#34;Running OpenMM simulation for &#34; +  self.system_prmtop + &#34; and &#34; + self.system_inpcrd)
        prmtop = simtk.openmm.app.AmberPrmtopFile(self.system_prmtop)
        inpcrd = simtk.openmm.app.AmberInpcrdFile(self.system_inpcrd)
        system = prmtop.createSystem()
        integrator = simtk.openmm.LangevinIntegrator(300 * simtk.unit.kelvin, 1 / simtk.unit.picosecond, 0.002 * simtk.unit.picoseconds)
        simulation = simtk.openmm.app.Simulation(prmtop.topology, system, integrator)
        simulation.context.setPositions(inpcrd.positions)
        if inpcrd.boxVectors is not None:
            simulation.context.setPeriodicBoxVectors(*inpcrd.boxVectors)
        simulation.minimizeEnergy()
        simulation.reporters.append(simtk.openmm.app.PDBReporter(self.system_output, self.sim_steps/10))
        simulation.reporters.append(simtk.openmm.app.StateDataReporter(stdout, reportInterval = int(self.sim_steps/10), step = True, potentialEnergy = True, temperature = True))  
        simulation.step(self.sim_steps)
        command = &#34;rm -rf &#34; + self.system_output
        os.system(command) 

    def run_openmm_prmtop_pdb(self):
        print(&#34;Running OpenMM simulation for &#34; +  self.system_prmtop + &#34; and &#34; + self.system_pdb)
        pdb = simtk.openmm.app.PDBFile(self.system_pdb)
        prmtop = simtk.openmm.app.AmberPrmtopFile(self.system_prmtop)
        system = prmtop.createSystem()
        integrator = simtk.openmm.LangevinIntegrator(300 * simtk.unit.kelvin, 1/simtk.unit.picosecond, 0.002 * simtk.unit.picoseconds)
        simulation = simtk.openmm.app.Simulation(prmtop.topology, system, integrator)
        simulation.context.setPositions(pdb.positions)
        simulation.minimizeEnergy()
        simulation.reporters.append(simtk.openmm.app.PDBReporter(self.system_output, self.sim_steps/10))
        simulation.reporters.append(simtk.openmm.app.StateDataReporter(stdout, reportInterval = int(self.sim_steps/10), step = True, potentialEnergy = True, temperature = True))  
        simulation.step(self.sim_steps)
        command = &#34;rm -rf &#34; + self.system_output
        os.system(command)  </code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.RunOpenMMSims.run_openmm_prmtop_inpcrd"><code class="name flex">
<span>def <span class="ident">run_openmm_prmtop_inpcrd</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_openmm_prmtop_inpcrd(self):
    print(&#34;Running OpenMM simulation for &#34; +  self.system_prmtop + &#34; and &#34; + self.system_inpcrd)
    prmtop = simtk.openmm.app.AmberPrmtopFile(self.system_prmtop)
    inpcrd = simtk.openmm.app.AmberInpcrdFile(self.system_inpcrd)
    system = prmtop.createSystem()
    integrator = simtk.openmm.LangevinIntegrator(300 * simtk.unit.kelvin, 1 / simtk.unit.picosecond, 0.002 * simtk.unit.picoseconds)
    simulation = simtk.openmm.app.Simulation(prmtop.topology, system, integrator)
    simulation.context.setPositions(inpcrd.positions)
    if inpcrd.boxVectors is not None:
        simulation.context.setPeriodicBoxVectors(*inpcrd.boxVectors)
    simulation.minimizeEnergy()
    simulation.reporters.append(simtk.openmm.app.PDBReporter(self.system_output, self.sim_steps/10))
    simulation.reporters.append(simtk.openmm.app.StateDataReporter(stdout, reportInterval = int(self.sim_steps/10), step = True, potentialEnergy = True, temperature = True))  
    simulation.step(self.sim_steps)
    command = &#34;rm -rf &#34; + self.system_output
    os.system(command) </code></pre>
</details>
</dd>
<dt id="parameterize.RunOpenMMSims.run_openmm_prmtop_pdb"><code class="name flex">
<span>def <span class="ident">run_openmm_prmtop_pdb</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_openmm_prmtop_pdb(self):
    print(&#34;Running OpenMM simulation for &#34; +  self.system_prmtop + &#34; and &#34; + self.system_pdb)
    pdb = simtk.openmm.app.PDBFile(self.system_pdb)
    prmtop = simtk.openmm.app.AmberPrmtopFile(self.system_prmtop)
    system = prmtop.createSystem()
    integrator = simtk.openmm.LangevinIntegrator(300 * simtk.unit.kelvin, 1/simtk.unit.picosecond, 0.002 * simtk.unit.picoseconds)
    simulation = simtk.openmm.app.Simulation(prmtop.topology, system, integrator)
    simulation.context.setPositions(pdb.positions)
    simulation.minimizeEnergy()
    simulation.reporters.append(simtk.openmm.app.PDBReporter(self.system_output, self.sim_steps/10))
    simulation.reporters.append(simtk.openmm.app.StateDataReporter(stdout, reportInterval = int(self.sim_steps/10), step = True, potentialEnergy = True, temperature = True))  
    simulation.step(self.sim_steps)
    command = &#34;rm -rf &#34; + self.system_output
    os.system(command)  </code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.TorsionDriveParams"><code class="flex name class">
<span>class <span class="ident">TorsionDriveParams</span></span>
<span>(</span><span>num_charge_atoms, index_charge_atom_1, charge_atom_1, tor_dir='torsion_dir', reparameterized_torsional_params_file='reparameterized_torsional_params.txt', psi_input_file='torsion_drive_input.dat', xyz_file='torsion_drive_input.xyz', coords_file='torsion_drive_input.txt', template_pdb='guest_init_II.pdb', system_pdb='torsion_drive_input.pdb', system_sdf='torsion_drive_input.sdf', system_xml='torsion_drive_input.xml', qm_scan_file='scan.xyz', load_topology='openmm', method='L-BFGS-B', dihedral_text_file='dihedrals.txt', system_init_sdf='torsion_drive_input_init.sdf', reparameterised_system_xml_file='guest_reparameterised.xml', reparameterised_torsional_system_xml_file='guest_torsional_reparameterized.xml')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TorsionDriveParams:

    def __init__(self, num_charge_atoms, index_charge_atom_1, charge_atom_1, tor_dir = &#34;torsion_dir&#34;, reparameterized_torsional_params_file = &#34;reparameterized_torsional_params.txt&#34;, psi_input_file = &#34;torsion_drive_input.dat&#34;, xyz_file = &#34;torsion_drive_input.xyz&#34;, coords_file = &#34;torsion_drive_input.txt&#34;, template_pdb = &#34;guest_init_II.pdb&#34;, system_pdb = &#34;torsion_drive_input.pdb&#34;, system_sdf = &#34;torsion_drive_input.sdf&#34;, system_xml = &#34;torsion_drive_input.xml&#34;, qm_scan_file = &#34;scan.xyz&#34;, load_topology = &#34;openmm&#34;, method = &#34;L-BFGS-B&#34;, dihedral_text_file = &#34;dihedrals.txt&#34;, system_init_sdf = &#34;torsion_drive_input_init.sdf&#34;, reparameterised_system_xml_file = &#34;guest_reparameterised.xml&#34;, reparameterised_torsional_system_xml_file = &#34;guest_torsional_reparameterized.xml&#34;):  
        self.num_charge_atoms = num_charge_atoms
        self.index_charge_atom_1 = index_charge_atom_1
        self.charge_atom_1 = charge_atom_1
        self.tor_dir = tor_dir
        self.reparameterized_torsional_params_file = reparameterized_torsional_params_file
        self.psi_input_file = psi_input_file
        self.xyz_file = xyz_file
        self.coords_file = coords_file
        self.template_pdb = template_pdb
        self.system_pdb = system_pdb
        self.system_sdf = system_sdf
        self.system_xml = system_xml
        self.qm_scan_file = qm_scan_file
        self.method = method
        self.dihedral_text_file = dihedral_text_file
        self.system_init_sdf = system_init_sdf
        self.load_topology = load_topology
        self.reparameterised_system_xml_file = reparameterised_system_xml_file
        self.reparameterised_torsional_system_xml_file = reparameterised_torsional_system_xml_file

    def write_reparams_torsion_lines(self):
        torsional_parameters_list = []
        parent_cwd = os.getcwd()
        target_dir = parent_cwd + &#34;/&#34; + self.tor_dir
        for i in os.listdir(target_dir):
            os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + i)
            print(&#34;Entering directory&#34; + &#34; : &#34;  + os.getcwd())
            torsiondrive_input_to_xyz(psi_input_file = self.psi_input_file, xyz_file = self.xyz_file)
            xyz_to_pdb(xyz_file = self.xyz_file, coords_file = self.coords_file, template_pdb = self.template_pdb, system_pdb = self.system_pdb)
            generate_xml_from_charged_pdb_sdf(system_pdb = self.system_pdb, system_init_sdf = system_init_sdf, system_sdf = self.system_sdf, num_charge_atoms = num_charge_atoms, index_charge_atom_1 = index_charge_atom_1, charge_atom_1 = charge_atom_1, system_xml = self.system_xml) 
            torsional_lines = get_torsional_lines(template_pdb = self.template_pdb, system_xml = self.system_xml, qm_scan_file = self.qm_scan_file, load_topology = self.load_topology,  method = self.method, dihedral_text_file = self.dihedral_text_file)
            #print(torsional_lines)
            torsional_parameters_list.append(torsional_lines)
            remove_mm_files(qm_scan_file = self.qm_scan_file)
            os.chdir(parent_cwd)  
        torsional_parameters = [item for sublist in torsional_parameters_list for item in sublist]
        with open(self.reparameterized_torsional_params_file, &#34;w&#34;) as f: 
            for i in torsional_parameters:
                f.write(i + &#34;\n&#34;) 

    def write_reparams_torsion_lines_charged(self):
        torsional_parameters_list = []
        parent_cwd = os.getcwd()
        target_dir = parent_cwd + &#34;/&#34; + self.tor_dir
        for i in os.listdir(target_dir):
            os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + i)
            print(&#34;Entering directory&#34; + &#34; : &#34;  + os.getcwd())
            torsiondrive_input_to_xyz(psi_input_file = self.psi_input_file, xyz_file = self.xyz_file)
            xyz_to_pdb(xyz_file = self.xyz_file, coords_file = self.coords_file, template_pdb = self.template_pdb, system_pdb = self.system_pdb)
            generate_xml_from_charged_pdb_sdf(system_pdb = self.system_pdb, system_init_sdf = self.system_init_sdf, system_sdf = self.system_sdf, num_charge_atoms = self.num_charge_atoms, index_charge_atom_1 = self.index_charge_atom_1, charge_atom_1 = self.charge_atom_1, system_xml = self.system_xml) 
            torsional_lines = get_torsional_lines(template_pdb = self.template_pdb, system_xml = self.system_xml, qm_scan_file = self.qm_scan_file, load_topology = self.load_topology,  method = self.method, dihedral_text_file = self.dihedral_text_file)
            #print(torsional_lines)
            torsional_parameters_list.append(torsional_lines)
            remove_mm_files(qm_scan_file = self.qm_scan_file)
            os.chdir(parent_cwd)  
        torsional_parameters = [item for sublist in torsional_parameters_list for item in sublist]
        with open(self.reparameterized_torsional_params_file, &#34;w&#34;) as f: 
            for i in torsional_parameters:
                f.write(i + &#34;\n&#34;) 

    def write_torsional_reparams(self):
        xml_tor = open(self.reparameterized_torsional_params_file, &#39;r&#39;) 
        xml_tor_lines = xml_tor.readlines() 
        non_zero_k_tor = []
        for i in xml_tor_lines:
            to_find = &#34;k=&#34; + &#39;&#34;&#39; + &#34;0.0&#34; + &#39;&#34;&#39; 
            if to_find not in i:
                non_zero_k_tor.append(i)
        #print(non_zero_k_tor)
        p1 = []
        for i in range(len(non_zero_k_tor)):
            p1.append(int(re.findall(&#39;\d*\.?\d+&#39;,non_zero_k_tor[i])[2]))
        #print(p1)
        p2 = []
        for i in range(len(non_zero_k_tor)):
            p2.append(int(re.findall(&#39;\d*\.?\d+&#39;,non_zero_k_tor[i])[4]))
        #print(p2)
        p3 = []
        for i in range(len(non_zero_k_tor)):
            p3.append(int(re.findall(&#39;\d*\.?\d+&#39;,non_zero_k_tor[i])[6]))
        #print(p3)
        p4 = []
        for i in range(len(non_zero_k_tor)):
            p4.append(int(re.findall(&#39;\d*\.?\d+&#39;,non_zero_k_tor[i])[8]))
        #print(p4)
        periodicity = []
        for i in range(len(non_zero_k_tor)):
            periodicity.append(int(re.findall(&#39;\d*\.?\d+&#39;,non_zero_k_tor[i])[9]))
        #print(periodicity)
        xml_tor_reparams = open(self.reparameterised_system_xml_file, &#39;r&#39;) 
        xml_tor_reparams_lines = xml_tor_reparams.readlines() 
        for j in range(len(xml_tor_reparams_lines)):
            for i in range(len(non_zero_k_tor)):
                to_find_tor = &#34;p1=&#34; + &#39;&#34;&#39; + str(p1[i]) + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + str(p2[i]) + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + str(p3[i]) + &#39;&#34;&#39; + &#34; &#34; + &#34;p4=&#34; + &#39;&#34;&#39; + str(p4[i]) + &#39;&#34;&#39; + &#34; &#34; + &#34;periodicity=&#34; + &#39;&#34;&#39; + str(periodicity[i]) + &#39;&#34;&#39; 
                if to_find_tor in xml_tor_reparams_lines[j]:
                    #print(xml_tor_reparams_lines[j])
                    xml_tor_reparams_lines[j] = non_zero_k_tor[i]    
        with open(self.reparameterised_torsional_system_xml_file, &#39;w&#39;) as f:
            for i in xml_tor_reparams_lines:
                f.write(i)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.TorsionDriveParams.write_reparams_torsion_lines"><code class="name flex">
<span>def <span class="ident">write_reparams_torsion_lines</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_reparams_torsion_lines(self):
    torsional_parameters_list = []
    parent_cwd = os.getcwd()
    target_dir = parent_cwd + &#34;/&#34; + self.tor_dir
    for i in os.listdir(target_dir):
        os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + i)
        print(&#34;Entering directory&#34; + &#34; : &#34;  + os.getcwd())
        torsiondrive_input_to_xyz(psi_input_file = self.psi_input_file, xyz_file = self.xyz_file)
        xyz_to_pdb(xyz_file = self.xyz_file, coords_file = self.coords_file, template_pdb = self.template_pdb, system_pdb = self.system_pdb)
        generate_xml_from_charged_pdb_sdf(system_pdb = self.system_pdb, system_init_sdf = system_init_sdf, system_sdf = self.system_sdf, num_charge_atoms = num_charge_atoms, index_charge_atom_1 = index_charge_atom_1, charge_atom_1 = charge_atom_1, system_xml = self.system_xml) 
        torsional_lines = get_torsional_lines(template_pdb = self.template_pdb, system_xml = self.system_xml, qm_scan_file = self.qm_scan_file, load_topology = self.load_topology,  method = self.method, dihedral_text_file = self.dihedral_text_file)
        #print(torsional_lines)
        torsional_parameters_list.append(torsional_lines)
        remove_mm_files(qm_scan_file = self.qm_scan_file)
        os.chdir(parent_cwd)  
    torsional_parameters = [item for sublist in torsional_parameters_list for item in sublist]
    with open(self.reparameterized_torsional_params_file, &#34;w&#34;) as f: 
        for i in torsional_parameters:
            f.write(i + &#34;\n&#34;) </code></pre>
</details>
</dd>
<dt id="parameterize.TorsionDriveParams.write_reparams_torsion_lines_charged"><code class="name flex">
<span>def <span class="ident">write_reparams_torsion_lines_charged</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_reparams_torsion_lines_charged(self):
    torsional_parameters_list = []
    parent_cwd = os.getcwd()
    target_dir = parent_cwd + &#34;/&#34; + self.tor_dir
    for i in os.listdir(target_dir):
        os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + i)
        print(&#34;Entering directory&#34; + &#34; : &#34;  + os.getcwd())
        torsiondrive_input_to_xyz(psi_input_file = self.psi_input_file, xyz_file = self.xyz_file)
        xyz_to_pdb(xyz_file = self.xyz_file, coords_file = self.coords_file, template_pdb = self.template_pdb, system_pdb = self.system_pdb)
        generate_xml_from_charged_pdb_sdf(system_pdb = self.system_pdb, system_init_sdf = self.system_init_sdf, system_sdf = self.system_sdf, num_charge_atoms = self.num_charge_atoms, index_charge_atom_1 = self.index_charge_atom_1, charge_atom_1 = self.charge_atom_1, system_xml = self.system_xml) 
        torsional_lines = get_torsional_lines(template_pdb = self.template_pdb, system_xml = self.system_xml, qm_scan_file = self.qm_scan_file, load_topology = self.load_topology,  method = self.method, dihedral_text_file = self.dihedral_text_file)
        #print(torsional_lines)
        torsional_parameters_list.append(torsional_lines)
        remove_mm_files(qm_scan_file = self.qm_scan_file)
        os.chdir(parent_cwd)  
    torsional_parameters = [item for sublist in torsional_parameters_list for item in sublist]
    with open(self.reparameterized_torsional_params_file, &#34;w&#34;) as f: 
        for i in torsional_parameters:
            f.write(i + &#34;\n&#34;) </code></pre>
</details>
</dd>
<dt id="parameterize.TorsionDriveParams.write_torsional_reparams"><code class="name flex">
<span>def <span class="ident">write_torsional_reparams</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_torsional_reparams(self):
    xml_tor = open(self.reparameterized_torsional_params_file, &#39;r&#39;) 
    xml_tor_lines = xml_tor.readlines() 
    non_zero_k_tor = []
    for i in xml_tor_lines:
        to_find = &#34;k=&#34; + &#39;&#34;&#39; + &#34;0.0&#34; + &#39;&#34;&#39; 
        if to_find not in i:
            non_zero_k_tor.append(i)
    #print(non_zero_k_tor)
    p1 = []
    for i in range(len(non_zero_k_tor)):
        p1.append(int(re.findall(&#39;\d*\.?\d+&#39;,non_zero_k_tor[i])[2]))
    #print(p1)
    p2 = []
    for i in range(len(non_zero_k_tor)):
        p2.append(int(re.findall(&#39;\d*\.?\d+&#39;,non_zero_k_tor[i])[4]))
    #print(p2)
    p3 = []
    for i in range(len(non_zero_k_tor)):
        p3.append(int(re.findall(&#39;\d*\.?\d+&#39;,non_zero_k_tor[i])[6]))
    #print(p3)
    p4 = []
    for i in range(len(non_zero_k_tor)):
        p4.append(int(re.findall(&#39;\d*\.?\d+&#39;,non_zero_k_tor[i])[8]))
    #print(p4)
    periodicity = []
    for i in range(len(non_zero_k_tor)):
        periodicity.append(int(re.findall(&#39;\d*\.?\d+&#39;,non_zero_k_tor[i])[9]))
    #print(periodicity)
    xml_tor_reparams = open(self.reparameterised_system_xml_file, &#39;r&#39;) 
    xml_tor_reparams_lines = xml_tor_reparams.readlines() 
    for j in range(len(xml_tor_reparams_lines)):
        for i in range(len(non_zero_k_tor)):
            to_find_tor = &#34;p1=&#34; + &#39;&#34;&#39; + str(p1[i]) + &#39;&#34;&#39; + &#34; &#34; + &#34;p2=&#34; + &#39;&#34;&#39; + str(p2[i]) + &#39;&#34;&#39; + &#34; &#34; + &#34;p3=&#34; + &#39;&#34;&#39; + str(p3[i]) + &#39;&#34;&#39; + &#34; &#34; + &#34;p4=&#34; + &#39;&#34;&#39; + str(p4[i]) + &#39;&#34;&#39; + &#34; &#34; + &#34;periodicity=&#34; + &#39;&#34;&#39; + str(periodicity[i]) + &#39;&#34;&#39; 
            if to_find_tor in xml_tor_reparams_lines[j]:
                #print(xml_tor_reparams_lines[j])
                xml_tor_reparams_lines[j] = non_zero_k_tor[i]    
    with open(self.reparameterised_torsional_system_xml_file, &#39;w&#39;) as f:
        for i in xml_tor_reparams_lines:
            f.write(i)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="parameterize.TorsionDriveSims"><code class="flex name class">
<span>class <span class="ident">TorsionDriveSims</span></span>
<span>(</span><span>charge, multiplicity, reparameterised_system_xml_file='guest_reparameterised.xml', torsion_xml_file='guest_torsion_xml.txt', xyz_file='guest_coords.xyz', psi_input_file='torsion_drive_input.dat', memory=50, basis_set='STO-3G', functional='BLYP', iterations=2000, method_torsion_drive='native_opt', system_bonds_file='guest_bonds.txt', tor_dir='torsion_dir', dihedral_text_file='dihedrals.txt', template_pdb='guest_init_II.pdb', torsion_drive_run_file='run_command', dihedral_interval=15, engine='psi4', energy_threshold=0.001)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TorsionDriveSims:

    def __init__(self, charge, multiplicity, reparameterised_system_xml_file = &#34;guest_reparameterised.xml&#34;, torsion_xml_file = &#34;guest_torsion_xml.txt&#34;, xyz_file = &#34;guest_coords.xyz&#34;, psi_input_file = &#34;torsion_drive_input.dat&#34;, memory = 50, basis_set = &#34;STO-3G&#34;, functional = &#34;BLYP&#34;, iterations = 2000, method_torsion_drive = &#34;native_opt&#34;, system_bonds_file = &#34;guest_bonds.txt&#34;, tor_dir = &#34;torsion_dir&#34;, dihedral_text_file = &#34;dihedrals.txt&#34;, template_pdb = &#34;guest_init_II.pdb&#34;, torsion_drive_run_file = &#34;run_command&#34;, dihedral_interval = 15, engine = &#34;psi4&#34;, energy_threshold = 0.001):  
        self.charge = charge
        self.multiplicity = multiplicity
        self.reparameterised_system_xml_file = reparameterised_system_xml_file
        self.torsion_xml_file = torsion_xml_file
        self.xyz_file = xyz_file
        self.psi_input_file = psi_input_file
        self.memory = memory
        self.basis_set = basis_set
        self.functional = functional
        self.iterations = iterations
        self.method_torsion_drive = method_torsion_drive
        self.system_bonds_file = system_bonds_file
        self.tor_dir = tor_dir
        self.dihedral_text_file = dihedral_text_file
        self.template_pdb = template_pdb
        self.torsion_drive_run_file = torsion_drive_run_file
        self.dihedral_interval = dihedral_interval
        self.engine = engine
        self.energy_threshold = energy_threshold

    def write_torsion_drive_run_file(self):
        if self.method_torsion_drive == &#34;geometric&#34;:
            torsion_command = &#34;torsiondrive-launch&#34; + &#34; &#34; + self.psi_input_file + &#34; &#34; + self.dihedral_text_file + &#34; &#34; + &#34;-g&#34; + &#34; &#34; + str(self.dihedral_interval) + &#34; &#34; + &#34;-e&#34; + &#34; &#34; + self.engine + &#34; &#34; + &#34;--energy_thresh&#34; + &#34; &#34; + str(self.energy_threshold) + &#34; &#34; + &#34;-v&#34;
        if self.method_torsion_drive == &#34;native_opt&#34;:
            torsion_command = &#34;torsiondrive-launch&#34; + &#34; &#34; + self.psi_input_file + &#34; &#34; + self.dihedral_text_file + &#34; &#34; + &#34;-g&#34; + &#34; &#34; + str(self.dihedral_interval) + &#34; &#34; + &#34;-e&#34; + &#34; &#34; + self.engine + &#34; &#34; + &#34;--energy_thresh&#34; + &#34; &#34; + str(self.energy_threshold) + &#34; &#34; + &#34;--&#34; + self.method_torsion_drive + &#34; &#34; + &#34;-v&#34;
        print(torsion_command)
        with open(self.torsion_drive_run_file, &#34;w&#34;) as f: 
            f.write(torsion_command) 

    def write_tor_params_txt(self):
        xml_off = open(self.reparameterised_system_xml_file, &#39;r&#39;) 
        xml_off_lines = xml_off.readlines() 
        for i in range(len(xml_off_lines)):
            if &#34;&lt;Torsions&gt;&#34; in xml_off_lines[i]:
                to_begin = int(i)
            if &#34;&lt;/Torsions&gt;&#34; in xml_off_lines[i]:
                to_end = int(i)  
        torsion_params = xml_off_lines[to_begin + 1:to_end]

        k_list_off = []
        for i in range(len(torsion_params)):
            k_list_off.append(float(re.findall(&#39;\d*\.?\d+&#39;,torsion_params[i])[0]))
        k_list_off = [round(num, 10) for num in k_list_off]
        #print(k_list_off)
        p1 = []
        for i in range(len(torsion_params)):
            p1.append(int(re.findall(&#39;\d*\.?\d+&#39;,torsion_params[i])[2]))
        p1 = [i + 1 for i in p1]
        #print(p1)
        p2 = []
        for i in range(len(torsion_params)):
            p2.append(int(re.findall(&#39;\d*\.?\d+&#39;,torsion_params[i])[4]))
        p2 = [i + 1 for i in p2]
        #print(p2)
        p3 = []
        for i in range(len(torsion_params)):
            p3.append(int(re.findall(&#39;\d*\.?\d+&#39;,torsion_params[i])[6]))
        p3 = [i + 1 for i in p3]
        #print(p3)
        p4 = []
        for i in range(len(torsion_params)):
            p4.append(int(re.findall(&#39;\d*\.?\d+&#39;,torsion_params[i])[8]))
        p4 = [i + 1 for i in p4]
        #print(p4)
        periodicity = []
        for i in range(len(torsion_params)):
            periodicity.append(int(re.findall(&#39;\d*\.?\d+&#39;,torsion_params[i])[9]))
        #print(periodicity)
        phase = []
        for i in range(len(torsion_params)):
            phase.append(float(re.findall(&#39;\d*\.?\d+&#39;,torsion_params[i])[10]))
        phase = [round(num, 8) for num in phase]
        #print(phase)
        data_tuples = list(zip(k_list_off, p1, p2, p3, p4, periodicity, phase))
        df_tor = pd.DataFrame(data_tuples, columns=[&#39;k&#39;,&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;,&#39;p4&#39;,&#39;periodicity&#39;,&#39;phase&#39;])
        #print(df_tor.head())
        df_tor.to_csv (self.torsion_xml_file, index = False, header = False, sep = &#39; &#39;)

    def write_psi4_input(self):
        xyz_lines = open(self.xyz_file, &#39;r&#39;).readlines()[2:]
        with open(self.psi_input_file, &#34;w&#34;) as f: 
            f.write(&#34;memory&#34; + &#34; &#34; + str(self.memory)  + &#34; &#34; + &#34;GB&#34; + &#34;\n&#34;) 
            f.write(&#34;molecule&#34; + &#34; &#34; + &#34;{&#34; + &#34;\n&#34;)
            f.write(str(self.charge) + &#34; &#34; + str(self.multiplicity) + &#34;\n&#34;)
            for line in xyz_lines:
                f.write(line)
            f.write(&#34;}&#34; + &#34;\n&#34;)
            f.write(&#34;set&#34;  + &#34; &#34; + &#34;{&#34; + &#34;\n&#34;)
            f.write(&#34;basis&#34; + &#34; &#34; + self.basis_set + &#34;\n&#34;)
            if self.method_torsion_drive == &#34;native_opt&#34; :        
                f.write(&#34;GEOM_MAXITER&#34; + &#34; &#34; + str(self.iterations) + &#34;\n&#34;)
            f.write(&#34;}&#34; + &#34;\n&#34;)
            if self.method_torsion_drive == &#34;native_opt&#34; :
                f.write(&#34;optimize&#34; + &#34;(&#34; + &#34;&#39;&#34; + self.functional + &#34;&#39;&#34;&#34;)&#34; + &#34;\n&#34;)  
            if self.method_torsion_drive == &#34;geometric&#34; :
                f.write(&#34;gradient&#34; + &#34;(&#34; + &#34;&#39;&#34; + self.functional + &#34;&#39;&#34;&#34;)&#34; + &#34;\n&#34;) 

    def create_torsion_drive_dir(self):
        df_tor = pd.read_csv(self.torsion_xml_file, header = None, delimiter = r&#34;\s+&#34;)
        df_tor.columns = [&#39;k&#39;,&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;,&#39;p4&#39;,&#39;periodicity&#39;,&#39;phase&#39;]
        #print(df_tor.head())
        df_dihedrals = df_tor[[&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;,&#39;p4&#39;]]
        #print(df_dihedrals.head())
        dihedrals_list_list = []
        for i in range(len(df_dihedrals)):
            dihedrals_list_list.append(df_dihedrals.iloc[i].values.tolist())
        set_list = set()
        unique_dihedrals_list_list = []
        for x in dihedrals_list_list:
            srtd = tuple(sorted(x))
            if srtd not in set_list:
                unique_dihedrals_list_list.append(x)
                set_list.add(srtd)
        #print(unique_dihedrals_list_list)
        os.system(&#34;rm -rf &#34; + self.tor_dir)
        os.system(&#34;mkdir &#34; + self.tor_dir)
        parent_cwd = os.getcwd()
        shutil.copy(parent_cwd + &#34;/&#34; + self.psi_input_file, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.psi_input_file)
        shutil.copy(parent_cwd + &#34;/&#34; + self.template_pdb, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.template_pdb)
        shutil.copy(parent_cwd + &#34;/&#34; + self.torsion_drive_run_file, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.torsion_drive_run_file)
        os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir)
        torsion_drive_dir = os.getcwd()
        for i in range(len(unique_dihedrals_list_list)):
            dir_name = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
            os.system(&#34;rm -rf &#34; + dir_name)
            os.system(&#34;mkdir &#34;  + dir_name)
            os.chdir (torsion_drive_dir + &#34;/&#34; + dir_name)
            with open(self.dihedral_text_file, &#34;w&#34;) as f: 
                f.write(&#34;# dihedral definition by atom indices starting from 1&#34; + &#34;\n&#34;)
                f.write(&#34;# i     j     k     l&#34; + &#34;\n&#34;)
                i_ = unique_dihedrals_list_list[i][0]
                j_ = unique_dihedrals_list_list[i][1]
                k_ = unique_dihedrals_list_list[i][2]
                l_ = unique_dihedrals_list_list[i][3]
                f.write(&#34; &#34; +  &#34;{:&lt; 6d}&#34;.format(i_) + &#34;{:&lt; 6d}&#34;.format(j_) + &#34;{:&lt; 6d}&#34;.format(k_) + &#34;{:&lt; 6d}&#34;.format(l_) +  &#34;\n&#34;)
                shutil.copy (torsion_drive_dir + &#34;/&#34; + self.psi_input_file, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.psi_input_file)
                shutil.copy (torsion_drive_dir + &#34;/&#34; + self.template_pdb, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.template_pdb)
                shutil.copy (torsion_drive_dir + &#34;/&#34; + self.torsion_drive_run_file, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.torsion_drive_run_file)
                os.chdir(torsion_drive_dir)   
        os.system(&#34;rm -rf &#34;  + self.psi_input_file)
        os.system(&#34;rm -rf &#34;  + self.template_pdb)
        os.system(&#34;rm -rf &#34; + self.torsion_drive_run_file)
        os.chdir(parent_cwd)   

    def create_non_H_torsion_drive_dir(self):
        df_tor = pd.read_csv(self.torsion_xml_file, header = None, delimiter = r&#34;\s+&#34;)
        df_tor.columns = [&#39;k&#39;,&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;,&#39;p4&#39;,&#39;periodicity&#39;,&#39;phase&#39;]
        #print(df_tor.head())
        ppdb = PandasPdb()
        ppdb.read_pdb(self.template_pdb)
        df_index_symbol = ppdb.df[&#34;ATOM&#34;][[&#34;atom_number&#34;, &#34;element_symbol&#34;]]
        #print(df_index_symbol.head())
        df_dihedrals = df_tor[[&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;,&#39;p4&#39;]]
        #print(df_dihedrals.head())
        dihedrals_list_list = []
        for i in range(len(df_dihedrals)):
            dihedrals_list_list.append(df_dihedrals.iloc[i].values.tolist())
        set_list = set()
        unique_dihedrals_list_list = []
        for x in dihedrals_list_list:
            srtd = tuple(sorted(x))
            if srtd not in set_list:
                unique_dihedrals_list_list.append(x)
                set_list.add(srtd)
        #print(unique_dihedrals_list_list)
        atom_dihedral_list = []
        for sub_list in unique_dihedrals_list_list:
            atom_dihedral_list.append([df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[0]][&#34;element_symbol&#34;].to_list()[0],df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[1]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[2]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[3]][&#34;element_symbol&#34;].to_list()[0]])
        #print(atom_dihedral_list)
        index_to_include = []
        for i in range(len(atom_dihedral_list)):
            if &#34;H&#34; not in atom_dihedral_list[i]:
                index_to_include.append(i)
        non_H_dihedrals = []
        for i in index_to_include:
            non_H_dihedrals.append(unique_dihedrals_list_list[i])
        #print(non_H_dihedrals)
        non_H_atom_dihedral_list = []
        for sub_list in non_H_dihedrals:
            non_H_atom_dihedral_list.append([df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[0]][&#34;element_symbol&#34;].to_list()[0],df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[1]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[2]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[3]][&#34;element_symbol&#34;].to_list()[0]])
        print(non_H_atom_dihedral_list)  
        os.system(&#34;rm -rf &#34; + self.tor_dir)
        os.system(&#34;mkdir &#34; + self.tor_dir)
        parent_cwd = os.getcwd()
        shutil.copy(parent_cwd + &#34;/&#34; + self.psi_input_file, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.psi_input_file)
        shutil.copy(parent_cwd + &#34;/&#34; + self.template_pdb, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.template_pdb)
        shutil.copy(parent_cwd + &#34;/&#34; + self.torsion_drive_run_file, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.torsion_drive_run_file)
        os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir)
        torsion_drive_dir = os.getcwd()
        for i in range(len(non_H_dihedrals)):
            dir_name = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
            os.system(&#34;rm -rf &#34; + dir_name)
            os.system(&#34;mkdir &#34;  + dir_name)
            os.chdir (torsion_drive_dir + &#34;/&#34; + dir_name)
            with open(self.dihedral_text_file, &#34;w&#34;) as f: 
                f.write(&#34;# dihedral definition by atom indices starting from 1&#34; + &#34;\n&#34;)
                f.write(&#34;# i     j     k     l&#34; + &#34;\n&#34;)
                i_ = non_H_dihedrals[i][0]
                j_ = non_H_dihedrals[i][1]
                k_ = non_H_dihedrals[i][2]
                l_ = non_H_dihedrals[i][3]
                f.write(&#34; &#34; +  &#34;{:&lt; 6d}&#34;.format(i_) + &#34;{:&lt; 6d}&#34;.format(j_) + &#34;{:&lt; 6d}&#34;.format(k_) + &#34;{:&lt; 6d}&#34;.format(l_) +  &#34;\n&#34;)
                shutil.copy (torsion_drive_dir + &#34;/&#34; + self.psi_input_file, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.psi_input_file)
                shutil.copy (torsion_drive_dir + &#34;/&#34; + self.template_pdb, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.template_pdb)
                shutil.copy (torsion_drive_dir + &#34;/&#34; + self.torsion_drive_run_file, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.torsion_drive_run_file)
                os.chdir(torsion_drive_dir)   
        os.system(&#34;rm -rf &#34;  + self.psi_input_file)
        os.system(&#34;rm -rf &#34;  + self.template_pdb)
        os.system(&#34;rm -rf &#34; + self.torsion_drive_run_file)
        os.chdir(parent_cwd)  


    def create_non_H_bonded_torsion_drive_dir(self):
        df_tor = pd.read_csv(self.torsion_xml_file, header = None, delimiter = r&#34;\s+&#34;)
        df_tor.columns = [&#39;k&#39;,&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;,&#39;p4&#39;,&#39;periodicity&#39;,&#39;phase&#39;]
        #print(df_tor.head())
        ppdb = PandasPdb()
        ppdb.read_pdb(self.template_pdb)
        df_index_symbol = ppdb.df[&#34;ATOM&#34;][[&#34;atom_number&#34;, &#34;element_symbol&#34;]]
        #print(df_index_symbol.head())
        df_dihedrals = df_tor[[&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;,&#39;p4&#39;]]
        #print(df_dihedrals.head())
        dihedrals_list_list = []
        for i in range(len(df_dihedrals)):
            dihedrals_list_list.append(df_dihedrals.iloc[i].values.tolist())
        set_list = set()
        unique_dihedrals_list_list = []
        for x in dihedrals_list_list:
            srtd = tuple(sorted(x))
            if srtd not in set_list:
                unique_dihedrals_list_list.append(x)
                set_list.add(srtd)
        #print(unique_dihedrals_list_list)
        atom_dihedral_list = []
        for sub_list in unique_dihedrals_list_list:
            atom_dihedral_list.append([df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[0]][&#34;element_symbol&#34;].to_list()[0],df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[1]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[2]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[3]][&#34;element_symbol&#34;].to_list()[0]])
        #print(atom_dihedral_list)
        index_to_include = []
        for i in range(len(atom_dihedral_list)):
            if &#34;H&#34; not in atom_dihedral_list[i]:
                index_to_include.append(i)
        non_H_dihedrals = []
        for i in index_to_include:
            non_H_dihedrals.append(unique_dihedrals_list_list[i])
        #print(non_H_dihedrals)
        non_H_atom_dihedral_list = []
        for sub_list in non_H_dihedrals:
            non_H_atom_dihedral_list.append([df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[0]][&#34;element_symbol&#34;].to_list()[0],df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[1]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[2]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[3]][&#34;element_symbol&#34;].to_list()[0]])
        #print(non_H_atom_dihedral_list)  
        df_bonds_all = pd.read_csv(self.system_bonds_file, header = None, delimiter = r&#34;\s+&#34;)
        df_bonds_all.columns = [&#34;bond_names&#34;, &#34;k&#34;, &#34;angle&#34;, &#34;b1&#34;, &#34;b2&#34;]
        df_bonds = df_bonds_all[[&#39;b1&#39;,&#39;b2&#39;]]
        bonds_list_list = []
        for i in range(len(df_bonds)):
            bonds_list_list.append(df_bonds.iloc[i].values.tolist())
        #print(bonds_list_list)
        reverse_bond_list_list = []
        for i in bonds_list_list:
            reverse_bond_list_list.append(reverse_list(i))
        #print(reverse_bond_list_list)
        bond_list = bonds_list_list + reverse_bond_list_list
        #print(bond_list)
        non_H_dihedral_bonds_list = []
        for i in non_H_dihedrals:
            non_H_dihedral_bonds_list.append([[i[0], i[1]], [i[1], i[2]], [i[2], i[3]]])
        #print(non_H_dihedral_bonds_list)
        bonded_index_to_include = []
        for i in range(len(non_H_dihedral_bonds_list)):
            if [non_H_dihedral_bonds_list[i][0] in bond_list, non_H_dihedral_bonds_list[i][1] in bond_list, non_H_dihedral_bonds_list[i][2] in bond_list] == [True, True, True] :
                bonded_index_to_include.append(i)
        #print(bonded_index_to_include)
        non_H_bonded_dihedrals = []
        for i in bonded_index_to_include:
            non_H_bonded_dihedrals.append(non_H_dihedrals[i])
        #print(non_H_bonded_dihedrals)
        non_H_bonded_atom_dihedral_list = []
        for sub_list in non_H_bonded_dihedrals:
            non_H_bonded_atom_dihedral_list.append([df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[0]][&#34;element_symbol&#34;].to_list()[0],df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[1]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[2]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[3]][&#34;element_symbol&#34;].to_list()[0]])
        print(non_H_bonded_atom_dihedral_list)    
        os.system(&#34;rm -rf &#34; + self.tor_dir)
        os.system(&#34;mkdir &#34; + self.tor_dir)
        parent_cwd = os.getcwd()
        shutil.copy(parent_cwd + &#34;/&#34; + self.psi_input_file, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.psi_input_file)
        shutil.copy(parent_cwd + &#34;/&#34; + self.template_pdb, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.template_pdb)
        shutil.copy(parent_cwd + &#34;/&#34; + self.torsion_drive_run_file, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.torsion_drive_run_file)
        os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir)
        torsion_drive_dir = os.getcwd()
        for i in range(len(non_H_bonded_dihedrals)):
            dir_name = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
            os.system(&#34;rm -rf &#34; + dir_name)
            os.system(&#34;mkdir &#34;  + dir_name)
            os.chdir (torsion_drive_dir + &#34;/&#34; + dir_name)
            with open(self.dihedral_text_file, &#34;w&#34;) as f: 
                f.write(&#34;# dihedral definition by atom indices starting from 1&#34; + &#34;\n&#34;)
                f.write(&#34;# i     j     k     l&#34; + &#34;\n&#34;)
                i_ = non_H_bonded_dihedrals[i][0]
                j_ = non_H_bonded_dihedrals[i][1]
                k_ = non_H_bonded_dihedrals[i][2]
                l_ = non_H_bonded_dihedrals[i][3]
                f.write(&#34; &#34; +  &#34;{:&lt; 6d}&#34;.format(i_) + &#34;{:&lt; 6d}&#34;.format(j_) + &#34;{:&lt; 6d}&#34;.format(k_) + &#34;{:&lt; 6d}&#34;.format(l_) +  &#34;\n&#34;)
                shutil.copy (torsion_drive_dir + &#34;/&#34; + self.psi_input_file, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.psi_input_file)
                shutil.copy (torsion_drive_dir + &#34;/&#34; + self.template_pdb, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.template_pdb)
                shutil.copy (torsion_drive_dir + &#34;/&#34; + self.torsion_drive_run_file, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.torsion_drive_run_file)
                os.chdir(torsion_drive_dir)   
        os.system(&#34;rm -rf &#34;  + self.psi_input_file)
        os.system(&#34;rm -rf &#34;  + self.template_pdb)
        os.system(&#34;rm -rf &#34; + self.torsion_drive_run_file)
        os.chdir(parent_cwd)  

    def run_torsion_sim(self):
        parent_cwd = os.getcwd()
        target_dir = parent_cwd + &#34;/&#34; + self.tor_dir
        num_folders = 0
        for _, dirnames, filenames in os.walk(target_dir):
            num_folders += len(dirnames)
        for i in range(num_folders):
            dir_ = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
            os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + dir_)
            run_command = &#34;bash&#34; + &#34; &#34; + self.torsion_drive_run_file
            #os.system(run_command)
            print(run_command)
            os.chdir(parent_cwd) </code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="parameterize.TorsionDriveSims.create_non_H_bonded_torsion_drive_dir"><code class="name flex">
<span>def <span class="ident">create_non_H_bonded_torsion_drive_dir</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_non_H_bonded_torsion_drive_dir(self):
    df_tor = pd.read_csv(self.torsion_xml_file, header = None, delimiter = r&#34;\s+&#34;)
    df_tor.columns = [&#39;k&#39;,&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;,&#39;p4&#39;,&#39;periodicity&#39;,&#39;phase&#39;]
    #print(df_tor.head())
    ppdb = PandasPdb()
    ppdb.read_pdb(self.template_pdb)
    df_index_symbol = ppdb.df[&#34;ATOM&#34;][[&#34;atom_number&#34;, &#34;element_symbol&#34;]]
    #print(df_index_symbol.head())
    df_dihedrals = df_tor[[&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;,&#39;p4&#39;]]
    #print(df_dihedrals.head())
    dihedrals_list_list = []
    for i in range(len(df_dihedrals)):
        dihedrals_list_list.append(df_dihedrals.iloc[i].values.tolist())
    set_list = set()
    unique_dihedrals_list_list = []
    for x in dihedrals_list_list:
        srtd = tuple(sorted(x))
        if srtd not in set_list:
            unique_dihedrals_list_list.append(x)
            set_list.add(srtd)
    #print(unique_dihedrals_list_list)
    atom_dihedral_list = []
    for sub_list in unique_dihedrals_list_list:
        atom_dihedral_list.append([df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[0]][&#34;element_symbol&#34;].to_list()[0],df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[1]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[2]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[3]][&#34;element_symbol&#34;].to_list()[0]])
    #print(atom_dihedral_list)
    index_to_include = []
    for i in range(len(atom_dihedral_list)):
        if &#34;H&#34; not in atom_dihedral_list[i]:
            index_to_include.append(i)
    non_H_dihedrals = []
    for i in index_to_include:
        non_H_dihedrals.append(unique_dihedrals_list_list[i])
    #print(non_H_dihedrals)
    non_H_atom_dihedral_list = []
    for sub_list in non_H_dihedrals:
        non_H_atom_dihedral_list.append([df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[0]][&#34;element_symbol&#34;].to_list()[0],df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[1]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[2]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[3]][&#34;element_symbol&#34;].to_list()[0]])
    #print(non_H_atom_dihedral_list)  
    df_bonds_all = pd.read_csv(self.system_bonds_file, header = None, delimiter = r&#34;\s+&#34;)
    df_bonds_all.columns = [&#34;bond_names&#34;, &#34;k&#34;, &#34;angle&#34;, &#34;b1&#34;, &#34;b2&#34;]
    df_bonds = df_bonds_all[[&#39;b1&#39;,&#39;b2&#39;]]
    bonds_list_list = []
    for i in range(len(df_bonds)):
        bonds_list_list.append(df_bonds.iloc[i].values.tolist())
    #print(bonds_list_list)
    reverse_bond_list_list = []
    for i in bonds_list_list:
        reverse_bond_list_list.append(reverse_list(i))
    #print(reverse_bond_list_list)
    bond_list = bonds_list_list + reverse_bond_list_list
    #print(bond_list)
    non_H_dihedral_bonds_list = []
    for i in non_H_dihedrals:
        non_H_dihedral_bonds_list.append([[i[0], i[1]], [i[1], i[2]], [i[2], i[3]]])
    #print(non_H_dihedral_bonds_list)
    bonded_index_to_include = []
    for i in range(len(non_H_dihedral_bonds_list)):
        if [non_H_dihedral_bonds_list[i][0] in bond_list, non_H_dihedral_bonds_list[i][1] in bond_list, non_H_dihedral_bonds_list[i][2] in bond_list] == [True, True, True] :
            bonded_index_to_include.append(i)
    #print(bonded_index_to_include)
    non_H_bonded_dihedrals = []
    for i in bonded_index_to_include:
        non_H_bonded_dihedrals.append(non_H_dihedrals[i])
    #print(non_H_bonded_dihedrals)
    non_H_bonded_atom_dihedral_list = []
    for sub_list in non_H_bonded_dihedrals:
        non_H_bonded_atom_dihedral_list.append([df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[0]][&#34;element_symbol&#34;].to_list()[0],df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[1]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[2]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[3]][&#34;element_symbol&#34;].to_list()[0]])
    print(non_H_bonded_atom_dihedral_list)    
    os.system(&#34;rm -rf &#34; + self.tor_dir)
    os.system(&#34;mkdir &#34; + self.tor_dir)
    parent_cwd = os.getcwd()
    shutil.copy(parent_cwd + &#34;/&#34; + self.psi_input_file, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.psi_input_file)
    shutil.copy(parent_cwd + &#34;/&#34; + self.template_pdb, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.template_pdb)
    shutil.copy(parent_cwd + &#34;/&#34; + self.torsion_drive_run_file, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.torsion_drive_run_file)
    os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir)
    torsion_drive_dir = os.getcwd()
    for i in range(len(non_H_bonded_dihedrals)):
        dir_name = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
        os.system(&#34;rm -rf &#34; + dir_name)
        os.system(&#34;mkdir &#34;  + dir_name)
        os.chdir (torsion_drive_dir + &#34;/&#34; + dir_name)
        with open(self.dihedral_text_file, &#34;w&#34;) as f: 
            f.write(&#34;# dihedral definition by atom indices starting from 1&#34; + &#34;\n&#34;)
            f.write(&#34;# i     j     k     l&#34; + &#34;\n&#34;)
            i_ = non_H_bonded_dihedrals[i][0]
            j_ = non_H_bonded_dihedrals[i][1]
            k_ = non_H_bonded_dihedrals[i][2]
            l_ = non_H_bonded_dihedrals[i][3]
            f.write(&#34; &#34; +  &#34;{:&lt; 6d}&#34;.format(i_) + &#34;{:&lt; 6d}&#34;.format(j_) + &#34;{:&lt; 6d}&#34;.format(k_) + &#34;{:&lt; 6d}&#34;.format(l_) +  &#34;\n&#34;)
            shutil.copy (torsion_drive_dir + &#34;/&#34; + self.psi_input_file, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.psi_input_file)
            shutil.copy (torsion_drive_dir + &#34;/&#34; + self.template_pdb, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.template_pdb)
            shutil.copy (torsion_drive_dir + &#34;/&#34; + self.torsion_drive_run_file, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.torsion_drive_run_file)
            os.chdir(torsion_drive_dir)   
    os.system(&#34;rm -rf &#34;  + self.psi_input_file)
    os.system(&#34;rm -rf &#34;  + self.template_pdb)
    os.system(&#34;rm -rf &#34; + self.torsion_drive_run_file)
    os.chdir(parent_cwd)  </code></pre>
</details>
</dd>
<dt id="parameterize.TorsionDriveSims.create_non_H_torsion_drive_dir"><code class="name flex">
<span>def <span class="ident">create_non_H_torsion_drive_dir</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_non_H_torsion_drive_dir(self):
    df_tor = pd.read_csv(self.torsion_xml_file, header = None, delimiter = r&#34;\s+&#34;)
    df_tor.columns = [&#39;k&#39;,&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;,&#39;p4&#39;,&#39;periodicity&#39;,&#39;phase&#39;]
    #print(df_tor.head())
    ppdb = PandasPdb()
    ppdb.read_pdb(self.template_pdb)
    df_index_symbol = ppdb.df[&#34;ATOM&#34;][[&#34;atom_number&#34;, &#34;element_symbol&#34;]]
    #print(df_index_symbol.head())
    df_dihedrals = df_tor[[&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;,&#39;p4&#39;]]
    #print(df_dihedrals.head())
    dihedrals_list_list = []
    for i in range(len(df_dihedrals)):
        dihedrals_list_list.append(df_dihedrals.iloc[i].values.tolist())
    set_list = set()
    unique_dihedrals_list_list = []
    for x in dihedrals_list_list:
        srtd = tuple(sorted(x))
        if srtd not in set_list:
            unique_dihedrals_list_list.append(x)
            set_list.add(srtd)
    #print(unique_dihedrals_list_list)
    atom_dihedral_list = []
    for sub_list in unique_dihedrals_list_list:
        atom_dihedral_list.append([df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[0]][&#34;element_symbol&#34;].to_list()[0],df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[1]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[2]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[3]][&#34;element_symbol&#34;].to_list()[0]])
    #print(atom_dihedral_list)
    index_to_include = []
    for i in range(len(atom_dihedral_list)):
        if &#34;H&#34; not in atom_dihedral_list[i]:
            index_to_include.append(i)
    non_H_dihedrals = []
    for i in index_to_include:
        non_H_dihedrals.append(unique_dihedrals_list_list[i])
    #print(non_H_dihedrals)
    non_H_atom_dihedral_list = []
    for sub_list in non_H_dihedrals:
        non_H_atom_dihedral_list.append([df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[0]][&#34;element_symbol&#34;].to_list()[0],df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[1]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[2]][&#34;element_symbol&#34;].to_list()[0], df_index_symbol.loc[df_index_symbol[&#39;atom_number&#39;] == sub_list[3]][&#34;element_symbol&#34;].to_list()[0]])
    print(non_H_atom_dihedral_list)  
    os.system(&#34;rm -rf &#34; + self.tor_dir)
    os.system(&#34;mkdir &#34; + self.tor_dir)
    parent_cwd = os.getcwd()
    shutil.copy(parent_cwd + &#34;/&#34; + self.psi_input_file, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.psi_input_file)
    shutil.copy(parent_cwd + &#34;/&#34; + self.template_pdb, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.template_pdb)
    shutil.copy(parent_cwd + &#34;/&#34; + self.torsion_drive_run_file, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.torsion_drive_run_file)
    os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir)
    torsion_drive_dir = os.getcwd()
    for i in range(len(non_H_dihedrals)):
        dir_name = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
        os.system(&#34;rm -rf &#34; + dir_name)
        os.system(&#34;mkdir &#34;  + dir_name)
        os.chdir (torsion_drive_dir + &#34;/&#34; + dir_name)
        with open(self.dihedral_text_file, &#34;w&#34;) as f: 
            f.write(&#34;# dihedral definition by atom indices starting from 1&#34; + &#34;\n&#34;)
            f.write(&#34;# i     j     k     l&#34; + &#34;\n&#34;)
            i_ = non_H_dihedrals[i][0]
            j_ = non_H_dihedrals[i][1]
            k_ = non_H_dihedrals[i][2]
            l_ = non_H_dihedrals[i][3]
            f.write(&#34; &#34; +  &#34;{:&lt; 6d}&#34;.format(i_) + &#34;{:&lt; 6d}&#34;.format(j_) + &#34;{:&lt; 6d}&#34;.format(k_) + &#34;{:&lt; 6d}&#34;.format(l_) +  &#34;\n&#34;)
            shutil.copy (torsion_drive_dir + &#34;/&#34; + self.psi_input_file, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.psi_input_file)
            shutil.copy (torsion_drive_dir + &#34;/&#34; + self.template_pdb, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.template_pdb)
            shutil.copy (torsion_drive_dir + &#34;/&#34; + self.torsion_drive_run_file, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.torsion_drive_run_file)
            os.chdir(torsion_drive_dir)   
    os.system(&#34;rm -rf &#34;  + self.psi_input_file)
    os.system(&#34;rm -rf &#34;  + self.template_pdb)
    os.system(&#34;rm -rf &#34; + self.torsion_drive_run_file)
    os.chdir(parent_cwd)  </code></pre>
</details>
</dd>
<dt id="parameterize.TorsionDriveSims.create_torsion_drive_dir"><code class="name flex">
<span>def <span class="ident">create_torsion_drive_dir</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_torsion_drive_dir(self):
    df_tor = pd.read_csv(self.torsion_xml_file, header = None, delimiter = r&#34;\s+&#34;)
    df_tor.columns = [&#39;k&#39;,&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;,&#39;p4&#39;,&#39;periodicity&#39;,&#39;phase&#39;]
    #print(df_tor.head())
    df_dihedrals = df_tor[[&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;,&#39;p4&#39;]]
    #print(df_dihedrals.head())
    dihedrals_list_list = []
    for i in range(len(df_dihedrals)):
        dihedrals_list_list.append(df_dihedrals.iloc[i].values.tolist())
    set_list = set()
    unique_dihedrals_list_list = []
    for x in dihedrals_list_list:
        srtd = tuple(sorted(x))
        if srtd not in set_list:
            unique_dihedrals_list_list.append(x)
            set_list.add(srtd)
    #print(unique_dihedrals_list_list)
    os.system(&#34;rm -rf &#34; + self.tor_dir)
    os.system(&#34;mkdir &#34; + self.tor_dir)
    parent_cwd = os.getcwd()
    shutil.copy(parent_cwd + &#34;/&#34; + self.psi_input_file, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.psi_input_file)
    shutil.copy(parent_cwd + &#34;/&#34; + self.template_pdb, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.template_pdb)
    shutil.copy(parent_cwd + &#34;/&#34; + self.torsion_drive_run_file, parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + self.torsion_drive_run_file)
    os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir)
    torsion_drive_dir = os.getcwd()
    for i in range(len(unique_dihedrals_list_list)):
        dir_name = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
        os.system(&#34;rm -rf &#34; + dir_name)
        os.system(&#34;mkdir &#34;  + dir_name)
        os.chdir (torsion_drive_dir + &#34;/&#34; + dir_name)
        with open(self.dihedral_text_file, &#34;w&#34;) as f: 
            f.write(&#34;# dihedral definition by atom indices starting from 1&#34; + &#34;\n&#34;)
            f.write(&#34;# i     j     k     l&#34; + &#34;\n&#34;)
            i_ = unique_dihedrals_list_list[i][0]
            j_ = unique_dihedrals_list_list[i][1]
            k_ = unique_dihedrals_list_list[i][2]
            l_ = unique_dihedrals_list_list[i][3]
            f.write(&#34; &#34; +  &#34;{:&lt; 6d}&#34;.format(i_) + &#34;{:&lt; 6d}&#34;.format(j_) + &#34;{:&lt; 6d}&#34;.format(k_) + &#34;{:&lt; 6d}&#34;.format(l_) +  &#34;\n&#34;)
            shutil.copy (torsion_drive_dir + &#34;/&#34; + self.psi_input_file, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.psi_input_file)
            shutil.copy (torsion_drive_dir + &#34;/&#34; + self.template_pdb, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.template_pdb)
            shutil.copy (torsion_drive_dir + &#34;/&#34; + self.torsion_drive_run_file, torsion_drive_dir + &#34;/&#34; + dir_name + &#34;/&#34; + self.torsion_drive_run_file)
            os.chdir(torsion_drive_dir)   
    os.system(&#34;rm -rf &#34;  + self.psi_input_file)
    os.system(&#34;rm -rf &#34;  + self.template_pdb)
    os.system(&#34;rm -rf &#34; + self.torsion_drive_run_file)
    os.chdir(parent_cwd)   </code></pre>
</details>
</dd>
<dt id="parameterize.TorsionDriveSims.run_torsion_sim"><code class="name flex">
<span>def <span class="ident">run_torsion_sim</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_torsion_sim(self):
    parent_cwd = os.getcwd()
    target_dir = parent_cwd + &#34;/&#34; + self.tor_dir
    num_folders = 0
    for _, dirnames, filenames in os.walk(target_dir):
        num_folders += len(dirnames)
    for i in range(num_folders):
        dir_ = &#34;torsion_drive&#34; + &#34;_&#34; + str(i)
        os.chdir(parent_cwd + &#34;/&#34; + self.tor_dir + &#34;/&#34; + dir_)
        run_command = &#34;bash&#34; + &#34; &#34; + self.torsion_drive_run_file
        #os.system(run_command)
        print(run_command)
        os.chdir(parent_cwd) </code></pre>
</details>
</dd>
<dt id="parameterize.TorsionDriveSims.write_psi4_input"><code class="name flex">
<span>def <span class="ident">write_psi4_input</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_psi4_input(self):
    xyz_lines = open(self.xyz_file, &#39;r&#39;).readlines()[2:]
    with open(self.psi_input_file, &#34;w&#34;) as f: 
        f.write(&#34;memory&#34; + &#34; &#34; + str(self.memory)  + &#34; &#34; + &#34;GB&#34; + &#34;\n&#34;) 
        f.write(&#34;molecule&#34; + &#34; &#34; + &#34;{&#34; + &#34;\n&#34;)
        f.write(str(self.charge) + &#34; &#34; + str(self.multiplicity) + &#34;\n&#34;)
        for line in xyz_lines:
            f.write(line)
        f.write(&#34;}&#34; + &#34;\n&#34;)
        f.write(&#34;set&#34;  + &#34; &#34; + &#34;{&#34; + &#34;\n&#34;)
        f.write(&#34;basis&#34; + &#34; &#34; + self.basis_set + &#34;\n&#34;)
        if self.method_torsion_drive == &#34;native_opt&#34; :        
            f.write(&#34;GEOM_MAXITER&#34; + &#34; &#34; + str(self.iterations) + &#34;\n&#34;)
        f.write(&#34;}&#34; + &#34;\n&#34;)
        if self.method_torsion_drive == &#34;native_opt&#34; :
            f.write(&#34;optimize&#34; + &#34;(&#34; + &#34;&#39;&#34; + self.functional + &#34;&#39;&#34;&#34;)&#34; + &#34;\n&#34;)  
        if self.method_torsion_drive == &#34;geometric&#34; :
            f.write(&#34;gradient&#34; + &#34;(&#34; + &#34;&#39;&#34; + self.functional + &#34;&#39;&#34;&#34;)&#34; + &#34;\n&#34;) </code></pre>
</details>
</dd>
<dt id="parameterize.TorsionDriveSims.write_tor_params_txt"><code class="name flex">
<span>def <span class="ident">write_tor_params_txt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_tor_params_txt(self):
    xml_off = open(self.reparameterised_system_xml_file, &#39;r&#39;) 
    xml_off_lines = xml_off.readlines() 
    for i in range(len(xml_off_lines)):
        if &#34;&lt;Torsions&gt;&#34; in xml_off_lines[i]:
            to_begin = int(i)
        if &#34;&lt;/Torsions&gt;&#34; in xml_off_lines[i]:
            to_end = int(i)  
    torsion_params = xml_off_lines[to_begin + 1:to_end]

    k_list_off = []
    for i in range(len(torsion_params)):
        k_list_off.append(float(re.findall(&#39;\d*\.?\d+&#39;,torsion_params[i])[0]))
    k_list_off = [round(num, 10) for num in k_list_off]
    #print(k_list_off)
    p1 = []
    for i in range(len(torsion_params)):
        p1.append(int(re.findall(&#39;\d*\.?\d+&#39;,torsion_params[i])[2]))
    p1 = [i + 1 for i in p1]
    #print(p1)
    p2 = []
    for i in range(len(torsion_params)):
        p2.append(int(re.findall(&#39;\d*\.?\d+&#39;,torsion_params[i])[4]))
    p2 = [i + 1 for i in p2]
    #print(p2)
    p3 = []
    for i in range(len(torsion_params)):
        p3.append(int(re.findall(&#39;\d*\.?\d+&#39;,torsion_params[i])[6]))
    p3 = [i + 1 for i in p3]
    #print(p3)
    p4 = []
    for i in range(len(torsion_params)):
        p4.append(int(re.findall(&#39;\d*\.?\d+&#39;,torsion_params[i])[8]))
    p4 = [i + 1 for i in p4]
    #print(p4)
    periodicity = []
    for i in range(len(torsion_params)):
        periodicity.append(int(re.findall(&#39;\d*\.?\d+&#39;,torsion_params[i])[9]))
    #print(periodicity)
    phase = []
    for i in range(len(torsion_params)):
        phase.append(float(re.findall(&#39;\d*\.?\d+&#39;,torsion_params[i])[10]))
    phase = [round(num, 8) for num in phase]
    #print(phase)
    data_tuples = list(zip(k_list_off, p1, p2, p3, p4, periodicity, phase))
    df_tor = pd.DataFrame(data_tuples, columns=[&#39;k&#39;,&#39;p1&#39;,&#39;p2&#39;,&#39;p3&#39;,&#39;p4&#39;,&#39;periodicity&#39;,&#39;phase&#39;])
    #print(df_tor.head())
    df_tor.to_csv (self.torsion_xml_file, index = False, header = False, sep = &#39; &#39;)</code></pre>
</details>
</dd>
<dt id="parameterize.TorsionDriveSims.write_torsion_drive_run_file"><code class="name flex">
<span>def <span class="ident">write_torsion_drive_run_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_torsion_drive_run_file(self):
    if self.method_torsion_drive == &#34;geometric&#34;:
        torsion_command = &#34;torsiondrive-launch&#34; + &#34; &#34; + self.psi_input_file + &#34; &#34; + self.dihedral_text_file + &#34; &#34; + &#34;-g&#34; + &#34; &#34; + str(self.dihedral_interval) + &#34; &#34; + &#34;-e&#34; + &#34; &#34; + self.engine + &#34; &#34; + &#34;--energy_thresh&#34; + &#34; &#34; + str(self.energy_threshold) + &#34; &#34; + &#34;-v&#34;
    if self.method_torsion_drive == &#34;native_opt&#34;:
        torsion_command = &#34;torsiondrive-launch&#34; + &#34; &#34; + self.psi_input_file + &#34; &#34; + self.dihedral_text_file + &#34; &#34; + &#34;-g&#34; + &#34; &#34; + str(self.dihedral_interval) + &#34; &#34; + &#34;-e&#34; + &#34; &#34; + self.engine + &#34; &#34; + &#34;--energy_thresh&#34; + &#34; &#34; + str(self.energy_threshold) + &#34; &#34; + &#34;--&#34; + self.method_torsion_drive + &#34; &#34; + &#34;-v&#34;
    print(torsion_command)
    with open(self.torsion_drive_run_file, &#34;w&#34;) as f: 
        f.write(torsion_command) </code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="parameterize.OPLS_LJ" href="#parameterize.OPLS_LJ">OPLS_LJ</a></code></li>
<li><code><a title="parameterize.copy_file" href="#parameterize.copy_file">copy_file</a></code></li>
<li><code><a title="parameterize.dihedral_energy" href="#parameterize.dihedral_energy">dihedral_energy</a></code></li>
<li><code><a title="parameterize.dot_product" href="#parameterize.dot_product">dot_product</a></code></li>
<li><code><a title="parameterize.error_function" href="#parameterize.error_function">error_function</a></code></li>
<li><code><a title="parameterize.error_function_boltzmann" href="#parameterize.error_function_boltzmann">error_function_boltzmann</a></code></li>
<li><code><a title="parameterize.fit_params" href="#parameterize.fit_params">fit_params</a></code></li>
<li><code><a title="parameterize.force_angle_constant" href="#parameterize.force_angle_constant">force_angle_constant</a></code></li>
<li><code><a title="parameterize.force_angle_constant_special_case" href="#parameterize.force_angle_constant_special_case">force_angle_constant_special_case</a></code></li>
<li><code><a title="parameterize.force_constant_bond" href="#parameterize.force_constant_bond">force_constant_bond</a></code></li>
<li><code><a title="parameterize.gen_init_guess" href="#parameterize.gen_init_guess">gen_init_guess</a></code></li>
<li><code><a title="parameterize.generate_mm_pdbs" href="#parameterize.generate_mm_pdbs">generate_mm_pdbs</a></code></li>
<li><code><a title="parameterize.generate_xml_from_charged_pdb_sdf" href="#parameterize.generate_xml_from_charged_pdb_sdf">generate_xml_from_charged_pdb_sdf</a></code></li>
<li><code><a title="parameterize.generate_xml_from_pdb_sdf" href="#parameterize.generate_xml_from_pdb_sdf">generate_xml_from_pdb_sdf</a></code></li>
<li><code><a title="parameterize.get_dihedrals" href="#parameterize.get_dihedrals">get_dihedrals</a></code></li>
<li><code><a title="parameterize.get_mm_potential_energies" href="#parameterize.get_mm_potential_energies">get_mm_potential_energies</a></code></li>
<li><code><a title="parameterize.get_non_torsion_mm_energy" href="#parameterize.get_non_torsion_mm_energy">get_non_torsion_mm_energy</a></code></li>
<li><code><a title="parameterize.get_qm_energies" href="#parameterize.get_qm_energies">get_qm_energies</a></code></li>
<li><code><a title="parameterize.get_tor_params" href="#parameterize.get_tor_params">get_tor_params</a></code></li>
<li><code><a title="parameterize.get_torsional_lines" href="#parameterize.get_torsional_lines">get_torsional_lines</a></code></li>
<li><code><a title="parameterize.list_diff" href="#parameterize.list_diff">list_diff</a></code></li>
<li><code><a title="parameterize.list_hartree_kcal" href="#parameterize.list_hartree_kcal">list_hartree_kcal</a></code></li>
<li><code><a title="parameterize.list_kJ_kcal" href="#parameterize.list_kJ_kcal">list_kJ_kcal</a></code></li>
<li><code><a title="parameterize.list_to_dict" href="#parameterize.list_to_dict">list_to_dict</a></code></li>
<li><code><a title="parameterize.objective_function" href="#parameterize.objective_function">objective_function</a></code></li>
<li><code><a title="parameterize.remove_mm_files" href="#parameterize.remove_mm_files">remove_mm_files</a></code></li>
<li><code><a title="parameterize.reverse_list" href="#parameterize.reverse_list">reverse_list</a></code></li>
<li><code><a title="parameterize.scale_list" href="#parameterize.scale_list">scale_list</a></code></li>
<li><code><a title="parameterize.search_in_file" href="#parameterize.search_in_file">search_in_file</a></code></li>
<li><code><a title="parameterize.torsiondrive_input_to_xyz" href="#parameterize.torsiondrive_input_to_xyz">torsiondrive_input_to_xyz</a></code></li>
<li><code><a title="parameterize.u_PA_from_angles" href="#parameterize.u_PA_from_angles">u_PA_from_angles</a></code></li>
<li><code><a title="parameterize.uniq" href="#parameterize.uniq">uniq</a></code></li>
<li><code><a title="parameterize.unit_vector_N" href="#parameterize.unit_vector_N">unit_vector_N</a></code></li>
<li><code><a title="parameterize.xyz_to_pdb" href="#parameterize.xyz_to_pdb">xyz_to_pdb</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="parameterize.GuestAmberXMLAmber" href="#parameterize.GuestAmberXMLAmber">GuestAmberXMLAmber</a></code></h4>
<ul class="">
<li><code><a title="parameterize.GuestAmberXMLAmber.analyze_diff_energies" href="#parameterize.GuestAmberXMLAmber.analyze_diff_energies">analyze_diff_energies</a></code></li>
<li><code><a title="parameterize.GuestAmberXMLAmber.generate_xml_antechamber" href="#parameterize.GuestAmberXMLAmber.generate_xml_antechamber">generate_xml_antechamber</a></code></li>
<li><code><a title="parameterize.GuestAmberXMLAmber.generate_xml_from_charged_pdb_sdf" href="#parameterize.GuestAmberXMLAmber.generate_xml_from_charged_pdb_sdf">generate_xml_from_charged_pdb_sdf</a></code></li>
<li><code><a title="parameterize.GuestAmberXMLAmber.generate_xml_from_doubly_charged_pdb_sdf" href="#parameterize.GuestAmberXMLAmber.generate_xml_from_doubly_charged_pdb_sdf">generate_xml_from_doubly_charged_pdb_sdf</a></code></li>
<li><code><a title="parameterize.GuestAmberXMLAmber.generate_xml_from_pdb_sdf" href="#parameterize.GuestAmberXMLAmber.generate_xml_from_pdb_sdf">generate_xml_from_pdb_sdf</a></code></li>
<li><code><a title="parameterize.GuestAmberXMLAmber.generate_xml_from_pdb_smi" href="#parameterize.GuestAmberXMLAmber.generate_xml_from_pdb_smi">generate_xml_from_pdb_smi</a></code></li>
<li><code><a title="parameterize.GuestAmberXMLAmber.save_amber_params" href="#parameterize.GuestAmberXMLAmber.save_amber_params">save_amber_params</a></code></li>
<li><code><a title="parameterize.GuestAmberXMLAmber.write_reparameterised_system_xml" href="#parameterize.GuestAmberXMLAmber.write_reparameterised_system_xml">write_reparameterised_system_xml</a></code></li>
<li><code><a title="parameterize.GuestAmberXMLAmber.write_system_params" href="#parameterize.GuestAmberXMLAmber.write_system_params">write_system_params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.HostAmberXMLAmber" href="#parameterize.HostAmberXMLAmber">HostAmberXMLAmber</a></code></h4>
<ul class="">
<li><code><a title="parameterize.HostAmberXMLAmber.analyze_diff_energies" href="#parameterize.HostAmberXMLAmber.analyze_diff_energies">analyze_diff_energies</a></code></li>
<li><code><a title="parameterize.HostAmberXMLAmber.save_amber_params" href="#parameterize.HostAmberXMLAmber.save_amber_params">save_amber_params</a></code></li>
<li><code><a title="parameterize.HostAmberXMLAmber.serialize_system" href="#parameterize.HostAmberXMLAmber.serialize_system">serialize_system</a></code></li>
<li><code><a title="parameterize.HostAmberXMLAmber.write_reparameterised_system_xml" href="#parameterize.HostAmberXMLAmber.write_reparameterised_system_xml">write_reparameterised_system_xml</a></code></li>
<li><code><a title="parameterize.HostAmberXMLAmber.write_system_params" href="#parameterize.HostAmberXMLAmber.write_system_params">write_system_params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.MergeHostGuestTopology" href="#parameterize.MergeHostGuestTopology">MergeHostGuestTopology</a></code></h4>
<ul class="">
<li><code><a title="parameterize.MergeHostGuestTopology.merge_topology_files" href="#parameterize.MergeHostGuestTopology.merge_topology_files">merge_topology_files</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.ParameterizeGuest" href="#parameterize.ParameterizeGuest">ParameterizeGuest</a></code></h4>
<ul class="">
<li><code><a title="parameterize.ParameterizeGuest.get_atom_names" href="#parameterize.ParameterizeGuest.get_atom_names">get_atom_names</a></code></li>
<li><code><a title="parameterize.ParameterizeGuest.get_bond_angle_params" href="#parameterize.ParameterizeGuest.get_bond_angle_params">get_bond_angle_params</a></code></li>
<li><code><a title="parameterize.ParameterizeGuest.get_bond_angles" href="#parameterize.ParameterizeGuest.get_bond_angles">get_bond_angles</a></code></li>
<li><code><a title="parameterize.ParameterizeGuest.get_charges" href="#parameterize.ParameterizeGuest.get_charges">get_charges</a></code></li>
<li><code><a title="parameterize.ParameterizeGuest.get_hessian" href="#parameterize.ParameterizeGuest.get_hessian">get_hessian</a></code></li>
<li><code><a title="parameterize.ParameterizeGuest.get_proper_dihedrals" href="#parameterize.ParameterizeGuest.get_proper_dihedrals">get_proper_dihedrals</a></code></li>
<li><code><a title="parameterize.ParameterizeGuest.get_unprocessed_hessian" href="#parameterize.ParameterizeGuest.get_unprocessed_hessian">get_unprocessed_hessian</a></code></li>
<li><code><a title="parameterize.ParameterizeGuest.get_xyz" href="#parameterize.ParameterizeGuest.get_xyz">get_xyz</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.ParameterizeHost" href="#parameterize.ParameterizeHost">ParameterizeHost</a></code></h4>
<ul class="">
<li><code><a title="parameterize.ParameterizeHost.get_atom_names" href="#parameterize.ParameterizeHost.get_atom_names">get_atom_names</a></code></li>
<li><code><a title="parameterize.ParameterizeHost.get_bond_angle_params" href="#parameterize.ParameterizeHost.get_bond_angle_params">get_bond_angle_params</a></code></li>
<li><code><a title="parameterize.ParameterizeHost.get_bond_angles" href="#parameterize.ParameterizeHost.get_bond_angles">get_bond_angles</a></code></li>
<li><code><a title="parameterize.ParameterizeHost.get_charges" href="#parameterize.ParameterizeHost.get_charges">get_charges</a></code></li>
<li><code><a title="parameterize.ParameterizeHost.get_hessian" href="#parameterize.ParameterizeHost.get_hessian">get_hessian</a></code></li>
<li><code><a title="parameterize.ParameterizeHost.get_unprocessed_hessian" href="#parameterize.ParameterizeHost.get_unprocessed_hessian">get_unprocessed_hessian</a></code></li>
<li><code><a title="parameterize.ParameterizeHost.get_xyz" href="#parameterize.ParameterizeHost.get_xyz">get_xyz</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.PrepareGaussianGuest" href="#parameterize.PrepareGaussianGuest">PrepareGaussianGuest</a></code></h4>
<ul class="">
<li><code><a title="parameterize.PrepareGaussianGuest.get_fchk" href="#parameterize.PrepareGaussianGuest.get_fchk">get_fchk</a></code></li>
<li><code><a title="parameterize.PrepareGaussianGuest.run_gaussian" href="#parameterize.PrepareGaussianGuest.run_gaussian">run_gaussian</a></code></li>
<li><code><a title="parameterize.PrepareGaussianGuest.write_input" href="#parameterize.PrepareGaussianGuest.write_input">write_input</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.PrepareGaussianHost" href="#parameterize.PrepareGaussianHost">PrepareGaussianHost</a></code></h4>
<ul class="">
<li><code><a title="parameterize.PrepareGaussianHost.get_fchk" href="#parameterize.PrepareGaussianHost.get_fchk">get_fchk</a></code></li>
<li><code><a title="parameterize.PrepareGaussianHost.run_gaussian" href="#parameterize.PrepareGaussianHost.run_gaussian">run_gaussian</a></code></li>
<li><code><a title="parameterize.PrepareGaussianHost.write_input" href="#parameterize.PrepareGaussianHost.write_input">write_input</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.PrepareGaussianHostGuest" href="#parameterize.PrepareGaussianHostGuest">PrepareGaussianHostGuest</a></code></h4>
<ul class="">
<li><code><a title="parameterize.PrepareGaussianHostGuest.get_fchk" href="#parameterize.PrepareGaussianHostGuest.get_fchk">get_fchk</a></code></li>
<li><code><a title="parameterize.PrepareGaussianHostGuest.get_qm_host_guest_charges" href="#parameterize.PrepareGaussianHostGuest.get_qm_host_guest_charges">get_qm_host_guest_charges</a></code></li>
<li><code><a title="parameterize.PrepareGaussianHostGuest.run_gaussian" href="#parameterize.PrepareGaussianHostGuest.run_gaussian">run_gaussian</a></code></li>
<li><code><a title="parameterize.PrepareGaussianHostGuest.write_input" href="#parameterize.PrepareGaussianHostGuest.write_input">write_input</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.PrepareQMMM" href="#parameterize.PrepareQMMM">PrepareQMMM</a></code></h4>
<ul class="">
<li><code><a title="parameterize.PrepareQMMM.clean_up" href="#parameterize.PrepareQMMM.clean_up">clean_up</a></code></li>
<li><code><a title="parameterize.PrepareQMMM.create_host_guest" href="#parameterize.PrepareQMMM.create_host_guest">create_host_guest</a></code></li>
<li><code><a title="parameterize.PrepareQMMM.get_guest_coord" href="#parameterize.PrepareQMMM.get_guest_coord">get_guest_coord</a></code></li>
<li><code><a title="parameterize.PrepareQMMM.get_host_mm_region_atoms" href="#parameterize.PrepareQMMM.get_host_mm_region_atoms">get_host_mm_region_atoms</a></code></li>
<li><code><a title="parameterize.PrepareQMMM.get_host_qm_mm_atoms" href="#parameterize.PrepareQMMM.get_host_qm_mm_atoms">get_host_qm_mm_atoms</a></code></li>
<li><code><a title="parameterize.PrepareQMMM.get_qm_mm_regions" href="#parameterize.PrepareQMMM.get_qm_mm_regions">get_qm_mm_regions</a></code></li>
<li><code><a title="parameterize.PrepareQMMM.get_qm_resids" href="#parameterize.PrepareQMMM.get_qm_resids">get_qm_resids</a></code></li>
<li><code><a title="parameterize.PrepareQMMM.realign_guest" href="#parameterize.PrepareQMMM.realign_guest">realign_guest</a></code></li>
<li><code><a title="parameterize.PrepareQMMM.save_host_mm_regions_pdbs" href="#parameterize.PrepareQMMM.save_host_mm_regions_pdbs">save_host_mm_regions_pdbs</a></code></li>
<li><code><a title="parameterize.PrepareQMMM.save_host_pdbs" href="#parameterize.PrepareQMMM.save_host_pdbs">save_host_pdbs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.RunOpenMMSims" href="#parameterize.RunOpenMMSims">RunOpenMMSims</a></code></h4>
<ul class="">
<li><code><a title="parameterize.RunOpenMMSims.run_openmm_prmtop_inpcrd" href="#parameterize.RunOpenMMSims.run_openmm_prmtop_inpcrd">run_openmm_prmtop_inpcrd</a></code></li>
<li><code><a title="parameterize.RunOpenMMSims.run_openmm_prmtop_pdb" href="#parameterize.RunOpenMMSims.run_openmm_prmtop_pdb">run_openmm_prmtop_pdb</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.TorsionDriveParams" href="#parameterize.TorsionDriveParams">TorsionDriveParams</a></code></h4>
<ul class="">
<li><code><a title="parameterize.TorsionDriveParams.write_reparams_torsion_lines" href="#parameterize.TorsionDriveParams.write_reparams_torsion_lines">write_reparams_torsion_lines</a></code></li>
<li><code><a title="parameterize.TorsionDriveParams.write_reparams_torsion_lines_charged" href="#parameterize.TorsionDriveParams.write_reparams_torsion_lines_charged">write_reparams_torsion_lines_charged</a></code></li>
<li><code><a title="parameterize.TorsionDriveParams.write_torsional_reparams" href="#parameterize.TorsionDriveParams.write_torsional_reparams">write_torsional_reparams</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="parameterize.TorsionDriveSims" href="#parameterize.TorsionDriveSims">TorsionDriveSims</a></code></h4>
<ul class="">
<li><code><a title="parameterize.TorsionDriveSims.create_non_H_bonded_torsion_drive_dir" href="#parameterize.TorsionDriveSims.create_non_H_bonded_torsion_drive_dir">create_non_H_bonded_torsion_drive_dir</a></code></li>
<li><code><a title="parameterize.TorsionDriveSims.create_non_H_torsion_drive_dir" href="#parameterize.TorsionDriveSims.create_non_H_torsion_drive_dir">create_non_H_torsion_drive_dir</a></code></li>
<li><code><a title="parameterize.TorsionDriveSims.create_torsion_drive_dir" href="#parameterize.TorsionDriveSims.create_torsion_drive_dir">create_torsion_drive_dir</a></code></li>
<li><code><a title="parameterize.TorsionDriveSims.run_torsion_sim" href="#parameterize.TorsionDriveSims.run_torsion_sim">run_torsion_sim</a></code></li>
<li><code><a title="parameterize.TorsionDriveSims.write_psi4_input" href="#parameterize.TorsionDriveSims.write_psi4_input">write_psi4_input</a></code></li>
<li><code><a title="parameterize.TorsionDriveSims.write_tor_params_txt" href="#parameterize.TorsionDriveSims.write_tor_params_txt">write_tor_params_txt</a></code></li>
<li><code><a title="parameterize.TorsionDriveSims.write_torsion_drive_run_file" href="#parameterize.TorsionDriveSims.write_torsion_drive_run_file">write_torsion_drive_run_file</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>